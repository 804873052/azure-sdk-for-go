//go:build go1.13
// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// AFDCustomDomainsCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDCustomDomainsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDCustomDomainsCreateResponse, error)
}

type afdCustomDomainsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdCustomDomainsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdCustomDomainsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdCustomDomainsCreatePoller) FinalResponse(ctx context.Context) (AFDCustomDomainsCreateResponse, error) {
	respType := AFDCustomDomainsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDDomain)
	if err != nil {
		return AFDCustomDomainsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdCustomDomainsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdCustomDomainsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsCreateResponse, error) {
	respType := AFDCustomDomainsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDDomain)
	if err != nil {
		return AFDCustomDomainsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDCustomDomainsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDCustomDomainsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (AFDCustomDomainsDeleteResponse, error)
}

type afdCustomDomainsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *afdCustomDomainsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdCustomDomainsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdCustomDomainsDeletePoller) FinalResponse(ctx context.Context) (AFDCustomDomainsDeleteResponse, error) {
	respType := AFDCustomDomainsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDCustomDomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdCustomDomainsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdCustomDomainsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsDeleteResponse, error) {
	respType := AFDCustomDomainsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return AFDCustomDomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDCustomDomainsRefreshValidationTokenPoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsRefreshValidationTokenPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDCustomDomainsRefreshValidationTokenResponse will be returned.
	FinalResponse(ctx context.Context) (AFDCustomDomainsRefreshValidationTokenResponse, error)
}

type afdCustomDomainsRefreshValidationTokenPoller struct {
	pt *armcore.LROPoller
}

func (p *afdCustomDomainsRefreshValidationTokenPoller) Done() bool {
	return p.pt.Done()
}

func (p *afdCustomDomainsRefreshValidationTokenPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdCustomDomainsRefreshValidationTokenPoller) FinalResponse(ctx context.Context) (AFDCustomDomainsRefreshValidationTokenResponse, error) {
	respType := AFDCustomDomainsRefreshValidationTokenResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ValidationToken)
	if err != nil {
		return AFDCustomDomainsRefreshValidationTokenResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdCustomDomainsRefreshValidationTokenPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdCustomDomainsRefreshValidationTokenPoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsRefreshValidationTokenResponse, error) {
	respType := AFDCustomDomainsRefreshValidationTokenResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ValidationToken)
	if err != nil {
		return AFDCustomDomainsRefreshValidationTokenResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDCustomDomainsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDCustomDomainsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDCustomDomainsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDCustomDomainsUpdateResponse, error)
}

type afdCustomDomainsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdCustomDomainsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdCustomDomainsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdCustomDomainsUpdatePoller) FinalResponse(ctx context.Context) (AFDCustomDomainsUpdateResponse, error) {
	respType := AFDCustomDomainsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDDomain)
	if err != nil {
		return AFDCustomDomainsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdCustomDomainsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdCustomDomainsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDCustomDomainsUpdateResponse, error) {
	respType := AFDCustomDomainsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDDomain)
	if err != nil {
		return AFDCustomDomainsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDEndpointsCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDEndpointsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDEndpointsCreateResponse, error)
}

type afdEndpointsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdEndpointsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdEndpointsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdEndpointsCreatePoller) FinalResponse(ctx context.Context) (AFDEndpointsCreateResponse, error) {
	respType := AFDEndpointsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDEndpoint)
	if err != nil {
		return AFDEndpointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdEndpointsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdEndpointsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsCreateResponse, error) {
	respType := AFDEndpointsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDEndpoint)
	if err != nil {
		return AFDEndpointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDEndpointsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDEndpointsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (AFDEndpointsDeleteResponse, error)
}

type afdEndpointsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *afdEndpointsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdEndpointsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdEndpointsDeletePoller) FinalResponse(ctx context.Context) (AFDEndpointsDeleteResponse, error) {
	respType := AFDEndpointsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDEndpointsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdEndpointsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdEndpointsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsDeleteResponse, error) {
	respType := AFDEndpointsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return AFDEndpointsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDEndpointsPurgeContentPoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsPurgeContentPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDEndpointsPurgeContentResponse will be returned.
	FinalResponse(ctx context.Context) (AFDEndpointsPurgeContentResponse, error)
}

type afdEndpointsPurgeContentPoller struct {
	pt *armcore.LROPoller
}

func (p *afdEndpointsPurgeContentPoller) Done() bool {
	return p.pt.Done()
}

func (p *afdEndpointsPurgeContentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdEndpointsPurgeContentPoller) FinalResponse(ctx context.Context) (AFDEndpointsPurgeContentResponse, error) {
	respType := AFDEndpointsPurgeContentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDEndpointsPurgeContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdEndpointsPurgeContentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdEndpointsPurgeContentPoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsPurgeContentResponse, error) {
	respType := AFDEndpointsPurgeContentResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return AFDEndpointsPurgeContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDEndpointsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDEndpointsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDEndpointsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDEndpointsUpdateResponse, error)
}

type afdEndpointsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdEndpointsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdEndpointsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdEndpointsUpdatePoller) FinalResponse(ctx context.Context) (AFDEndpointsUpdateResponse, error) {
	respType := AFDEndpointsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDEndpoint)
	if err != nil {
		return AFDEndpointsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdEndpointsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdEndpointsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDEndpointsUpdateResponse, error) {
	respType := AFDEndpointsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDEndpoint)
	if err != nil {
		return AFDEndpointsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDOriginGroupsCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginGroupsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDOriginGroupsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDOriginGroupsCreateResponse, error)
}

type afdOriginGroupsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdOriginGroupsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdOriginGroupsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdOriginGroupsCreatePoller) FinalResponse(ctx context.Context) (AFDOriginGroupsCreateResponse, error) {
	respType := AFDOriginGroupsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOriginGroup)
	if err != nil {
		return AFDOriginGroupsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdOriginGroupsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdOriginGroupsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsCreateResponse, error) {
	respType := AFDOriginGroupsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDOriginGroup)
	if err != nil {
		return AFDOriginGroupsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDOriginGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDOriginGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (AFDOriginGroupsDeleteResponse, error)
}

type afdOriginGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *afdOriginGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdOriginGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdOriginGroupsDeletePoller) FinalResponse(ctx context.Context) (AFDOriginGroupsDeleteResponse, error) {
	respType := AFDOriginGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDOriginGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdOriginGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdOriginGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsDeleteResponse, error) {
	respType := AFDOriginGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return AFDOriginGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDOriginGroupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginGroupsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDOriginGroupsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDOriginGroupsUpdateResponse, error)
}

type afdOriginGroupsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdOriginGroupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdOriginGroupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdOriginGroupsUpdatePoller) FinalResponse(ctx context.Context) (AFDOriginGroupsUpdateResponse, error) {
	respType := AFDOriginGroupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOriginGroup)
	if err != nil {
		return AFDOriginGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdOriginGroupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdOriginGroupsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginGroupsUpdateResponse, error) {
	respType := AFDOriginGroupsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDOriginGroup)
	if err != nil {
		return AFDOriginGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDOriginsCreatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDOriginsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDOriginsCreateResponse, error)
}

type afdOriginsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdOriginsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdOriginsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdOriginsCreatePoller) FinalResponse(ctx context.Context) (AFDOriginsCreateResponse, error) {
	respType := AFDOriginsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOrigin)
	if err != nil {
		return AFDOriginsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdOriginsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdOriginsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsCreateResponse, error) {
	respType := AFDOriginsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDOrigin)
	if err != nil {
		return AFDOriginsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDOriginsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDOriginsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (AFDOriginsDeleteResponse, error)
}

type afdOriginsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *afdOriginsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdOriginsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdOriginsDeletePoller) FinalResponse(ctx context.Context) (AFDOriginsDeleteResponse, error) {
	respType := AFDOriginsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AFDOriginsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdOriginsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdOriginsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsDeleteResponse, error) {
	respType := AFDOriginsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return AFDOriginsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AFDOriginsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AFDOriginsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AFDOriginsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (AFDOriginsUpdateResponse, error)
}

type afdOriginsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *afdOriginsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *afdOriginsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *afdOriginsUpdatePoller) FinalResponse(ctx context.Context) (AFDOriginsUpdateResponse, error) {
	respType := AFDOriginsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AFDOrigin)
	if err != nil {
		return AFDOriginsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *afdOriginsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *afdOriginsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AFDOriginsUpdateResponse, error) {
	respType := AFDOriginsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AFDOrigin)
	if err != nil {
		return AFDOriginsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomDomainsCreatePoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomDomainsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (CustomDomainsCreateResponse, error)
}

type customDomainsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *customDomainsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *customDomainsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *customDomainsCreatePoller) FinalResponse(ctx context.Context) (CustomDomainsCreateResponse, error) {
	respType := CustomDomainsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *customDomainsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customDomainsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsCreateResponse, error) {
	respType := CustomDomainsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomDomainsDeletePoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomDomainsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (CustomDomainsDeleteResponse, error)
}

type customDomainsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *customDomainsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *customDomainsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *customDomainsDeletePoller) FinalResponse(ctx context.Context) (CustomDomainsDeleteResponse, error) {
	respType := CustomDomainsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *customDomainsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customDomainsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsDeleteResponse, error) {
	respType := CustomDomainsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomDomainsDisableCustomHTTPSPoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsDisableCustomHTTPSPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomDomainsDisableCustomHTTPSResponse will be returned.
	FinalResponse(ctx context.Context) (CustomDomainsDisableCustomHTTPSResponse, error)
}

type customDomainsDisableCustomHTTPSPoller struct {
	pt *armcore.LROPoller
}

func (p *customDomainsDisableCustomHTTPSPoller) Done() bool {
	return p.pt.Done()
}

func (p *customDomainsDisableCustomHTTPSPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *customDomainsDisableCustomHTTPSPoller) FinalResponse(ctx context.Context) (CustomDomainsDisableCustomHTTPSResponse, error) {
	respType := CustomDomainsDisableCustomHTTPSResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsDisableCustomHTTPSResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *customDomainsDisableCustomHTTPSPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customDomainsDisableCustomHTTPSPoller) pollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsDisableCustomHTTPSResponse, error) {
	respType := CustomDomainsDisableCustomHTTPSResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsDisableCustomHTTPSResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomDomainsEnableCustomHTTPSPoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsEnableCustomHTTPSPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomDomainsEnableCustomHTTPSResponse will be returned.
	FinalResponse(ctx context.Context) (CustomDomainsEnableCustomHTTPSResponse, error)
}

type customDomainsEnableCustomHTTPSPoller struct {
	pt *armcore.LROPoller
}

func (p *customDomainsEnableCustomHTTPSPoller) Done() bool {
	return p.pt.Done()
}

func (p *customDomainsEnableCustomHTTPSPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *customDomainsEnableCustomHTTPSPoller) FinalResponse(ctx context.Context) (CustomDomainsEnableCustomHTTPSResponse, error) {
	respType := CustomDomainsEnableCustomHTTPSResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsEnableCustomHTTPSResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *customDomainsEnableCustomHTTPSPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customDomainsEnableCustomHTTPSPoller) pollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsEnableCustomHTTPSResponse, error) {
	respType := CustomDomainsEnableCustomHTTPSResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CustomDomain)
	if err != nil {
		return CustomDomainsEnableCustomHTTPSResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EndpointsCreatePoller provides polling facilities until the operation reaches a terminal state.
type EndpointsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EndpointsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (EndpointsCreateResponse, error)
}

type endpointsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *endpointsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *endpointsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *endpointsCreatePoller) FinalResponse(ctx context.Context) (EndpointsCreateResponse, error) {
	respType := EndpointsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *endpointsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *endpointsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EndpointsCreateResponse, error) {
	respType := EndpointsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return EndpointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EndpointsDeletePoller provides polling facilities until the operation reaches a terminal state.
type EndpointsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EndpointsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (EndpointsDeleteResponse, error)
}

type endpointsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *endpointsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *endpointsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *endpointsDeletePoller) FinalResponse(ctx context.Context) (EndpointsDeleteResponse, error) {
	respType := EndpointsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EndpointsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *endpointsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *endpointsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EndpointsDeleteResponse, error) {
	respType := EndpointsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return EndpointsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EndpointsLoadContentPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsLoadContentPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EndpointsLoadContentResponse will be returned.
	FinalResponse(ctx context.Context) (EndpointsLoadContentResponse, error)
}

type endpointsLoadContentPoller struct {
	pt *armcore.LROPoller
}

func (p *endpointsLoadContentPoller) Done() bool {
	return p.pt.Done()
}

func (p *endpointsLoadContentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *endpointsLoadContentPoller) FinalResponse(ctx context.Context) (EndpointsLoadContentResponse, error) {
	respType := EndpointsLoadContentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EndpointsLoadContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *endpointsLoadContentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *endpointsLoadContentPoller) pollUntilDone(ctx context.Context, freq time.Duration) (EndpointsLoadContentResponse, error) {
	respType := EndpointsLoadContentResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return EndpointsLoadContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EndpointsPurgeContentPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsPurgeContentPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EndpointsPurgeContentResponse will be returned.
	FinalResponse(ctx context.Context) (EndpointsPurgeContentResponse, error)
}

type endpointsPurgeContentPoller struct {
	pt *armcore.LROPoller
}

func (p *endpointsPurgeContentPoller) Done() bool {
	return p.pt.Done()
}

func (p *endpointsPurgeContentPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *endpointsPurgeContentPoller) FinalResponse(ctx context.Context) (EndpointsPurgeContentResponse, error) {
	respType := EndpointsPurgeContentResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EndpointsPurgeContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *endpointsPurgeContentPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *endpointsPurgeContentPoller) pollUntilDone(ctx context.Context, freq time.Duration) (EndpointsPurgeContentResponse, error) {
	respType := EndpointsPurgeContentResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return EndpointsPurgeContentResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EndpointsStartPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsStartPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EndpointsStartResponse will be returned.
	FinalResponse(ctx context.Context) (EndpointsStartResponse, error)
}

type endpointsStartPoller struct {
	pt *armcore.LROPoller
}

func (p *endpointsStartPoller) Done() bool {
	return p.pt.Done()
}

func (p *endpointsStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *endpointsStartPoller) FinalResponse(ctx context.Context) (EndpointsStartResponse, error) {
	respType := EndpointsStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *endpointsStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *endpointsStartPoller) pollUntilDone(ctx context.Context, freq time.Duration) (EndpointsStartResponse, error) {
	respType := EndpointsStartResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return EndpointsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EndpointsStopPoller provides polling facilities until the operation reaches a terminal state.
type EndpointsStopPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EndpointsStopResponse will be returned.
	FinalResponse(ctx context.Context) (EndpointsStopResponse, error)
}

type endpointsStopPoller struct {
	pt *armcore.LROPoller
}

func (p *endpointsStopPoller) Done() bool {
	return p.pt.Done()
}

func (p *endpointsStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *endpointsStopPoller) FinalResponse(ctx context.Context) (EndpointsStopResponse, error) {
	respType := EndpointsStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *endpointsStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *endpointsStopPoller) pollUntilDone(ctx context.Context, freq time.Duration) (EndpointsStopResponse, error) {
	respType := EndpointsStopResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return EndpointsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EndpointsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type EndpointsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EndpointsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (EndpointsUpdateResponse, error)
}

type endpointsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *endpointsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *endpointsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *endpointsUpdatePoller) FinalResponse(ctx context.Context) (EndpointsUpdateResponse, error) {
	respType := EndpointsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Endpoint)
	if err != nil {
		return EndpointsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *endpointsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *endpointsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EndpointsUpdateResponse, error) {
	respType := EndpointsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Endpoint)
	if err != nil {
		return EndpointsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OriginGroupsCreatePoller provides polling facilities until the operation reaches a terminal state.
type OriginGroupsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OriginGroupsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (OriginGroupsCreateResponse, error)
}

type originGroupsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *originGroupsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *originGroupsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *originGroupsCreatePoller) FinalResponse(ctx context.Context) (OriginGroupsCreateResponse, error) {
	respType := OriginGroupsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OriginGroup)
	if err != nil {
		return OriginGroupsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *originGroupsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *originGroupsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsCreateResponse, error) {
	respType := OriginGroupsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.OriginGroup)
	if err != nil {
		return OriginGroupsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OriginGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type OriginGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OriginGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (OriginGroupsDeleteResponse, error)
}

type originGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *originGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *originGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *originGroupsDeletePoller) FinalResponse(ctx context.Context) (OriginGroupsDeleteResponse, error) {
	respType := OriginGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return OriginGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *originGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *originGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsDeleteResponse, error) {
	respType := OriginGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return OriginGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OriginGroupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OriginGroupsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OriginGroupsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (OriginGroupsUpdateResponse, error)
}

type originGroupsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *originGroupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *originGroupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *originGroupsUpdatePoller) FinalResponse(ctx context.Context) (OriginGroupsUpdateResponse, error) {
	respType := OriginGroupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OriginGroup)
	if err != nil {
		return OriginGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *originGroupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *originGroupsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OriginGroupsUpdateResponse, error) {
	respType := OriginGroupsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.OriginGroup)
	if err != nil {
		return OriginGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OriginsCreatePoller provides polling facilities until the operation reaches a terminal state.
type OriginsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OriginsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (OriginsCreateResponse, error)
}

type originsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *originsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *originsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *originsCreatePoller) FinalResponse(ctx context.Context) (OriginsCreateResponse, error) {
	respType := OriginsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Origin)
	if err != nil {
		return OriginsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *originsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *originsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OriginsCreateResponse, error) {
	respType := OriginsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Origin)
	if err != nil {
		return OriginsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OriginsDeletePoller provides polling facilities until the operation reaches a terminal state.
type OriginsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OriginsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (OriginsDeleteResponse, error)
}

type originsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *originsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *originsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *originsDeletePoller) FinalResponse(ctx context.Context) (OriginsDeleteResponse, error) {
	respType := OriginsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return OriginsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *originsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *originsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OriginsDeleteResponse, error) {
	respType := OriginsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return OriginsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OriginsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OriginsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OriginsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (OriginsUpdateResponse, error)
}

type originsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *originsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *originsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *originsUpdatePoller) FinalResponse(ctx context.Context) (OriginsUpdateResponse, error) {
	respType := OriginsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Origin)
	if err != nil {
		return OriginsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *originsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *originsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OriginsUpdateResponse, error) {
	respType := OriginsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Origin)
	if err != nil {
		return OriginsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PoliciesCreateOrUpdateResponse, error)
}

type policiesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *policiesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *policiesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *policiesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PoliciesCreateOrUpdateResponse, error) {
	respType := PoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CdnWebApplicationFirewallPolicy)
	if err != nil {
		return PoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *policiesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *policiesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PoliciesCreateOrUpdateResponse, error) {
	respType := PoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CdnWebApplicationFirewallPolicy)
	if err != nil {
		return PoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PoliciesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PoliciesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PoliciesUpdateResponse, error)
}

type policiesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *policiesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *policiesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *policiesUpdatePoller) FinalResponse(ctx context.Context) (PoliciesUpdateResponse, error) {
	respType := PoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CdnWebApplicationFirewallPolicy)
	if err != nil {
		return PoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *policiesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *policiesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PoliciesUpdateResponse, error) {
	respType := PoliciesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CdnWebApplicationFirewallPolicy)
	if err != nil {
		return PoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ProfilesCreatePoller provides polling facilities until the operation reaches a terminal state.
type ProfilesCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ProfilesCreateResponse will be returned.
	FinalResponse(ctx context.Context) (ProfilesCreateResponse, error)
}

type profilesCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *profilesCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *profilesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *profilesCreatePoller) FinalResponse(ctx context.Context) (ProfilesCreateResponse, error) {
	respType := ProfilesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Profile)
	if err != nil {
		return ProfilesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *profilesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *profilesCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ProfilesCreateResponse, error) {
	respType := ProfilesCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return ProfilesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ProfilesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ProfilesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ProfilesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ProfilesDeleteResponse, error)
}

type profilesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *profilesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *profilesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *profilesDeletePoller) FinalResponse(ctx context.Context) (ProfilesDeleteResponse, error) {
	respType := ProfilesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ProfilesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *profilesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *profilesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ProfilesDeleteResponse, error) {
	respType := ProfilesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ProfilesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ProfilesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ProfilesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ProfilesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ProfilesUpdateResponse, error)
}

type profilesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *profilesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *profilesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *profilesUpdatePoller) FinalResponse(ctx context.Context) (ProfilesUpdateResponse, error) {
	respType := ProfilesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Profile)
	if err != nil {
		return ProfilesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *profilesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *profilesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ProfilesUpdateResponse, error) {
	respType := ProfilesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Profile)
	if err != nil {
		return ProfilesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RoutesCreatePoller provides polling facilities until the operation reaches a terminal state.
type RoutesCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RoutesCreateResponse will be returned.
	FinalResponse(ctx context.Context) (RoutesCreateResponse, error)
}

type routesCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *routesCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *routesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routesCreatePoller) FinalResponse(ctx context.Context) (RoutesCreateResponse, error) {
	respType := RoutesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Route)
	if err != nil {
		return RoutesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routesCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RoutesCreateResponse, error) {
	respType := RoutesCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return RoutesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RoutesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RoutesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RoutesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (RoutesDeleteResponse, error)
}

type routesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *routesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *routesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routesDeletePoller) FinalResponse(ctx context.Context) (RoutesDeleteResponse, error) {
	respType := RoutesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RoutesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RoutesDeleteResponse, error) {
	respType := RoutesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return RoutesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RoutesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RoutesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RoutesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (RoutesUpdateResponse, error)
}

type routesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *routesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *routesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routesUpdatePoller) FinalResponse(ctx context.Context) (RoutesUpdateResponse, error) {
	respType := RoutesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Route)
	if err != nil {
		return RoutesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RoutesUpdateResponse, error) {
	respType := RoutesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return RoutesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RuleSetsCreatePoller provides polling facilities until the operation reaches a terminal state.
type RuleSetsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RuleSetsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (RuleSetsCreateResponse, error)
}

type ruleSetsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *ruleSetsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *ruleSetsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ruleSetsCreatePoller) FinalResponse(ctx context.Context) (RuleSetsCreateResponse, error) {
	respType := RuleSetsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RuleSet)
	if err != nil {
		return RuleSetsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ruleSetsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ruleSetsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RuleSetsCreateResponse, error) {
	respType := RuleSetsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.RuleSet)
	if err != nil {
		return RuleSetsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RuleSetsDeletePoller provides polling facilities until the operation reaches a terminal state.
type RuleSetsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RuleSetsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (RuleSetsDeleteResponse, error)
}

type ruleSetsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *ruleSetsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *ruleSetsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ruleSetsDeletePoller) FinalResponse(ctx context.Context) (RuleSetsDeleteResponse, error) {
	respType := RuleSetsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RuleSetsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ruleSetsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ruleSetsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RuleSetsDeleteResponse, error) {
	respType := RuleSetsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return RuleSetsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RulesCreatePoller provides polling facilities until the operation reaches a terminal state.
type RulesCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RulesCreateResponse will be returned.
	FinalResponse(ctx context.Context) (RulesCreateResponse, error)
}

type rulesCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *rulesCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *rulesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *rulesCreatePoller) FinalResponse(ctx context.Context) (RulesCreateResponse, error) {
	respType := RulesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Rule)
	if err != nil {
		return RulesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *rulesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *rulesCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RulesCreateResponse, error) {
	respType := RulesCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Rule)
	if err != nil {
		return RulesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RulesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RulesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (RulesDeleteResponse, error)
}

type rulesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *rulesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *rulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *rulesDeletePoller) FinalResponse(ctx context.Context) (RulesDeleteResponse, error) {
	respType := RulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *rulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *rulesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RulesDeleteResponse, error) {
	respType := RulesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return RulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RulesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RulesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RulesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (RulesUpdateResponse, error)
}

type rulesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *rulesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *rulesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *rulesUpdatePoller) FinalResponse(ctx context.Context) (RulesUpdateResponse, error) {
	respType := RulesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Rule)
	if err != nil {
		return RulesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *rulesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *rulesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RulesUpdateResponse, error) {
	respType := RulesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Rule)
	if err != nil {
		return RulesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecretsCreatePoller provides polling facilities until the operation reaches a terminal state.
type SecretsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecretsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (SecretsCreateResponse, error)
}

type secretsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *secretsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *secretsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *secretsCreatePoller) FinalResponse(ctx context.Context) (SecretsCreateResponse, error) {
	respType := SecretsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Secret)
	if err != nil {
		return SecretsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *secretsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *secretsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecretsCreateResponse, error) {
	respType := SecretsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Secret)
	if err != nil {
		return SecretsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecretsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecretsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecretsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SecretsDeleteResponse, error)
}

type secretsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *secretsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *secretsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *secretsDeletePoller) FinalResponse(ctx context.Context) (SecretsDeleteResponse, error) {
	respType := SecretsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecretsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *secretsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *secretsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecretsDeleteResponse, error) {
	respType := SecretsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SecretsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecretsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecretsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecretsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SecretsUpdateResponse, error)
}

type secretsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *secretsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *secretsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *secretsUpdatePoller) FinalResponse(ctx context.Context) (SecretsUpdateResponse, error) {
	respType := SecretsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Secret)
	if err != nil {
		return SecretsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *secretsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *secretsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecretsUpdateResponse, error) {
	respType := SecretsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Secret)
	if err != nil {
		return SecretsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityPoliciesCreatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPoliciesCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityPoliciesCreateResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityPoliciesCreateResponse, error)
}

type securityPoliciesCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *securityPoliciesCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *securityPoliciesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *securityPoliciesCreatePoller) FinalResponse(ctx context.Context) (SecurityPoliciesCreateResponse, error) {
	respType := SecurityPoliciesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityPolicy)
	if err != nil {
		return SecurityPoliciesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *securityPoliciesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityPoliciesCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesCreateResponse, error) {
	respType := SecurityPoliciesCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SecurityPolicy)
	if err != nil {
		return SecurityPoliciesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPoliciesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityPoliciesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityPoliciesDeleteResponse, error)
}

type securityPoliciesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *securityPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *securityPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *securityPoliciesDeletePoller) FinalResponse(ctx context.Context) (SecurityPoliciesDeleteResponse, error) {
	respType := SecurityPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecurityPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *securityPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityPoliciesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesDeleteResponse, error) {
	respType := SecurityPoliciesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SecurityPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityPoliciesPatchPoller provides polling facilities until the operation reaches a terminal state.
type SecurityPoliciesPatchPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityPoliciesPatchResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityPoliciesPatchResponse, error)
}

type securityPoliciesPatchPoller struct {
	pt *armcore.LROPoller
}

func (p *securityPoliciesPatchPoller) Done() bool {
	return p.pt.Done()
}

func (p *securityPoliciesPatchPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *securityPoliciesPatchPoller) FinalResponse(ctx context.Context) (SecurityPoliciesPatchResponse, error) {
	respType := SecurityPoliciesPatchResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityPolicy)
	if err != nil {
		return SecurityPoliciesPatchResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *securityPoliciesPatchPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityPoliciesPatchPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecurityPoliciesPatchResponse, error) {
	respType := SecurityPoliciesPatchResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SecurityPolicy)
	if err != nil {
		return SecurityPoliciesPatchResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
