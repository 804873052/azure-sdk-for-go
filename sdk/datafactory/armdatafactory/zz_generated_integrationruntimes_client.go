//go:build go1.13
// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatafactory

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// IntegrationRuntimesClient contains the methods for the IntegrationRuntimes group.
// Don't use this type directly, use NewIntegrationRuntimesClient() instead.
type IntegrationRuntimesClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewIntegrationRuntimesClient creates a new instance of IntegrationRuntimesClient with the specified values.
func NewIntegrationRuntimesClient(con *armcore.Connection, subscriptionID string) *IntegrationRuntimesClient {
	return &IntegrationRuntimesClient{con: con, subscriptionID: subscriptionID}
}

// CreateLinkedIntegrationRuntime - Create a linked integration runtime entry in a shared integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) CreateLinkedIntegrationRuntime(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, createLinkedIntegrationRuntimeRequest CreateLinkedIntegrationRuntimeRequest, options *IntegrationRuntimesCreateLinkedIntegrationRuntimeOptions) (IntegrationRuntimesCreateLinkedIntegrationRuntimeResponse, error) {
	req, err := client.createLinkedIntegrationRuntimeCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, createLinkedIntegrationRuntimeRequest, options)
	if err != nil {
		return IntegrationRuntimesCreateLinkedIntegrationRuntimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesCreateLinkedIntegrationRuntimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesCreateLinkedIntegrationRuntimeResponse{}, client.createLinkedIntegrationRuntimeHandleError(resp)
	}
	return client.createLinkedIntegrationRuntimeHandleResponse(resp)
}

// createLinkedIntegrationRuntimeCreateRequest creates the CreateLinkedIntegrationRuntime request.
func (client *IntegrationRuntimesClient) createLinkedIntegrationRuntimeCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, createLinkedIntegrationRuntimeRequest CreateLinkedIntegrationRuntimeRequest, options *IntegrationRuntimesCreateLinkedIntegrationRuntimeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/linkedIntegrationRuntime"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(createLinkedIntegrationRuntimeRequest)
}

// createLinkedIntegrationRuntimeHandleResponse handles the CreateLinkedIntegrationRuntime response.
func (client *IntegrationRuntimesClient) createLinkedIntegrationRuntimeHandleResponse(resp *azcore.Response) (IntegrationRuntimesCreateLinkedIntegrationRuntimeResponse, error) {
	result := IntegrationRuntimesCreateLinkedIntegrationRuntimeResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeStatusResponse); err != nil {
		return IntegrationRuntimesCreateLinkedIntegrationRuntimeResponse{}, err
	}
	return result, nil
}

// createLinkedIntegrationRuntimeHandleError handles the CreateLinkedIntegrationRuntime error response.
func (client *IntegrationRuntimesClient) createLinkedIntegrationRuntimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdate - Creates or updates an integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, integrationRuntime IntegrationRuntimeResource, options *IntegrationRuntimesCreateOrUpdateOptions) (IntegrationRuntimesCreateOrUpdateResponse, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, integrationRuntime, options)
	if err != nil {
		return IntegrationRuntimesCreateOrUpdateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesCreateOrUpdateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesCreateOrUpdateResponse{}, client.createOrUpdateHandleError(resp)
	}
	return client.createOrUpdateHandleResponse(resp)
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *IntegrationRuntimesClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, integrationRuntime IntegrationRuntimeResource, options *IntegrationRuntimesCreateOrUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(integrationRuntime)
}

// createOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *IntegrationRuntimesClient) createOrUpdateHandleResponse(resp *azcore.Response) (IntegrationRuntimesCreateOrUpdateResponse, error) {
	result := IntegrationRuntimesCreateOrUpdateResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeResource); err != nil {
		return IntegrationRuntimesCreateOrUpdateResponse{}, err
	}
	return result, nil
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *IntegrationRuntimesClient) createOrUpdateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Delete - Deletes an integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) Delete(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesDeleteOptions) (IntegrationRuntimesDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesDeleteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesDeleteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return IntegrationRuntimesDeleteResponse{}, client.deleteHandleError(resp)
	}
	return IntegrationRuntimesDeleteResponse{RawResponse: resp.Response}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *IntegrationRuntimesClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesDeleteOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *IntegrationRuntimesClient) deleteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Get - Gets an integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) Get(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetOptions) (IntegrationRuntimesGetResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesGetResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesGetResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNotModified) {
		return IntegrationRuntimesGetResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *IntegrationRuntimesClient) getCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *IntegrationRuntimesClient) getHandleResponse(resp *azcore.Response) (IntegrationRuntimesGetResponse, error) {
	result := IntegrationRuntimesGetResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeResource); err != nil {
		return IntegrationRuntimesGetResponse{}, err
	}
	return result, nil
}

// getHandleError handles the Get error response.
func (client *IntegrationRuntimesClient) getHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetConnectionInfo - Gets the on-premises integration runtime connection information for encrypting the on-premises data source credentials.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) GetConnectionInfo(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetConnectionInfoOptions) (IntegrationRuntimesGetConnectionInfoResponse, error) {
	req, err := client.getConnectionInfoCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesGetConnectionInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesGetConnectionInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesGetConnectionInfoResponse{}, client.getConnectionInfoHandleError(resp)
	}
	return client.getConnectionInfoHandleResponse(resp)
}

// getConnectionInfoCreateRequest creates the GetConnectionInfo request.
func (client *IntegrationRuntimesClient) getConnectionInfoCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetConnectionInfoOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/getConnectionInfo"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getConnectionInfoHandleResponse handles the GetConnectionInfo response.
func (client *IntegrationRuntimesClient) getConnectionInfoHandleResponse(resp *azcore.Response) (IntegrationRuntimesGetConnectionInfoResponse, error) {
	result := IntegrationRuntimesGetConnectionInfoResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeConnectionInfo); err != nil {
		return IntegrationRuntimesGetConnectionInfoResponse{}, err
	}
	return result, nil
}

// getConnectionInfoHandleError handles the GetConnectionInfo error response.
func (client *IntegrationRuntimesClient) getConnectionInfoHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMonitoringData - Get the integration runtime monitoring data, which includes the monitor data for all the nodes under this integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) GetMonitoringData(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetMonitoringDataOptions) (IntegrationRuntimesGetMonitoringDataResponse, error) {
	req, err := client.getMonitoringDataCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesGetMonitoringDataResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesGetMonitoringDataResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesGetMonitoringDataResponse{}, client.getMonitoringDataHandleError(resp)
	}
	return client.getMonitoringDataHandleResponse(resp)
}

// getMonitoringDataCreateRequest creates the GetMonitoringData request.
func (client *IntegrationRuntimesClient) getMonitoringDataCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetMonitoringDataOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/monitoringData"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMonitoringDataHandleResponse handles the GetMonitoringData response.
func (client *IntegrationRuntimesClient) getMonitoringDataHandleResponse(resp *azcore.Response) (IntegrationRuntimesGetMonitoringDataResponse, error) {
	result := IntegrationRuntimesGetMonitoringDataResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeMonitoringData); err != nil {
		return IntegrationRuntimesGetMonitoringDataResponse{}, err
	}
	return result, nil
}

// getMonitoringDataHandleError handles the GetMonitoringData error response.
func (client *IntegrationRuntimesClient) getMonitoringDataHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetStatus - Gets detailed status information for an integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) GetStatus(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetStatusOptions) (IntegrationRuntimesGetStatusResponse, error) {
	req, err := client.getStatusCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesGetStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesGetStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesGetStatusResponse{}, client.getStatusHandleError(resp)
	}
	return client.getStatusHandleResponse(resp)
}

// getStatusCreateRequest creates the GetStatus request.
func (client *IntegrationRuntimesClient) getStatusCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesGetStatusOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/getStatus"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getStatusHandleResponse handles the GetStatus response.
func (client *IntegrationRuntimesClient) getStatusHandleResponse(resp *azcore.Response) (IntegrationRuntimesGetStatusResponse, error) {
	result := IntegrationRuntimesGetStatusResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeStatusResponse); err != nil {
		return IntegrationRuntimesGetStatusResponse{}, err
	}
	return result, nil
}

// getStatusHandleError handles the GetStatus error response.
func (client *IntegrationRuntimesClient) getStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListAuthKeys - Retrieves the authentication keys for an integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) ListAuthKeys(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesListAuthKeysOptions) (IntegrationRuntimesListAuthKeysResponse, error) {
	req, err := client.listAuthKeysCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesListAuthKeysResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesListAuthKeysResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesListAuthKeysResponse{}, client.listAuthKeysHandleError(resp)
	}
	return client.listAuthKeysHandleResponse(resp)
}

// listAuthKeysCreateRequest creates the ListAuthKeys request.
func (client *IntegrationRuntimesClient) listAuthKeysCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesListAuthKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/listAuthKeys"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAuthKeysHandleResponse handles the ListAuthKeys response.
func (client *IntegrationRuntimesClient) listAuthKeysHandleResponse(resp *azcore.Response) (IntegrationRuntimesListAuthKeysResponse, error) {
	result := IntegrationRuntimesListAuthKeysResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeAuthKeys); err != nil {
		return IntegrationRuntimesListAuthKeysResponse{}, err
	}
	return result, nil
}

// listAuthKeysHandleError handles the ListAuthKeys error response.
func (client *IntegrationRuntimesClient) listAuthKeysHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListByFactory - Lists integration runtimes.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) ListByFactory(resourceGroupName string, factoryName string, options *IntegrationRuntimesListByFactoryOptions) IntegrationRuntimesListByFactoryPager {
	return &integrationRuntimesListByFactoryPager{
		client: client,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listByFactoryCreateRequest(ctx, resourceGroupName, factoryName, options)
		},
		advancer: func(ctx context.Context, resp IntegrationRuntimesListByFactoryResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.IntegrationRuntimeListResponse.NextLink)
		},
	}
}

// listByFactoryCreateRequest creates the ListByFactory request.
func (client *IntegrationRuntimesClient) listByFactoryCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, options *IntegrationRuntimesListByFactoryOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listByFactoryHandleResponse handles the ListByFactory response.
func (client *IntegrationRuntimesClient) listByFactoryHandleResponse(resp *azcore.Response) (IntegrationRuntimesListByFactoryResponse, error) {
	result := IntegrationRuntimesListByFactoryResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeListResponse); err != nil {
		return IntegrationRuntimesListByFactoryResponse{}, err
	}
	return result, nil
}

// listByFactoryHandleError handles the ListByFactory error response.
func (client *IntegrationRuntimesClient) listByFactoryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListOutboundNetworkDependenciesEndpoints - Gets the list of outbound network dependencies for a given Azure-SSIS integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) ListOutboundNetworkDependenciesEndpoints(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesListOutboundNetworkDependenciesEndpointsOptions) (IntegrationRuntimesListOutboundNetworkDependenciesEndpointsResponse, error) {
	req, err := client.listOutboundNetworkDependenciesEndpointsCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesListOutboundNetworkDependenciesEndpointsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesListOutboundNetworkDependenciesEndpointsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesListOutboundNetworkDependenciesEndpointsResponse{}, client.listOutboundNetworkDependenciesEndpointsHandleError(resp)
	}
	return client.listOutboundNetworkDependenciesEndpointsHandleResponse(resp)
}

// listOutboundNetworkDependenciesEndpointsCreateRequest creates the ListOutboundNetworkDependenciesEndpoints request.
func (client *IntegrationRuntimesClient) listOutboundNetworkDependenciesEndpointsCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesListOutboundNetworkDependenciesEndpointsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/outboundNetworkDependenciesEndpoints"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listOutboundNetworkDependenciesEndpointsHandleResponse handles the ListOutboundNetworkDependenciesEndpoints response.
func (client *IntegrationRuntimesClient) listOutboundNetworkDependenciesEndpointsHandleResponse(resp *azcore.Response) (IntegrationRuntimesListOutboundNetworkDependenciesEndpointsResponse, error) {
	result := IntegrationRuntimesListOutboundNetworkDependenciesEndpointsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse); err != nil {
		return IntegrationRuntimesListOutboundNetworkDependenciesEndpointsResponse{}, err
	}
	return result, nil
}

// listOutboundNetworkDependenciesEndpointsHandleError handles the ListOutboundNetworkDependenciesEndpoints error response.
func (client *IntegrationRuntimesClient) listOutboundNetworkDependenciesEndpointsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RegenerateAuthKey - Regenerates the authentication key for an integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) RegenerateAuthKey(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, regenerateKeyParameters IntegrationRuntimeRegenerateKeyParameters, options *IntegrationRuntimesRegenerateAuthKeyOptions) (IntegrationRuntimesRegenerateAuthKeyResponse, error) {
	req, err := client.regenerateAuthKeyCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, regenerateKeyParameters, options)
	if err != nil {
		return IntegrationRuntimesRegenerateAuthKeyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesRegenerateAuthKeyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesRegenerateAuthKeyResponse{}, client.regenerateAuthKeyHandleError(resp)
	}
	return client.regenerateAuthKeyHandleResponse(resp)
}

// regenerateAuthKeyCreateRequest creates the RegenerateAuthKey request.
func (client *IntegrationRuntimesClient) regenerateAuthKeyCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, regenerateKeyParameters IntegrationRuntimeRegenerateKeyParameters, options *IntegrationRuntimesRegenerateAuthKeyOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/regenerateAuthKey"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(regenerateKeyParameters)
}

// regenerateAuthKeyHandleResponse handles the RegenerateAuthKey response.
func (client *IntegrationRuntimesClient) regenerateAuthKeyHandleResponse(resp *azcore.Response) (IntegrationRuntimesRegenerateAuthKeyResponse, error) {
	result := IntegrationRuntimesRegenerateAuthKeyResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeAuthKeys); err != nil {
		return IntegrationRuntimesRegenerateAuthKeyResponse{}, err
	}
	return result, nil
}

// regenerateAuthKeyHandleError handles the RegenerateAuthKey error response.
func (client *IntegrationRuntimesClient) regenerateAuthKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RemoveLinks - Remove all linked integration runtimes under specific data factory in a self-hosted integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) RemoveLinks(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, linkedIntegrationRuntimeRequest LinkedIntegrationRuntimeRequest, options *IntegrationRuntimesRemoveLinksOptions) (IntegrationRuntimesRemoveLinksResponse, error) {
	req, err := client.removeLinksCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, linkedIntegrationRuntimeRequest, options)
	if err != nil {
		return IntegrationRuntimesRemoveLinksResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesRemoveLinksResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesRemoveLinksResponse{}, client.removeLinksHandleError(resp)
	}
	return IntegrationRuntimesRemoveLinksResponse{RawResponse: resp.Response}, nil
}

// removeLinksCreateRequest creates the RemoveLinks request.
func (client *IntegrationRuntimesClient) removeLinksCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, linkedIntegrationRuntimeRequest LinkedIntegrationRuntimeRequest, options *IntegrationRuntimesRemoveLinksOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/removeLinks"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(linkedIntegrationRuntimeRequest)
}

// removeLinksHandleError handles the RemoveLinks error response.
func (client *IntegrationRuntimesClient) removeLinksHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginStart - Starts a ManagedReserved type integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) BeginStart(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesBeginStartOptions) (IntegrationRuntimesStartPollerResponse, error) {
	resp, err := client.start(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesStartPollerResponse{}, err
	}
	result := IntegrationRuntimesStartPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("IntegrationRuntimesClient.Start", "", resp, client.con.Pipeline(), client.startHandleError)
	if err != nil {
		return IntegrationRuntimesStartPollerResponse{}, err
	}
	poller := &integrationRuntimesStartPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (IntegrationRuntimesStartResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeStart creates a new IntegrationRuntimesStartPoller from the specified resume token.
// token - The value must come from a previous call to IntegrationRuntimesStartPoller.ResumeToken().
func (client *IntegrationRuntimesClient) ResumeStart(ctx context.Context, token string) (IntegrationRuntimesStartPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("IntegrationRuntimesClient.Start", token, client.con.Pipeline(), client.startHandleError)
	if err != nil {
		return IntegrationRuntimesStartPollerResponse{}, err
	}
	poller := &integrationRuntimesStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return IntegrationRuntimesStartPollerResponse{}, err
	}
	result := IntegrationRuntimesStartPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (IntegrationRuntimesStartResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Start - Starts a ManagedReserved type integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) start(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesBeginStartOptions) (*azcore.Response, error) {
	req, err := client.startCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.startHandleError(resp)
	}
	return resp, nil
}

// startCreateRequest creates the Start request.
func (client *IntegrationRuntimesClient) startCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesBeginStartOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/start"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startHandleError handles the Start error response.
func (client *IntegrationRuntimesClient) startHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginStop - Stops a ManagedReserved type integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) BeginStop(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesBeginStopOptions) (IntegrationRuntimesStopPollerResponse, error) {
	resp, err := client.stop(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesStopPollerResponse{}, err
	}
	result := IntegrationRuntimesStopPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("IntegrationRuntimesClient.Stop", "", resp, client.con.Pipeline(), client.stopHandleError)
	if err != nil {
		return IntegrationRuntimesStopPollerResponse{}, err
	}
	poller := &integrationRuntimesStopPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (IntegrationRuntimesStopResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeStop creates a new IntegrationRuntimesStopPoller from the specified resume token.
// token - The value must come from a previous call to IntegrationRuntimesStopPoller.ResumeToken().
func (client *IntegrationRuntimesClient) ResumeStop(ctx context.Context, token string) (IntegrationRuntimesStopPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("IntegrationRuntimesClient.Stop", token, client.con.Pipeline(), client.stopHandleError)
	if err != nil {
		return IntegrationRuntimesStopPollerResponse{}, err
	}
	poller := &integrationRuntimesStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return IntegrationRuntimesStopPollerResponse{}, err
	}
	result := IntegrationRuntimesStopPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (IntegrationRuntimesStopResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Stop - Stops a ManagedReserved type integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) stop(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesBeginStopOptions) (*azcore.Response, error) {
	req, err := client.stopCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.stopHandleError(resp)
	}
	return resp, nil
}

// stopCreateRequest creates the Stop request.
func (client *IntegrationRuntimesClient) stopCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesBeginStopOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/stop"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopHandleError handles the Stop error response.
func (client *IntegrationRuntimesClient) stopHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SyncCredentials - Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across
// all worker nodes with those available on the dispatcher node.
// If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using
// this API directly.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) SyncCredentials(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesSyncCredentialsOptions) (IntegrationRuntimesSyncCredentialsResponse, error) {
	req, err := client.syncCredentialsCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesSyncCredentialsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesSyncCredentialsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesSyncCredentialsResponse{}, client.syncCredentialsHandleError(resp)
	}
	return IntegrationRuntimesSyncCredentialsResponse{RawResponse: resp.Response}, nil
}

// syncCredentialsCreateRequest creates the SyncCredentials request.
func (client *IntegrationRuntimesClient) syncCredentialsCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesSyncCredentialsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/syncCredentials"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// syncCredentialsHandleError handles the SyncCredentials error response.
func (client *IntegrationRuntimesClient) syncCredentialsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Update - Updates an integration runtime.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) Update(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, updateIntegrationRuntimeRequest UpdateIntegrationRuntimeRequest, options *IntegrationRuntimesUpdateOptions) (IntegrationRuntimesUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, updateIntegrationRuntimeRequest, options)
	if err != nil {
		return IntegrationRuntimesUpdateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesUpdateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesUpdateResponse{}, client.updateHandleError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *IntegrationRuntimesClient) updateCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, updateIntegrationRuntimeRequest UpdateIntegrationRuntimeRequest, options *IntegrationRuntimesUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(updateIntegrationRuntimeRequest)
}

// updateHandleResponse handles the Update response.
func (client *IntegrationRuntimesClient) updateHandleResponse(resp *azcore.Response) (IntegrationRuntimesUpdateResponse, error) {
	result := IntegrationRuntimesUpdateResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.IntegrationRuntimeResource); err != nil {
		return IntegrationRuntimesUpdateResponse{}, err
	}
	return result, nil
}

// updateHandleError handles the Update error response.
func (client *IntegrationRuntimesClient) updateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Upgrade - Upgrade self-hosted integration runtime to latest version if availability.
// If the operation fails it returns the *CloudError error type.
func (client *IntegrationRuntimesClient) Upgrade(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesUpgradeOptions) (IntegrationRuntimesUpgradeResponse, error) {
	req, err := client.upgradeCreateRequest(ctx, resourceGroupName, factoryName, integrationRuntimeName, options)
	if err != nil {
		return IntegrationRuntimesUpgradeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IntegrationRuntimesUpgradeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IntegrationRuntimesUpgradeResponse{}, client.upgradeHandleError(resp)
	}
	return IntegrationRuntimesUpgradeResponse{RawResponse: resp.Response}, nil
}

// upgradeCreateRequest creates the Upgrade request.
func (client *IntegrationRuntimesClient) upgradeCreateRequest(ctx context.Context, resourceGroupName string, factoryName string, integrationRuntimeName string, options *IntegrationRuntimesUpgradeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}/upgrade"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if factoryName == "" {
		return nil, errors.New("parameter factoryName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{factoryName}", url.PathEscape(factoryName))
	if integrationRuntimeName == "" {
		return nil, errors.New("parameter integrationRuntimeName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{integrationRuntimeName}", url.PathEscape(integrationRuntimeName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-06-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// upgradeHandleError handles the Upgrade error response.
func (client *IntegrationRuntimesClient) upgradeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType.InnerError); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
