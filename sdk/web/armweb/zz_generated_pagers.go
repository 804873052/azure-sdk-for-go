// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// APIKVReferenceCollectionPager provides iteration over APIKVReferenceCollection pages.
type APIKVReferenceCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current APIKVReferenceCollectionResponse.
	PageResponse() APIKVReferenceCollectionResponse
}

type apikvReferenceCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type apikvReferenceCollectionHandleError func(*azcore.Response) error

type apikvReferenceCollectionHandleResponse func(*azcore.Response) (APIKVReferenceCollectionResponse, error)

type apikvReferenceCollectionAdvancePage func(context.Context, APIKVReferenceCollectionResponse) (*azcore.Request, error)

type apikvReferenceCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester apikvReferenceCollectionCreateRequest
	// callback for handling response errors
	errorer apikvReferenceCollectionHandleError
	// callback for handling the HTTP response
	responder apikvReferenceCollectionHandleResponse
	// callback for advancing to the next page
	advancer apikvReferenceCollectionAdvancePage
	// contains the current response
	current APIKVReferenceCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *apikvReferenceCollectionPager) Err() error {
	return p.err
}

func (p *apikvReferenceCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIKVReferenceCollection.NextLink == nil || len(*p.current.APIKVReferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *apikvReferenceCollectionPager) PageResponse() APIKVReferenceCollectionResponse {
	return p.current
}

// AppServiceCertificateCollectionPager provides iteration over AppServiceCertificateCollection pages.
type AppServiceCertificateCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current AppServiceCertificateCollectionResponse.
	PageResponse() AppServiceCertificateCollectionResponse
}

type appServiceCertificateCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type appServiceCertificateCollectionHandleError func(*azcore.Response) error

type appServiceCertificateCollectionHandleResponse func(*azcore.Response) (AppServiceCertificateCollectionResponse, error)

type appServiceCertificateCollectionAdvancePage func(context.Context, AppServiceCertificateCollectionResponse) (*azcore.Request, error)

type appServiceCertificateCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester appServiceCertificateCollectionCreateRequest
	// callback for handling response errors
	errorer appServiceCertificateCollectionHandleError
	// callback for handling the HTTP response
	responder appServiceCertificateCollectionHandleResponse
	// callback for advancing to the next page
	advancer appServiceCertificateCollectionAdvancePage
	// contains the current response
	current AppServiceCertificateCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *appServiceCertificateCollectionPager) Err() error {
	return p.err
}

func (p *appServiceCertificateCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AppServiceCertificateCollection.NextLink == nil || len(*p.current.AppServiceCertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *appServiceCertificateCollectionPager) PageResponse() AppServiceCertificateCollectionResponse {
	return p.current
}

// AppServiceCertificateOrderCollectionPager provides iteration over AppServiceCertificateOrderCollection pages.
type AppServiceCertificateOrderCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current AppServiceCertificateOrderCollectionResponse.
	PageResponse() AppServiceCertificateOrderCollectionResponse
}

type appServiceCertificateOrderCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type appServiceCertificateOrderCollectionHandleError func(*azcore.Response) error

type appServiceCertificateOrderCollectionHandleResponse func(*azcore.Response) (AppServiceCertificateOrderCollectionResponse, error)

type appServiceCertificateOrderCollectionAdvancePage func(context.Context, AppServiceCertificateOrderCollectionResponse) (*azcore.Request, error)

type appServiceCertificateOrderCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester appServiceCertificateOrderCollectionCreateRequest
	// callback for handling response errors
	errorer appServiceCertificateOrderCollectionHandleError
	// callback for handling the HTTP response
	responder appServiceCertificateOrderCollectionHandleResponse
	// callback for advancing to the next page
	advancer appServiceCertificateOrderCollectionAdvancePage
	// contains the current response
	current AppServiceCertificateOrderCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *appServiceCertificateOrderCollectionPager) Err() error {
	return p.err
}

func (p *appServiceCertificateOrderCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AppServiceCertificateOrderCollection.NextLink == nil || len(*p.current.AppServiceCertificateOrderCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *appServiceCertificateOrderCollectionPager) PageResponse() AppServiceCertificateOrderCollectionResponse {
	return p.current
}

// AppServiceEnvironmentCollectionPager provides iteration over AppServiceEnvironmentCollection pages.
type AppServiceEnvironmentCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current AppServiceEnvironmentCollectionResponse.
	PageResponse() AppServiceEnvironmentCollectionResponse
}

type appServiceEnvironmentCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type appServiceEnvironmentCollectionHandleError func(*azcore.Response) error

type appServiceEnvironmentCollectionHandleResponse func(*azcore.Response) (AppServiceEnvironmentCollectionResponse, error)

type appServiceEnvironmentCollectionAdvancePage func(context.Context, AppServiceEnvironmentCollectionResponse) (*azcore.Request, error)

type appServiceEnvironmentCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester appServiceEnvironmentCollectionCreateRequest
	// callback for handling response errors
	errorer appServiceEnvironmentCollectionHandleError
	// callback for handling the HTTP response
	responder appServiceEnvironmentCollectionHandleResponse
	// callback for advancing to the next page
	advancer appServiceEnvironmentCollectionAdvancePage
	// contains the current response
	current AppServiceEnvironmentCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *appServiceEnvironmentCollectionPager) Err() error {
	return p.err
}

func (p *appServiceEnvironmentCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AppServiceEnvironmentCollection.NextLink == nil || len(*p.current.AppServiceEnvironmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *appServiceEnvironmentCollectionPager) PageResponse() AppServiceEnvironmentCollectionResponse {
	return p.current
}

// AppServicePlanCollectionPager provides iteration over AppServicePlanCollection pages.
type AppServicePlanCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current AppServicePlanCollectionResponse.
	PageResponse() AppServicePlanCollectionResponse
}

type appServicePlanCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type appServicePlanCollectionHandleError func(*azcore.Response) error

type appServicePlanCollectionHandleResponse func(*azcore.Response) (AppServicePlanCollectionResponse, error)

type appServicePlanCollectionAdvancePage func(context.Context, AppServicePlanCollectionResponse) (*azcore.Request, error)

type appServicePlanCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester appServicePlanCollectionCreateRequest
	// callback for handling response errors
	errorer appServicePlanCollectionHandleError
	// callback for handling the HTTP response
	responder appServicePlanCollectionHandleResponse
	// callback for advancing to the next page
	advancer appServicePlanCollectionAdvancePage
	// contains the current response
	current AppServicePlanCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *appServicePlanCollectionPager) Err() error {
	return p.err
}

func (p *appServicePlanCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AppServicePlanCollection.NextLink == nil || len(*p.current.AppServicePlanCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *appServicePlanCollectionPager) PageResponse() AppServicePlanCollectionResponse {
	return p.current
}

// ApplicationStackCollectionPager provides iteration over ApplicationStackCollection pages.
type ApplicationStackCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ApplicationStackCollectionResponse.
	PageResponse() ApplicationStackCollectionResponse
}

type applicationStackCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type applicationStackCollectionHandleError func(*azcore.Response) error

type applicationStackCollectionHandleResponse func(*azcore.Response) (ApplicationStackCollectionResponse, error)

type applicationStackCollectionAdvancePage func(context.Context, ApplicationStackCollectionResponse) (*azcore.Request, error)

type applicationStackCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester applicationStackCollectionCreateRequest
	// callback for handling response errors
	errorer applicationStackCollectionHandleError
	// callback for handling the HTTP response
	responder applicationStackCollectionHandleResponse
	// callback for advancing to the next page
	advancer applicationStackCollectionAdvancePage
	// contains the current response
	current ApplicationStackCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *applicationStackCollectionPager) Err() error {
	return p.err
}

func (p *applicationStackCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationStackCollection.NextLink == nil || len(*p.current.ApplicationStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *applicationStackCollectionPager) PageResponse() ApplicationStackCollectionResponse {
	return p.current
}

// BackupItemCollectionPager provides iteration over BackupItemCollection pages.
type BackupItemCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current BackupItemCollectionResponse.
	PageResponse() BackupItemCollectionResponse
}

type backupItemCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type backupItemCollectionHandleError func(*azcore.Response) error

type backupItemCollectionHandleResponse func(*azcore.Response) (BackupItemCollectionResponse, error)

type backupItemCollectionAdvancePage func(context.Context, BackupItemCollectionResponse) (*azcore.Request, error)

type backupItemCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester backupItemCollectionCreateRequest
	// callback for handling response errors
	errorer backupItemCollectionHandleError
	// callback for handling the HTTP response
	responder backupItemCollectionHandleResponse
	// callback for advancing to the next page
	advancer backupItemCollectionAdvancePage
	// contains the current response
	current BackupItemCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *backupItemCollectionPager) Err() error {
	return p.err
}

func (p *backupItemCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupItemCollection.NextLink == nil || len(*p.current.BackupItemCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *backupItemCollectionPager) PageResponse() BackupItemCollectionResponse {
	return p.current
}

// BillingMeterCollectionPager provides iteration over BillingMeterCollection pages.
type BillingMeterCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current BillingMeterCollectionResponse.
	PageResponse() BillingMeterCollectionResponse
}

type billingMeterCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type billingMeterCollectionHandleError func(*azcore.Response) error

type billingMeterCollectionHandleResponse func(*azcore.Response) (BillingMeterCollectionResponse, error)

type billingMeterCollectionAdvancePage func(context.Context, BillingMeterCollectionResponse) (*azcore.Request, error)

type billingMeterCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester billingMeterCollectionCreateRequest
	// callback for handling response errors
	errorer billingMeterCollectionHandleError
	// callback for handling the HTTP response
	responder billingMeterCollectionHandleResponse
	// callback for advancing to the next page
	advancer billingMeterCollectionAdvancePage
	// contains the current response
	current BillingMeterCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *billingMeterCollectionPager) Err() error {
	return p.err
}

func (p *billingMeterCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BillingMeterCollection.NextLink == nil || len(*p.current.BillingMeterCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *billingMeterCollectionPager) PageResponse() BillingMeterCollectionResponse {
	return p.current
}

// CertificateCollectionPager provides iteration over CertificateCollection pages.
type CertificateCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current CertificateCollectionResponse.
	PageResponse() CertificateCollectionResponse
}

type certificateCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type certificateCollectionHandleError func(*azcore.Response) error

type certificateCollectionHandleResponse func(*azcore.Response) (CertificateCollectionResponse, error)

type certificateCollectionAdvancePage func(context.Context, CertificateCollectionResponse) (*azcore.Request, error)

type certificateCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester certificateCollectionCreateRequest
	// callback for handling response errors
	errorer certificateCollectionHandleError
	// callback for handling the HTTP response
	responder certificateCollectionHandleResponse
	// callback for advancing to the next page
	advancer certificateCollectionAdvancePage
	// contains the current response
	current CertificateCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *certificateCollectionPager) Err() error {
	return p.err
}

func (p *certificateCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateCollection.NextLink == nil || len(*p.current.CertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *certificateCollectionPager) PageResponse() CertificateCollectionResponse {
	return p.current
}

// ContinuousWebJobCollectionPager provides iteration over ContinuousWebJobCollection pages.
type ContinuousWebJobCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ContinuousWebJobCollectionResponse.
	PageResponse() ContinuousWebJobCollectionResponse
}

type continuousWebJobCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type continuousWebJobCollectionHandleError func(*azcore.Response) error

type continuousWebJobCollectionHandleResponse func(*azcore.Response) (ContinuousWebJobCollectionResponse, error)

type continuousWebJobCollectionAdvancePage func(context.Context, ContinuousWebJobCollectionResponse) (*azcore.Request, error)

type continuousWebJobCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester continuousWebJobCollectionCreateRequest
	// callback for handling response errors
	errorer continuousWebJobCollectionHandleError
	// callback for handling the HTTP response
	responder continuousWebJobCollectionHandleResponse
	// callback for advancing to the next page
	advancer continuousWebJobCollectionAdvancePage
	// contains the current response
	current ContinuousWebJobCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *continuousWebJobCollectionPager) Err() error {
	return p.err
}

func (p *continuousWebJobCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContinuousWebJobCollection.NextLink == nil || len(*p.current.ContinuousWebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *continuousWebJobCollectionPager) PageResponse() ContinuousWebJobCollectionResponse {
	return p.current
}

// CsmOperationCollectionPager provides iteration over CsmOperationCollection pages.
type CsmOperationCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current CsmOperationCollectionResponse.
	PageResponse() CsmOperationCollectionResponse
}

type csmOperationCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type csmOperationCollectionHandleError func(*azcore.Response) error

type csmOperationCollectionHandleResponse func(*azcore.Response) (CsmOperationCollectionResponse, error)

type csmOperationCollectionAdvancePage func(context.Context, CsmOperationCollectionResponse) (*azcore.Request, error)

type csmOperationCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester csmOperationCollectionCreateRequest
	// callback for handling response errors
	errorer csmOperationCollectionHandleError
	// callback for handling the HTTP response
	responder csmOperationCollectionHandleResponse
	// callback for advancing to the next page
	advancer csmOperationCollectionAdvancePage
	// contains the current response
	current CsmOperationCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *csmOperationCollectionPager) Err() error {
	return p.err
}

func (p *csmOperationCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmOperationCollection.NextLink == nil || len(*p.current.CsmOperationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *csmOperationCollectionPager) PageResponse() CsmOperationCollectionResponse {
	return p.current
}

// CsmUsageQuotaCollectionPager provides iteration over CsmUsageQuotaCollection pages.
type CsmUsageQuotaCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current CsmUsageQuotaCollectionResponse.
	PageResponse() CsmUsageQuotaCollectionResponse
}

type csmUsageQuotaCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type csmUsageQuotaCollectionHandleError func(*azcore.Response) error

type csmUsageQuotaCollectionHandleResponse func(*azcore.Response) (CsmUsageQuotaCollectionResponse, error)

type csmUsageQuotaCollectionAdvancePage func(context.Context, CsmUsageQuotaCollectionResponse) (*azcore.Request, error)

type csmUsageQuotaCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester csmUsageQuotaCollectionCreateRequest
	// callback for handling response errors
	errorer csmUsageQuotaCollectionHandleError
	// callback for handling the HTTP response
	responder csmUsageQuotaCollectionHandleResponse
	// callback for advancing to the next page
	advancer csmUsageQuotaCollectionAdvancePage
	// contains the current response
	current CsmUsageQuotaCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *csmUsageQuotaCollectionPager) Err() error {
	return p.err
}

func (p *csmUsageQuotaCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CsmUsageQuotaCollection.NextLink == nil || len(*p.current.CsmUsageQuotaCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *csmUsageQuotaCollectionPager) PageResponse() CsmUsageQuotaCollectionResponse {
	return p.current
}

// DeletedWebAppCollectionPager provides iteration over DeletedWebAppCollection pages.
type DeletedWebAppCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DeletedWebAppCollectionResponse.
	PageResponse() DeletedWebAppCollectionResponse
}

type deletedWebAppCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type deletedWebAppCollectionHandleError func(*azcore.Response) error

type deletedWebAppCollectionHandleResponse func(*azcore.Response) (DeletedWebAppCollectionResponse, error)

type deletedWebAppCollectionAdvancePage func(context.Context, DeletedWebAppCollectionResponse) (*azcore.Request, error)

type deletedWebAppCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester deletedWebAppCollectionCreateRequest
	// callback for handling response errors
	errorer deletedWebAppCollectionHandleError
	// callback for handling the HTTP response
	responder deletedWebAppCollectionHandleResponse
	// callback for advancing to the next page
	advancer deletedWebAppCollectionAdvancePage
	// contains the current response
	current DeletedWebAppCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *deletedWebAppCollectionPager) Err() error {
	return p.err
}

func (p *deletedWebAppCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedWebAppCollection.NextLink == nil || len(*p.current.DeletedWebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *deletedWebAppCollectionPager) PageResponse() DeletedWebAppCollectionResponse {
	return p.current
}

// DeploymentCollectionPager provides iteration over DeploymentCollection pages.
type DeploymentCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DeploymentCollectionResponse.
	PageResponse() DeploymentCollectionResponse
}

type deploymentCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type deploymentCollectionHandleError func(*azcore.Response) error

type deploymentCollectionHandleResponse func(*azcore.Response) (DeploymentCollectionResponse, error)

type deploymentCollectionAdvancePage func(context.Context, DeploymentCollectionResponse) (*azcore.Request, error)

type deploymentCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester deploymentCollectionCreateRequest
	// callback for handling response errors
	errorer deploymentCollectionHandleError
	// callback for handling the HTTP response
	responder deploymentCollectionHandleResponse
	// callback for advancing to the next page
	advancer deploymentCollectionAdvancePage
	// contains the current response
	current DeploymentCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *deploymentCollectionPager) Err() error {
	return p.err
}

func (p *deploymentCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentCollection.NextLink == nil || len(*p.current.DeploymentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *deploymentCollectionPager) PageResponse() DeploymentCollectionResponse {
	return p.current
}

// DetectorResponseCollectionPager provides iteration over DetectorResponseCollection pages.
type DetectorResponseCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DetectorResponseCollectionResponse.
	PageResponse() DetectorResponseCollectionResponse
}

type detectorResponseCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type detectorResponseCollectionHandleError func(*azcore.Response) error

type detectorResponseCollectionHandleResponse func(*azcore.Response) (DetectorResponseCollectionResponse, error)

type detectorResponseCollectionAdvancePage func(context.Context, DetectorResponseCollectionResponse) (*azcore.Request, error)

type detectorResponseCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester detectorResponseCollectionCreateRequest
	// callback for handling response errors
	errorer detectorResponseCollectionHandleError
	// callback for handling the HTTP response
	responder detectorResponseCollectionHandleResponse
	// callback for advancing to the next page
	advancer detectorResponseCollectionAdvancePage
	// contains the current response
	current DetectorResponseCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *detectorResponseCollectionPager) Err() error {
	return p.err
}

func (p *detectorResponseCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DetectorResponseCollection.NextLink == nil || len(*p.current.DetectorResponseCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *detectorResponseCollectionPager) PageResponse() DetectorResponseCollectionResponse {
	return p.current
}

// DiagnosticAnalysisCollectionPager provides iteration over DiagnosticAnalysisCollection pages.
type DiagnosticAnalysisCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DiagnosticAnalysisCollectionResponse.
	PageResponse() DiagnosticAnalysisCollectionResponse
}

type diagnosticAnalysisCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type diagnosticAnalysisCollectionHandleError func(*azcore.Response) error

type diagnosticAnalysisCollectionHandleResponse func(*azcore.Response) (DiagnosticAnalysisCollectionResponse, error)

type diagnosticAnalysisCollectionAdvancePage func(context.Context, DiagnosticAnalysisCollectionResponse) (*azcore.Request, error)

type diagnosticAnalysisCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester diagnosticAnalysisCollectionCreateRequest
	// callback for handling response errors
	errorer diagnosticAnalysisCollectionHandleError
	// callback for handling the HTTP response
	responder diagnosticAnalysisCollectionHandleResponse
	// callback for advancing to the next page
	advancer diagnosticAnalysisCollectionAdvancePage
	// contains the current response
	current DiagnosticAnalysisCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *diagnosticAnalysisCollectionPager) Err() error {
	return p.err
}

func (p *diagnosticAnalysisCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticAnalysisCollection.NextLink == nil || len(*p.current.DiagnosticAnalysisCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *diagnosticAnalysisCollectionPager) PageResponse() DiagnosticAnalysisCollectionResponse {
	return p.current
}

// DiagnosticCategoryCollectionPager provides iteration over DiagnosticCategoryCollection pages.
type DiagnosticCategoryCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DiagnosticCategoryCollectionResponse.
	PageResponse() DiagnosticCategoryCollectionResponse
}

type diagnosticCategoryCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type diagnosticCategoryCollectionHandleError func(*azcore.Response) error

type diagnosticCategoryCollectionHandleResponse func(*azcore.Response) (DiagnosticCategoryCollectionResponse, error)

type diagnosticCategoryCollectionAdvancePage func(context.Context, DiagnosticCategoryCollectionResponse) (*azcore.Request, error)

type diagnosticCategoryCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester diagnosticCategoryCollectionCreateRequest
	// callback for handling response errors
	errorer diagnosticCategoryCollectionHandleError
	// callback for handling the HTTP response
	responder diagnosticCategoryCollectionHandleResponse
	// callback for advancing to the next page
	advancer diagnosticCategoryCollectionAdvancePage
	// contains the current response
	current DiagnosticCategoryCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *diagnosticCategoryCollectionPager) Err() error {
	return p.err
}

func (p *diagnosticCategoryCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCategoryCollection.NextLink == nil || len(*p.current.DiagnosticCategoryCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *diagnosticCategoryCollectionPager) PageResponse() DiagnosticCategoryCollectionResponse {
	return p.current
}

// DiagnosticDetectorCollectionPager provides iteration over DiagnosticDetectorCollection pages.
type DiagnosticDetectorCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DiagnosticDetectorCollectionResponse.
	PageResponse() DiagnosticDetectorCollectionResponse
}

type diagnosticDetectorCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type diagnosticDetectorCollectionHandleError func(*azcore.Response) error

type diagnosticDetectorCollectionHandleResponse func(*azcore.Response) (DiagnosticDetectorCollectionResponse, error)

type diagnosticDetectorCollectionAdvancePage func(context.Context, DiagnosticDetectorCollectionResponse) (*azcore.Request, error)

type diagnosticDetectorCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester diagnosticDetectorCollectionCreateRequest
	// callback for handling response errors
	errorer diagnosticDetectorCollectionHandleError
	// callback for handling the HTTP response
	responder diagnosticDetectorCollectionHandleResponse
	// callback for advancing to the next page
	advancer diagnosticDetectorCollectionAdvancePage
	// contains the current response
	current DiagnosticDetectorCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *diagnosticDetectorCollectionPager) Err() error {
	return p.err
}

func (p *diagnosticDetectorCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticDetectorCollection.NextLink == nil || len(*p.current.DiagnosticDetectorCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *diagnosticDetectorCollectionPager) PageResponse() DiagnosticDetectorCollectionResponse {
	return p.current
}

// DomainCollectionPager provides iteration over DomainCollection pages.
type DomainCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DomainCollectionResponse.
	PageResponse() DomainCollectionResponse
}

type domainCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type domainCollectionHandleError func(*azcore.Response) error

type domainCollectionHandleResponse func(*azcore.Response) (DomainCollectionResponse, error)

type domainCollectionAdvancePage func(context.Context, DomainCollectionResponse) (*azcore.Request, error)

type domainCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester domainCollectionCreateRequest
	// callback for handling response errors
	errorer domainCollectionHandleError
	// callback for handling the HTTP response
	responder domainCollectionHandleResponse
	// callback for advancing to the next page
	advancer domainCollectionAdvancePage
	// contains the current response
	current DomainCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *domainCollectionPager) Err() error {
	return p.err
}

func (p *domainCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainCollection.NextLink == nil || len(*p.current.DomainCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *domainCollectionPager) PageResponse() DomainCollectionResponse {
	return p.current
}

// DomainOwnershipIdentifierCollectionPager provides iteration over DomainOwnershipIdentifierCollection pages.
type DomainOwnershipIdentifierCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current DomainOwnershipIdentifierCollectionResponse.
	PageResponse() DomainOwnershipIdentifierCollectionResponse
}

type domainOwnershipIdentifierCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type domainOwnershipIdentifierCollectionHandleError func(*azcore.Response) error

type domainOwnershipIdentifierCollectionHandleResponse func(*azcore.Response) (DomainOwnershipIdentifierCollectionResponse, error)

type domainOwnershipIdentifierCollectionAdvancePage func(context.Context, DomainOwnershipIdentifierCollectionResponse) (*azcore.Request, error)

type domainOwnershipIdentifierCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester domainOwnershipIdentifierCollectionCreateRequest
	// callback for handling response errors
	errorer domainOwnershipIdentifierCollectionHandleError
	// callback for handling the HTTP response
	responder domainOwnershipIdentifierCollectionHandleResponse
	// callback for advancing to the next page
	advancer domainOwnershipIdentifierCollectionAdvancePage
	// contains the current response
	current DomainOwnershipIdentifierCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *domainOwnershipIdentifierCollectionPager) Err() error {
	return p.err
}

func (p *domainOwnershipIdentifierCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainOwnershipIdentifierCollection.NextLink == nil || len(*p.current.DomainOwnershipIdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *domainOwnershipIdentifierCollectionPager) PageResponse() DomainOwnershipIdentifierCollectionResponse {
	return p.current
}

// FunctionAppStackCollectionPager provides iteration over FunctionAppStackCollection pages.
type FunctionAppStackCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current FunctionAppStackCollectionResponse.
	PageResponse() FunctionAppStackCollectionResponse
}

type functionAppStackCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type functionAppStackCollectionHandleError func(*azcore.Response) error

type functionAppStackCollectionHandleResponse func(*azcore.Response) (FunctionAppStackCollectionResponse, error)

type functionAppStackCollectionAdvancePage func(context.Context, FunctionAppStackCollectionResponse) (*azcore.Request, error)

type functionAppStackCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester functionAppStackCollectionCreateRequest
	// callback for handling response errors
	errorer functionAppStackCollectionHandleError
	// callback for handling the HTTP response
	responder functionAppStackCollectionHandleResponse
	// callback for advancing to the next page
	advancer functionAppStackCollectionAdvancePage
	// contains the current response
	current FunctionAppStackCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *functionAppStackCollectionPager) Err() error {
	return p.err
}

func (p *functionAppStackCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FunctionAppStackCollection.NextLink == nil || len(*p.current.FunctionAppStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *functionAppStackCollectionPager) PageResponse() FunctionAppStackCollectionResponse {
	return p.current
}

// FunctionEnvelopeCollectionPager provides iteration over FunctionEnvelopeCollection pages.
type FunctionEnvelopeCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current FunctionEnvelopeCollectionResponse.
	PageResponse() FunctionEnvelopeCollectionResponse
}

type functionEnvelopeCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type functionEnvelopeCollectionHandleError func(*azcore.Response) error

type functionEnvelopeCollectionHandleResponse func(*azcore.Response) (FunctionEnvelopeCollectionResponse, error)

type functionEnvelopeCollectionAdvancePage func(context.Context, FunctionEnvelopeCollectionResponse) (*azcore.Request, error)

type functionEnvelopeCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester functionEnvelopeCollectionCreateRequest
	// callback for handling response errors
	errorer functionEnvelopeCollectionHandleError
	// callback for handling the HTTP response
	responder functionEnvelopeCollectionHandleResponse
	// callback for advancing to the next page
	advancer functionEnvelopeCollectionAdvancePage
	// contains the current response
	current FunctionEnvelopeCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *functionEnvelopeCollectionPager) Err() error {
	return p.err
}

func (p *functionEnvelopeCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FunctionEnvelopeCollection.NextLink == nil || len(*p.current.FunctionEnvelopeCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *functionEnvelopeCollectionPager) PageResponse() FunctionEnvelopeCollectionResponse {
	return p.current
}

// GeoRegionCollectionPager provides iteration over GeoRegionCollection pages.
type GeoRegionCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current GeoRegionCollectionResponse.
	PageResponse() GeoRegionCollectionResponse
}

type geoRegionCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type geoRegionCollectionHandleError func(*azcore.Response) error

type geoRegionCollectionHandleResponse func(*azcore.Response) (GeoRegionCollectionResponse, error)

type geoRegionCollectionAdvancePage func(context.Context, GeoRegionCollectionResponse) (*azcore.Request, error)

type geoRegionCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester geoRegionCollectionCreateRequest
	// callback for handling response errors
	errorer geoRegionCollectionHandleError
	// callback for handling the HTTP response
	responder geoRegionCollectionHandleResponse
	// callback for advancing to the next page
	advancer geoRegionCollectionAdvancePage
	// contains the current response
	current GeoRegionCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *geoRegionCollectionPager) Err() error {
	return p.err
}

func (p *geoRegionCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GeoRegionCollection.NextLink == nil || len(*p.current.GeoRegionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *geoRegionCollectionPager) PageResponse() GeoRegionCollectionResponse {
	return p.current
}

// HostNameBindingCollectionPager provides iteration over HostNameBindingCollection pages.
type HostNameBindingCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current HostNameBindingCollectionResponse.
	PageResponse() HostNameBindingCollectionResponse
}

type hostNameBindingCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type hostNameBindingCollectionHandleError func(*azcore.Response) error

type hostNameBindingCollectionHandleResponse func(*azcore.Response) (HostNameBindingCollectionResponse, error)

type hostNameBindingCollectionAdvancePage func(context.Context, HostNameBindingCollectionResponse) (*azcore.Request, error)

type hostNameBindingCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester hostNameBindingCollectionCreateRequest
	// callback for handling response errors
	errorer hostNameBindingCollectionHandleError
	// callback for handling the HTTP response
	responder hostNameBindingCollectionHandleResponse
	// callback for advancing to the next page
	advancer hostNameBindingCollectionAdvancePage
	// contains the current response
	current HostNameBindingCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *hostNameBindingCollectionPager) Err() error {
	return p.err
}

func (p *hostNameBindingCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HostNameBindingCollection.NextLink == nil || len(*p.current.HostNameBindingCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *hostNameBindingCollectionPager) PageResponse() HostNameBindingCollectionResponse {
	return p.current
}

// HybridConnectionCollectionPager provides iteration over HybridConnectionCollection pages.
type HybridConnectionCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current HybridConnectionCollectionResponse.
	PageResponse() HybridConnectionCollectionResponse
}

type hybridConnectionCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type hybridConnectionCollectionHandleError func(*azcore.Response) error

type hybridConnectionCollectionHandleResponse func(*azcore.Response) (HybridConnectionCollectionResponse, error)

type hybridConnectionCollectionAdvancePage func(context.Context, HybridConnectionCollectionResponse) (*azcore.Request, error)

type hybridConnectionCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester hybridConnectionCollectionCreateRequest
	// callback for handling response errors
	errorer hybridConnectionCollectionHandleError
	// callback for handling the HTTP response
	responder hybridConnectionCollectionHandleResponse
	// callback for advancing to the next page
	advancer hybridConnectionCollectionAdvancePage
	// contains the current response
	current HybridConnectionCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *hybridConnectionCollectionPager) Err() error {
	return p.err
}

func (p *hybridConnectionCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HybridConnectionCollection.NextLink == nil || len(*p.current.HybridConnectionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *hybridConnectionCollectionPager) PageResponse() HybridConnectionCollectionResponse {
	return p.current
}

// IdentifierCollectionPager provides iteration over IdentifierCollection pages.
type IdentifierCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current IdentifierCollectionResponse.
	PageResponse() IdentifierCollectionResponse
}

type identifierCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type identifierCollectionHandleError func(*azcore.Response) error

type identifierCollectionHandleResponse func(*azcore.Response) (IdentifierCollectionResponse, error)

type identifierCollectionAdvancePage func(context.Context, IdentifierCollectionResponse) (*azcore.Request, error)

type identifierCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester identifierCollectionCreateRequest
	// callback for handling response errors
	errorer identifierCollectionHandleError
	// callback for handling the HTTP response
	responder identifierCollectionHandleResponse
	// callback for advancing to the next page
	advancer identifierCollectionAdvancePage
	// contains the current response
	current IdentifierCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *identifierCollectionPager) Err() error {
	return p.err
}

func (p *identifierCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IdentifierCollection.NextLink == nil || len(*p.current.IdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *identifierCollectionPager) PageResponse() IdentifierCollectionResponse {
	return p.current
}

// InboundEnvironmentEndpointCollectionPager provides iteration over InboundEnvironmentEndpointCollection pages.
type InboundEnvironmentEndpointCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current InboundEnvironmentEndpointCollectionResponse.
	PageResponse() InboundEnvironmentEndpointCollectionResponse
}

type inboundEnvironmentEndpointCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type inboundEnvironmentEndpointCollectionHandleError func(*azcore.Response) error

type inboundEnvironmentEndpointCollectionHandleResponse func(*azcore.Response) (InboundEnvironmentEndpointCollectionResponse, error)

type inboundEnvironmentEndpointCollectionAdvancePage func(context.Context, InboundEnvironmentEndpointCollectionResponse) (*azcore.Request, error)

type inboundEnvironmentEndpointCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester inboundEnvironmentEndpointCollectionCreateRequest
	// callback for handling response errors
	errorer inboundEnvironmentEndpointCollectionHandleError
	// callback for handling the HTTP response
	responder inboundEnvironmentEndpointCollectionHandleResponse
	// callback for advancing to the next page
	advancer inboundEnvironmentEndpointCollectionAdvancePage
	// contains the current response
	current InboundEnvironmentEndpointCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *inboundEnvironmentEndpointCollectionPager) Err() error {
	return p.err
}

func (p *inboundEnvironmentEndpointCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InboundEnvironmentEndpointCollection.NextLink == nil || len(*p.current.InboundEnvironmentEndpointCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *inboundEnvironmentEndpointCollectionPager) PageResponse() InboundEnvironmentEndpointCollectionResponse {
	return p.current
}

// KubeEnvironmentCollectionPager provides iteration over KubeEnvironmentCollection pages.
type KubeEnvironmentCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current KubeEnvironmentCollectionResponse.
	PageResponse() KubeEnvironmentCollectionResponse
}

type kubeEnvironmentCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type kubeEnvironmentCollectionHandleError func(*azcore.Response) error

type kubeEnvironmentCollectionHandleResponse func(*azcore.Response) (KubeEnvironmentCollectionResponse, error)

type kubeEnvironmentCollectionAdvancePage func(context.Context, KubeEnvironmentCollectionResponse) (*azcore.Request, error)

type kubeEnvironmentCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester kubeEnvironmentCollectionCreateRequest
	// callback for handling response errors
	errorer kubeEnvironmentCollectionHandleError
	// callback for handling the HTTP response
	responder kubeEnvironmentCollectionHandleResponse
	// callback for advancing to the next page
	advancer kubeEnvironmentCollectionAdvancePage
	// contains the current response
	current KubeEnvironmentCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *kubeEnvironmentCollectionPager) Err() error {
	return p.err
}

func (p *kubeEnvironmentCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.KubeEnvironmentCollection.NextLink == nil || len(*p.current.KubeEnvironmentCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *kubeEnvironmentCollectionPager) PageResponse() KubeEnvironmentCollectionResponse {
	return p.current
}

// NameIdentifierCollectionPager provides iteration over NameIdentifierCollection pages.
type NameIdentifierCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current NameIdentifierCollectionResponse.
	PageResponse() NameIdentifierCollectionResponse
}

type nameIdentifierCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type nameIdentifierCollectionHandleError func(*azcore.Response) error

type nameIdentifierCollectionHandleResponse func(*azcore.Response) (NameIdentifierCollectionResponse, error)

type nameIdentifierCollectionAdvancePage func(context.Context, NameIdentifierCollectionResponse) (*azcore.Request, error)

type nameIdentifierCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester nameIdentifierCollectionCreateRequest
	// callback for handling response errors
	errorer nameIdentifierCollectionHandleError
	// callback for handling the HTTP response
	responder nameIdentifierCollectionHandleResponse
	// callback for advancing to the next page
	advancer nameIdentifierCollectionAdvancePage
	// contains the current response
	current NameIdentifierCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *nameIdentifierCollectionPager) Err() error {
	return p.err
}

func (p *nameIdentifierCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NameIdentifierCollection.NextLink == nil || len(*p.current.NameIdentifierCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *nameIdentifierCollectionPager) PageResponse() NameIdentifierCollectionResponse {
	return p.current
}

// OutboundEnvironmentEndpointCollectionPager provides iteration over OutboundEnvironmentEndpointCollection pages.
type OutboundEnvironmentEndpointCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current OutboundEnvironmentEndpointCollectionResponse.
	PageResponse() OutboundEnvironmentEndpointCollectionResponse
}

type outboundEnvironmentEndpointCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type outboundEnvironmentEndpointCollectionHandleError func(*azcore.Response) error

type outboundEnvironmentEndpointCollectionHandleResponse func(*azcore.Response) (OutboundEnvironmentEndpointCollectionResponse, error)

type outboundEnvironmentEndpointCollectionAdvancePage func(context.Context, OutboundEnvironmentEndpointCollectionResponse) (*azcore.Request, error)

type outboundEnvironmentEndpointCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester outboundEnvironmentEndpointCollectionCreateRequest
	// callback for handling response errors
	errorer outboundEnvironmentEndpointCollectionHandleError
	// callback for handling the HTTP response
	responder outboundEnvironmentEndpointCollectionHandleResponse
	// callback for advancing to the next page
	advancer outboundEnvironmentEndpointCollectionAdvancePage
	// contains the current response
	current OutboundEnvironmentEndpointCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *outboundEnvironmentEndpointCollectionPager) Err() error {
	return p.err
}

func (p *outboundEnvironmentEndpointCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OutboundEnvironmentEndpointCollection.NextLink == nil || len(*p.current.OutboundEnvironmentEndpointCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *outboundEnvironmentEndpointCollectionPager) PageResponse() OutboundEnvironmentEndpointCollectionResponse {
	return p.current
}

// PerfMonCounterCollectionPager provides iteration over PerfMonCounterCollection pages.
type PerfMonCounterCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current PerfMonCounterCollectionResponse.
	PageResponse() PerfMonCounterCollectionResponse
}

type perfMonCounterCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type perfMonCounterCollectionHandleError func(*azcore.Response) error

type perfMonCounterCollectionHandleResponse func(*azcore.Response) (PerfMonCounterCollectionResponse, error)

type perfMonCounterCollectionAdvancePage func(context.Context, PerfMonCounterCollectionResponse) (*azcore.Request, error)

type perfMonCounterCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester perfMonCounterCollectionCreateRequest
	// callback for handling response errors
	errorer perfMonCounterCollectionHandleError
	// callback for handling the HTTP response
	responder perfMonCounterCollectionHandleResponse
	// callback for advancing to the next page
	advancer perfMonCounterCollectionAdvancePage
	// contains the current response
	current PerfMonCounterCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *perfMonCounterCollectionPager) Err() error {
	return p.err
}

func (p *perfMonCounterCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PerfMonCounterCollection.NextLink == nil || len(*p.current.PerfMonCounterCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *perfMonCounterCollectionPager) PageResponse() PerfMonCounterCollectionResponse {
	return p.current
}

// PremierAddOnOfferCollectionPager provides iteration over PremierAddOnOfferCollection pages.
type PremierAddOnOfferCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current PremierAddOnOfferCollectionResponse.
	PageResponse() PremierAddOnOfferCollectionResponse
}

type premierAddOnOfferCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type premierAddOnOfferCollectionHandleError func(*azcore.Response) error

type premierAddOnOfferCollectionHandleResponse func(*azcore.Response) (PremierAddOnOfferCollectionResponse, error)

type premierAddOnOfferCollectionAdvancePage func(context.Context, PremierAddOnOfferCollectionResponse) (*azcore.Request, error)

type premierAddOnOfferCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester premierAddOnOfferCollectionCreateRequest
	// callback for handling response errors
	errorer premierAddOnOfferCollectionHandleError
	// callback for handling the HTTP response
	responder premierAddOnOfferCollectionHandleResponse
	// callback for advancing to the next page
	advancer premierAddOnOfferCollectionAdvancePage
	// contains the current response
	current PremierAddOnOfferCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *premierAddOnOfferCollectionPager) Err() error {
	return p.err
}

func (p *premierAddOnOfferCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PremierAddOnOfferCollection.NextLink == nil || len(*p.current.PremierAddOnOfferCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *premierAddOnOfferCollectionPager) PageResponse() PremierAddOnOfferCollectionResponse {
	return p.current
}

// PrivateEndpointConnectionCollectionPager provides iteration over PrivateEndpointConnectionCollection pages.
type PrivateEndpointConnectionCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current PrivateEndpointConnectionCollectionResponse.
	PageResponse() PrivateEndpointConnectionCollectionResponse
}

type privateEndpointConnectionCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type privateEndpointConnectionCollectionHandleError func(*azcore.Response) error

type privateEndpointConnectionCollectionHandleResponse func(*azcore.Response) (PrivateEndpointConnectionCollectionResponse, error)

type privateEndpointConnectionCollectionAdvancePage func(context.Context, PrivateEndpointConnectionCollectionResponse) (*azcore.Request, error)

type privateEndpointConnectionCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester privateEndpointConnectionCollectionCreateRequest
	// callback for handling response errors
	errorer privateEndpointConnectionCollectionHandleError
	// callback for handling the HTTP response
	responder privateEndpointConnectionCollectionHandleResponse
	// callback for advancing to the next page
	advancer privateEndpointConnectionCollectionAdvancePage
	// contains the current response
	current PrivateEndpointConnectionCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *privateEndpointConnectionCollectionPager) Err() error {
	return p.err
}

func (p *privateEndpointConnectionCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionCollection.NextLink == nil || len(*p.current.PrivateEndpointConnectionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *privateEndpointConnectionCollectionPager) PageResponse() PrivateEndpointConnectionCollectionResponse {
	return p.current
}

// ProcessInfoCollectionPager provides iteration over ProcessInfoCollection pages.
type ProcessInfoCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ProcessInfoCollectionResponse.
	PageResponse() ProcessInfoCollectionResponse
}

type processInfoCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type processInfoCollectionHandleError func(*azcore.Response) error

type processInfoCollectionHandleResponse func(*azcore.Response) (ProcessInfoCollectionResponse, error)

type processInfoCollectionAdvancePage func(context.Context, ProcessInfoCollectionResponse) (*azcore.Request, error)

type processInfoCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester processInfoCollectionCreateRequest
	// callback for handling response errors
	errorer processInfoCollectionHandleError
	// callback for handling the HTTP response
	responder processInfoCollectionHandleResponse
	// callback for advancing to the next page
	advancer processInfoCollectionAdvancePage
	// contains the current response
	current ProcessInfoCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *processInfoCollectionPager) Err() error {
	return p.err
}

func (p *processInfoCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessInfoCollection.NextLink == nil || len(*p.current.ProcessInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *processInfoCollectionPager) PageResponse() ProcessInfoCollectionResponse {
	return p.current
}

// ProcessModuleInfoCollectionPager provides iteration over ProcessModuleInfoCollection pages.
type ProcessModuleInfoCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ProcessModuleInfoCollectionResponse.
	PageResponse() ProcessModuleInfoCollectionResponse
}

type processModuleInfoCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type processModuleInfoCollectionHandleError func(*azcore.Response) error

type processModuleInfoCollectionHandleResponse func(*azcore.Response) (ProcessModuleInfoCollectionResponse, error)

type processModuleInfoCollectionAdvancePage func(context.Context, ProcessModuleInfoCollectionResponse) (*azcore.Request, error)

type processModuleInfoCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester processModuleInfoCollectionCreateRequest
	// callback for handling response errors
	errorer processModuleInfoCollectionHandleError
	// callback for handling the HTTP response
	responder processModuleInfoCollectionHandleResponse
	// callback for advancing to the next page
	advancer processModuleInfoCollectionAdvancePage
	// contains the current response
	current ProcessModuleInfoCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *processModuleInfoCollectionPager) Err() error {
	return p.err
}

func (p *processModuleInfoCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessModuleInfoCollection.NextLink == nil || len(*p.current.ProcessModuleInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *processModuleInfoCollectionPager) PageResponse() ProcessModuleInfoCollectionResponse {
	return p.current
}

// ProcessThreadInfoCollectionPager provides iteration over ProcessThreadInfoCollection pages.
type ProcessThreadInfoCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ProcessThreadInfoCollectionResponse.
	PageResponse() ProcessThreadInfoCollectionResponse
}

type processThreadInfoCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type processThreadInfoCollectionHandleError func(*azcore.Response) error

type processThreadInfoCollectionHandleResponse func(*azcore.Response) (ProcessThreadInfoCollectionResponse, error)

type processThreadInfoCollectionAdvancePage func(context.Context, ProcessThreadInfoCollectionResponse) (*azcore.Request, error)

type processThreadInfoCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester processThreadInfoCollectionCreateRequest
	// callback for handling response errors
	errorer processThreadInfoCollectionHandleError
	// callback for handling the HTTP response
	responder processThreadInfoCollectionHandleResponse
	// callback for advancing to the next page
	advancer processThreadInfoCollectionAdvancePage
	// contains the current response
	current ProcessThreadInfoCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *processThreadInfoCollectionPager) Err() error {
	return p.err
}

func (p *processThreadInfoCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProcessThreadInfoCollection.NextLink == nil || len(*p.current.ProcessThreadInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *processThreadInfoCollectionPager) PageResponse() ProcessThreadInfoCollectionResponse {
	return p.current
}

// PublicCertificateCollectionPager provides iteration over PublicCertificateCollection pages.
type PublicCertificateCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current PublicCertificateCollectionResponse.
	PageResponse() PublicCertificateCollectionResponse
}

type publicCertificateCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type publicCertificateCollectionHandleError func(*azcore.Response) error

type publicCertificateCollectionHandleResponse func(*azcore.Response) (PublicCertificateCollectionResponse, error)

type publicCertificateCollectionAdvancePage func(context.Context, PublicCertificateCollectionResponse) (*azcore.Request, error)

type publicCertificateCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester publicCertificateCollectionCreateRequest
	// callback for handling response errors
	errorer publicCertificateCollectionHandleError
	// callback for handling the HTTP response
	responder publicCertificateCollectionHandleResponse
	// callback for advancing to the next page
	advancer publicCertificateCollectionAdvancePage
	// contains the current response
	current PublicCertificateCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *publicCertificateCollectionPager) Err() error {
	return p.err
}

func (p *publicCertificateCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicCertificateCollection.NextLink == nil || len(*p.current.PublicCertificateCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *publicCertificateCollectionPager) PageResponse() PublicCertificateCollectionResponse {
	return p.current
}

// PublishingCredentialsPoliciesCollectionPager provides iteration over PublishingCredentialsPoliciesCollection pages.
type PublishingCredentialsPoliciesCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current PublishingCredentialsPoliciesCollectionResponse.
	PageResponse() PublishingCredentialsPoliciesCollectionResponse
}

type publishingCredentialsPoliciesCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type publishingCredentialsPoliciesCollectionHandleError func(*azcore.Response) error

type publishingCredentialsPoliciesCollectionHandleResponse func(*azcore.Response) (PublishingCredentialsPoliciesCollectionResponse, error)

type publishingCredentialsPoliciesCollectionAdvancePage func(context.Context, PublishingCredentialsPoliciesCollectionResponse) (*azcore.Request, error)

type publishingCredentialsPoliciesCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester publishingCredentialsPoliciesCollectionCreateRequest
	// callback for handling response errors
	errorer publishingCredentialsPoliciesCollectionHandleError
	// callback for handling the HTTP response
	responder publishingCredentialsPoliciesCollectionHandleResponse
	// callback for advancing to the next page
	advancer publishingCredentialsPoliciesCollectionAdvancePage
	// contains the current response
	current PublishingCredentialsPoliciesCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *publishingCredentialsPoliciesCollectionPager) Err() error {
	return p.err
}

func (p *publishingCredentialsPoliciesCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublishingCredentialsPoliciesCollection.NextLink == nil || len(*p.current.PublishingCredentialsPoliciesCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *publishingCredentialsPoliciesCollectionPager) PageResponse() PublishingCredentialsPoliciesCollectionResponse {
	return p.current
}

// RecommendationCollectionPager provides iteration over RecommendationCollection pages.
type RecommendationCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current RecommendationCollectionResponse.
	PageResponse() RecommendationCollectionResponse
}

type recommendationCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type recommendationCollectionHandleError func(*azcore.Response) error

type recommendationCollectionHandleResponse func(*azcore.Response) (RecommendationCollectionResponse, error)

type recommendationCollectionAdvancePage func(context.Context, RecommendationCollectionResponse) (*azcore.Request, error)

type recommendationCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester recommendationCollectionCreateRequest
	// callback for handling response errors
	errorer recommendationCollectionHandleError
	// callback for handling the HTTP response
	responder recommendationCollectionHandleResponse
	// callback for advancing to the next page
	advancer recommendationCollectionAdvancePage
	// contains the current response
	current RecommendationCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *recommendationCollectionPager) Err() error {
	return p.err
}

func (p *recommendationCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecommendationCollection.NextLink == nil || len(*p.current.RecommendationCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *recommendationCollectionPager) PageResponse() RecommendationCollectionResponse {
	return p.current
}

// ResourceCollectionPager provides iteration over ResourceCollection pages.
type ResourceCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ResourceCollectionResponse.
	PageResponse() ResourceCollectionResponse
}

type resourceCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type resourceCollectionHandleError func(*azcore.Response) error

type resourceCollectionHandleResponse func(*azcore.Response) (ResourceCollectionResponse, error)

type resourceCollectionAdvancePage func(context.Context, ResourceCollectionResponse) (*azcore.Request, error)

type resourceCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester resourceCollectionCreateRequest
	// callback for handling response errors
	errorer resourceCollectionHandleError
	// callback for handling the HTTP response
	responder resourceCollectionHandleResponse
	// callback for advancing to the next page
	advancer resourceCollectionAdvancePage
	// contains the current response
	current ResourceCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *resourceCollectionPager) Err() error {
	return p.err
}

func (p *resourceCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceCollection.NextLink == nil || len(*p.current.ResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *resourceCollectionPager) PageResponse() ResourceCollectionResponse {
	return p.current
}

// ResourceHealthMetadataCollectionPager provides iteration over ResourceHealthMetadataCollection pages.
type ResourceHealthMetadataCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ResourceHealthMetadataCollectionResponse.
	PageResponse() ResourceHealthMetadataCollectionResponse
}

type resourceHealthMetadataCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type resourceHealthMetadataCollectionHandleError func(*azcore.Response) error

type resourceHealthMetadataCollectionHandleResponse func(*azcore.Response) (ResourceHealthMetadataCollectionResponse, error)

type resourceHealthMetadataCollectionAdvancePage func(context.Context, ResourceHealthMetadataCollectionResponse) (*azcore.Request, error)

type resourceHealthMetadataCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester resourceHealthMetadataCollectionCreateRequest
	// callback for handling response errors
	errorer resourceHealthMetadataCollectionHandleError
	// callback for handling the HTTP response
	responder resourceHealthMetadataCollectionHandleResponse
	// callback for advancing to the next page
	advancer resourceHealthMetadataCollectionAdvancePage
	// contains the current response
	current ResourceHealthMetadataCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *resourceHealthMetadataCollectionPager) Err() error {
	return p.err
}

func (p *resourceHealthMetadataCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceHealthMetadataCollection.NextLink == nil || len(*p.current.ResourceHealthMetadataCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *resourceHealthMetadataCollectionPager) PageResponse() ResourceHealthMetadataCollectionResponse {
	return p.current
}

// ResourceMetricDefinitionCollectionPager provides iteration over ResourceMetricDefinitionCollection pages.
type ResourceMetricDefinitionCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current ResourceMetricDefinitionCollectionResponse.
	PageResponse() ResourceMetricDefinitionCollectionResponse
}

type resourceMetricDefinitionCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type resourceMetricDefinitionCollectionHandleError func(*azcore.Response) error

type resourceMetricDefinitionCollectionHandleResponse func(*azcore.Response) (ResourceMetricDefinitionCollectionResponse, error)

type resourceMetricDefinitionCollectionAdvancePage func(context.Context, ResourceMetricDefinitionCollectionResponse) (*azcore.Request, error)

type resourceMetricDefinitionCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester resourceMetricDefinitionCollectionCreateRequest
	// callback for handling response errors
	errorer resourceMetricDefinitionCollectionHandleError
	// callback for handling the HTTP response
	responder resourceMetricDefinitionCollectionHandleResponse
	// callback for advancing to the next page
	advancer resourceMetricDefinitionCollectionAdvancePage
	// contains the current response
	current ResourceMetricDefinitionCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *resourceMetricDefinitionCollectionPager) Err() error {
	return p.err
}

func (p *resourceMetricDefinitionCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceMetricDefinitionCollection.NextLink == nil || len(*p.current.ResourceMetricDefinitionCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *resourceMetricDefinitionCollectionPager) PageResponse() ResourceMetricDefinitionCollectionResponse {
	return p.current
}

// SKUInfoCollectionPager provides iteration over SKUInfoCollection pages.
type SKUInfoCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current SKUInfoCollectionResponse.
	PageResponse() SKUInfoCollectionResponse
}

type skuInfoCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type skuInfoCollectionHandleError func(*azcore.Response) error

type skuInfoCollectionHandleResponse func(*azcore.Response) (SKUInfoCollectionResponse, error)

type skuInfoCollectionAdvancePage func(context.Context, SKUInfoCollectionResponse) (*azcore.Request, error)

type skuInfoCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester skuInfoCollectionCreateRequest
	// callback for handling response errors
	errorer skuInfoCollectionHandleError
	// callback for handling the HTTP response
	responder skuInfoCollectionHandleResponse
	// callback for advancing to the next page
	advancer skuInfoCollectionAdvancePage
	// contains the current response
	current SKUInfoCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *skuInfoCollectionPager) Err() error {
	return p.err
}

func (p *skuInfoCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SKUInfoCollection.NextLink == nil || len(*p.current.SKUInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *skuInfoCollectionPager) PageResponse() SKUInfoCollectionResponse {
	return p.current
}

// SiteConfigResourceCollectionPager provides iteration over SiteConfigResourceCollection pages.
type SiteConfigResourceCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current SiteConfigResourceCollectionResponse.
	PageResponse() SiteConfigResourceCollectionResponse
}

type siteConfigResourceCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type siteConfigResourceCollectionHandleError func(*azcore.Response) error

type siteConfigResourceCollectionHandleResponse func(*azcore.Response) (SiteConfigResourceCollectionResponse, error)

type siteConfigResourceCollectionAdvancePage func(context.Context, SiteConfigResourceCollectionResponse) (*azcore.Request, error)

type siteConfigResourceCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester siteConfigResourceCollectionCreateRequest
	// callback for handling response errors
	errorer siteConfigResourceCollectionHandleError
	// callback for handling the HTTP response
	responder siteConfigResourceCollectionHandleResponse
	// callback for advancing to the next page
	advancer siteConfigResourceCollectionAdvancePage
	// contains the current response
	current SiteConfigResourceCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *siteConfigResourceCollectionPager) Err() error {
	return p.err
}

func (p *siteConfigResourceCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteConfigResourceCollection.NextLink == nil || len(*p.current.SiteConfigResourceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *siteConfigResourceCollectionPager) PageResponse() SiteConfigResourceCollectionResponse {
	return p.current
}

// SiteConfigurationSnapshotInfoCollectionPager provides iteration over SiteConfigurationSnapshotInfoCollection pages.
type SiteConfigurationSnapshotInfoCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current SiteConfigurationSnapshotInfoCollectionResponse.
	PageResponse() SiteConfigurationSnapshotInfoCollectionResponse
}

type siteConfigurationSnapshotInfoCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type siteConfigurationSnapshotInfoCollectionHandleError func(*azcore.Response) error

type siteConfigurationSnapshotInfoCollectionHandleResponse func(*azcore.Response) (SiteConfigurationSnapshotInfoCollectionResponse, error)

type siteConfigurationSnapshotInfoCollectionAdvancePage func(context.Context, SiteConfigurationSnapshotInfoCollectionResponse) (*azcore.Request, error)

type siteConfigurationSnapshotInfoCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester siteConfigurationSnapshotInfoCollectionCreateRequest
	// callback for handling response errors
	errorer siteConfigurationSnapshotInfoCollectionHandleError
	// callback for handling the HTTP response
	responder siteConfigurationSnapshotInfoCollectionHandleResponse
	// callback for advancing to the next page
	advancer siteConfigurationSnapshotInfoCollectionAdvancePage
	// contains the current response
	current SiteConfigurationSnapshotInfoCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *siteConfigurationSnapshotInfoCollectionPager) Err() error {
	return p.err
}

func (p *siteConfigurationSnapshotInfoCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteConfigurationSnapshotInfoCollection.NextLink == nil || len(*p.current.SiteConfigurationSnapshotInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *siteConfigurationSnapshotInfoCollectionPager) PageResponse() SiteConfigurationSnapshotInfoCollectionResponse {
	return p.current
}

// SiteExtensionInfoCollectionPager provides iteration over SiteExtensionInfoCollection pages.
type SiteExtensionInfoCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current SiteExtensionInfoCollectionResponse.
	PageResponse() SiteExtensionInfoCollectionResponse
}

type siteExtensionInfoCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type siteExtensionInfoCollectionHandleError func(*azcore.Response) error

type siteExtensionInfoCollectionHandleResponse func(*azcore.Response) (SiteExtensionInfoCollectionResponse, error)

type siteExtensionInfoCollectionAdvancePage func(context.Context, SiteExtensionInfoCollectionResponse) (*azcore.Request, error)

type siteExtensionInfoCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester siteExtensionInfoCollectionCreateRequest
	// callback for handling response errors
	errorer siteExtensionInfoCollectionHandleError
	// callback for handling the HTTP response
	responder siteExtensionInfoCollectionHandleResponse
	// callback for advancing to the next page
	advancer siteExtensionInfoCollectionAdvancePage
	// contains the current response
	current SiteExtensionInfoCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *siteExtensionInfoCollectionPager) Err() error {
	return p.err
}

func (p *siteExtensionInfoCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SiteExtensionInfoCollection.NextLink == nil || len(*p.current.SiteExtensionInfoCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *siteExtensionInfoCollectionPager) PageResponse() SiteExtensionInfoCollectionResponse {
	return p.current
}

// SlotDifferenceCollectionPager provides iteration over SlotDifferenceCollection pages.
type SlotDifferenceCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current SlotDifferenceCollectionResponse.
	PageResponse() SlotDifferenceCollectionResponse
}

type slotDifferenceCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type slotDifferenceCollectionHandleError func(*azcore.Response) error

type slotDifferenceCollectionHandleResponse func(*azcore.Response) (SlotDifferenceCollectionResponse, error)

type slotDifferenceCollectionAdvancePage func(context.Context, SlotDifferenceCollectionResponse) (*azcore.Request, error)

type slotDifferenceCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester slotDifferenceCollectionCreateRequest
	// callback for handling response errors
	errorer slotDifferenceCollectionHandleError
	// callback for handling the HTTP response
	responder slotDifferenceCollectionHandleResponse
	// callback for advancing to the next page
	advancer slotDifferenceCollectionAdvancePage
	// contains the current response
	current SlotDifferenceCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *slotDifferenceCollectionPager) Err() error {
	return p.err
}

func (p *slotDifferenceCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SlotDifferenceCollection.NextLink == nil || len(*p.current.SlotDifferenceCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *slotDifferenceCollectionPager) PageResponse() SlotDifferenceCollectionResponse {
	return p.current
}

// SnapshotCollectionPager provides iteration over SnapshotCollection pages.
type SnapshotCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current SnapshotCollectionResponse.
	PageResponse() SnapshotCollectionResponse
}

type snapshotCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type snapshotCollectionHandleError func(*azcore.Response) error

type snapshotCollectionHandleResponse func(*azcore.Response) (SnapshotCollectionResponse, error)

type snapshotCollectionAdvancePage func(context.Context, SnapshotCollectionResponse) (*azcore.Request, error)

type snapshotCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester snapshotCollectionCreateRequest
	// callback for handling response errors
	errorer snapshotCollectionHandleError
	// callback for handling the HTTP response
	responder snapshotCollectionHandleResponse
	// callback for advancing to the next page
	advancer snapshotCollectionAdvancePage
	// contains the current response
	current SnapshotCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *snapshotCollectionPager) Err() error {
	return p.err
}

func (p *snapshotCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotCollection.NextLink == nil || len(*p.current.SnapshotCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *snapshotCollectionPager) PageResponse() SnapshotCollectionResponse {
	return p.current
}

// SourceControlCollectionPager provides iteration over SourceControlCollection pages.
type SourceControlCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current SourceControlCollectionResponse.
	PageResponse() SourceControlCollectionResponse
}

type sourceControlCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type sourceControlCollectionHandleError func(*azcore.Response) error

type sourceControlCollectionHandleResponse func(*azcore.Response) (SourceControlCollectionResponse, error)

type sourceControlCollectionAdvancePage func(context.Context, SourceControlCollectionResponse) (*azcore.Request, error)

type sourceControlCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester sourceControlCollectionCreateRequest
	// callback for handling response errors
	errorer sourceControlCollectionHandleError
	// callback for handling the HTTP response
	responder sourceControlCollectionHandleResponse
	// callback for advancing to the next page
	advancer sourceControlCollectionAdvancePage
	// contains the current response
	current SourceControlCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *sourceControlCollectionPager) Err() error {
	return p.err
}

func (p *sourceControlCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceControlCollection.NextLink == nil || len(*p.current.SourceControlCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *sourceControlCollectionPager) PageResponse() SourceControlCollectionResponse {
	return p.current
}

// StampCapacityCollectionPager provides iteration over StampCapacityCollection pages.
type StampCapacityCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current StampCapacityCollectionResponse.
	PageResponse() StampCapacityCollectionResponse
}

type stampCapacityCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type stampCapacityCollectionHandleError func(*azcore.Response) error

type stampCapacityCollectionHandleResponse func(*azcore.Response) (StampCapacityCollectionResponse, error)

type stampCapacityCollectionAdvancePage func(context.Context, StampCapacityCollectionResponse) (*azcore.Request, error)

type stampCapacityCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester stampCapacityCollectionCreateRequest
	// callback for handling response errors
	errorer stampCapacityCollectionHandleError
	// callback for handling the HTTP response
	responder stampCapacityCollectionHandleResponse
	// callback for advancing to the next page
	advancer stampCapacityCollectionAdvancePage
	// contains the current response
	current StampCapacityCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *stampCapacityCollectionPager) Err() error {
	return p.err
}

func (p *stampCapacityCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StampCapacityCollection.NextLink == nil || len(*p.current.StampCapacityCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *stampCapacityCollectionPager) PageResponse() StampCapacityCollectionResponse {
	return p.current
}

// StaticSiteBuildCollectionPager provides iteration over StaticSiteBuildCollection pages.
type StaticSiteBuildCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current StaticSiteBuildCollectionResponse.
	PageResponse() StaticSiteBuildCollectionResponse
}

type staticSiteBuildCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type staticSiteBuildCollectionHandleError func(*azcore.Response) error

type staticSiteBuildCollectionHandleResponse func(*azcore.Response) (StaticSiteBuildCollectionResponse, error)

type staticSiteBuildCollectionAdvancePage func(context.Context, StaticSiteBuildCollectionResponse) (*azcore.Request, error)

type staticSiteBuildCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester staticSiteBuildCollectionCreateRequest
	// callback for handling response errors
	errorer staticSiteBuildCollectionHandleError
	// callback for handling the HTTP response
	responder staticSiteBuildCollectionHandleResponse
	// callback for advancing to the next page
	advancer staticSiteBuildCollectionAdvancePage
	// contains the current response
	current StaticSiteBuildCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *staticSiteBuildCollectionPager) Err() error {
	return p.err
}

func (p *staticSiteBuildCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteBuildCollection.NextLink == nil || len(*p.current.StaticSiteBuildCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *staticSiteBuildCollectionPager) PageResponse() StaticSiteBuildCollectionResponse {
	return p.current
}

// StaticSiteCollectionPager provides iteration over StaticSiteCollection pages.
type StaticSiteCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current StaticSiteCollectionResponse.
	PageResponse() StaticSiteCollectionResponse
}

type staticSiteCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type staticSiteCollectionHandleError func(*azcore.Response) error

type staticSiteCollectionHandleResponse func(*azcore.Response) (StaticSiteCollectionResponse, error)

type staticSiteCollectionAdvancePage func(context.Context, StaticSiteCollectionResponse) (*azcore.Request, error)

type staticSiteCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester staticSiteCollectionCreateRequest
	// callback for handling response errors
	errorer staticSiteCollectionHandleError
	// callback for handling the HTTP response
	responder staticSiteCollectionHandleResponse
	// callback for advancing to the next page
	advancer staticSiteCollectionAdvancePage
	// contains the current response
	current StaticSiteCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *staticSiteCollectionPager) Err() error {
	return p.err
}

func (p *staticSiteCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteCollection.NextLink == nil || len(*p.current.StaticSiteCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *staticSiteCollectionPager) PageResponse() StaticSiteCollectionResponse {
	return p.current
}

// StaticSiteCustomDomainOverviewCollectionPager provides iteration over StaticSiteCustomDomainOverviewCollection pages.
type StaticSiteCustomDomainOverviewCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current StaticSiteCustomDomainOverviewCollectionResponse.
	PageResponse() StaticSiteCustomDomainOverviewCollectionResponse
}

type staticSiteCustomDomainOverviewCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type staticSiteCustomDomainOverviewCollectionHandleError func(*azcore.Response) error

type staticSiteCustomDomainOverviewCollectionHandleResponse func(*azcore.Response) (StaticSiteCustomDomainOverviewCollectionResponse, error)

type staticSiteCustomDomainOverviewCollectionAdvancePage func(context.Context, StaticSiteCustomDomainOverviewCollectionResponse) (*azcore.Request, error)

type staticSiteCustomDomainOverviewCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester staticSiteCustomDomainOverviewCollectionCreateRequest
	// callback for handling response errors
	errorer staticSiteCustomDomainOverviewCollectionHandleError
	// callback for handling the HTTP response
	responder staticSiteCustomDomainOverviewCollectionHandleResponse
	// callback for advancing to the next page
	advancer staticSiteCustomDomainOverviewCollectionAdvancePage
	// contains the current response
	current StaticSiteCustomDomainOverviewCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *staticSiteCustomDomainOverviewCollectionPager) Err() error {
	return p.err
}

func (p *staticSiteCustomDomainOverviewCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteCustomDomainOverviewCollection.NextLink == nil || len(*p.current.StaticSiteCustomDomainOverviewCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *staticSiteCustomDomainOverviewCollectionPager) PageResponse() StaticSiteCustomDomainOverviewCollectionResponse {
	return p.current
}

// StaticSiteFunctionOverviewCollectionPager provides iteration over StaticSiteFunctionOverviewCollection pages.
type StaticSiteFunctionOverviewCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current StaticSiteFunctionOverviewCollectionResponse.
	PageResponse() StaticSiteFunctionOverviewCollectionResponse
}

type staticSiteFunctionOverviewCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type staticSiteFunctionOverviewCollectionHandleError func(*azcore.Response) error

type staticSiteFunctionOverviewCollectionHandleResponse func(*azcore.Response) (StaticSiteFunctionOverviewCollectionResponse, error)

type staticSiteFunctionOverviewCollectionAdvancePage func(context.Context, StaticSiteFunctionOverviewCollectionResponse) (*azcore.Request, error)

type staticSiteFunctionOverviewCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester staticSiteFunctionOverviewCollectionCreateRequest
	// callback for handling response errors
	errorer staticSiteFunctionOverviewCollectionHandleError
	// callback for handling the HTTP response
	responder staticSiteFunctionOverviewCollectionHandleResponse
	// callback for advancing to the next page
	advancer staticSiteFunctionOverviewCollectionAdvancePage
	// contains the current response
	current StaticSiteFunctionOverviewCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *staticSiteFunctionOverviewCollectionPager) Err() error {
	return p.err
}

func (p *staticSiteFunctionOverviewCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteFunctionOverviewCollection.NextLink == nil || len(*p.current.StaticSiteFunctionOverviewCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *staticSiteFunctionOverviewCollectionPager) PageResponse() StaticSiteFunctionOverviewCollectionResponse {
	return p.current
}

// StaticSiteUserCollectionPager provides iteration over StaticSiteUserCollection pages.
type StaticSiteUserCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current StaticSiteUserCollectionResponse.
	PageResponse() StaticSiteUserCollectionResponse
}

type staticSiteUserCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type staticSiteUserCollectionHandleError func(*azcore.Response) error

type staticSiteUserCollectionHandleResponse func(*azcore.Response) (StaticSiteUserCollectionResponse, error)

type staticSiteUserCollectionAdvancePage func(context.Context, StaticSiteUserCollectionResponse) (*azcore.Request, error)

type staticSiteUserCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester staticSiteUserCollectionCreateRequest
	// callback for handling response errors
	errorer staticSiteUserCollectionHandleError
	// callback for handling the HTTP response
	responder staticSiteUserCollectionHandleResponse
	// callback for advancing to the next page
	advancer staticSiteUserCollectionAdvancePage
	// contains the current response
	current StaticSiteUserCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *staticSiteUserCollectionPager) Err() error {
	return p.err
}

func (p *staticSiteUserCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteUserCollection.NextLink == nil || len(*p.current.StaticSiteUserCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *staticSiteUserCollectionPager) PageResponse() StaticSiteUserCollectionResponse {
	return p.current
}

// StaticSiteUserProvidedFunctionAppsCollectionPager provides iteration over StaticSiteUserProvidedFunctionAppsCollection pages.
type StaticSiteUserProvidedFunctionAppsCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current StaticSiteUserProvidedFunctionAppsCollectionResponse.
	PageResponse() StaticSiteUserProvidedFunctionAppsCollectionResponse
}

type staticSiteUserProvidedFunctionAppsCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type staticSiteUserProvidedFunctionAppsCollectionHandleError func(*azcore.Response) error

type staticSiteUserProvidedFunctionAppsCollectionHandleResponse func(*azcore.Response) (StaticSiteUserProvidedFunctionAppsCollectionResponse, error)

type staticSiteUserProvidedFunctionAppsCollectionAdvancePage func(context.Context, StaticSiteUserProvidedFunctionAppsCollectionResponse) (*azcore.Request, error)

type staticSiteUserProvidedFunctionAppsCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester staticSiteUserProvidedFunctionAppsCollectionCreateRequest
	// callback for handling response errors
	errorer staticSiteUserProvidedFunctionAppsCollectionHandleError
	// callback for handling the HTTP response
	responder staticSiteUserProvidedFunctionAppsCollectionHandleResponse
	// callback for advancing to the next page
	advancer staticSiteUserProvidedFunctionAppsCollectionAdvancePage
	// contains the current response
	current StaticSiteUserProvidedFunctionAppsCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *staticSiteUserProvidedFunctionAppsCollectionPager) Err() error {
	return p.err
}

func (p *staticSiteUserProvidedFunctionAppsCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.StaticSiteUserProvidedFunctionAppsCollection.NextLink == nil || len(*p.current.StaticSiteUserProvidedFunctionAppsCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *staticSiteUserProvidedFunctionAppsCollectionPager) PageResponse() StaticSiteUserProvidedFunctionAppsCollectionResponse {
	return p.current
}

// TldLegalAgreementCollectionPager provides iteration over TldLegalAgreementCollection pages.
type TldLegalAgreementCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current TldLegalAgreementCollectionResponse.
	PageResponse() TldLegalAgreementCollectionResponse
}

type tldLegalAgreementCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type tldLegalAgreementCollectionHandleError func(*azcore.Response) error

type tldLegalAgreementCollectionHandleResponse func(*azcore.Response) (TldLegalAgreementCollectionResponse, error)

type tldLegalAgreementCollectionAdvancePage func(context.Context, TldLegalAgreementCollectionResponse) (*azcore.Request, error)

type tldLegalAgreementCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester tldLegalAgreementCollectionCreateRequest
	// callback for handling response errors
	errorer tldLegalAgreementCollectionHandleError
	// callback for handling the HTTP response
	responder tldLegalAgreementCollectionHandleResponse
	// callback for advancing to the next page
	advancer tldLegalAgreementCollectionAdvancePage
	// contains the current response
	current TldLegalAgreementCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *tldLegalAgreementCollectionPager) Err() error {
	return p.err
}

func (p *tldLegalAgreementCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TldLegalAgreementCollection.NextLink == nil || len(*p.current.TldLegalAgreementCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *tldLegalAgreementCollectionPager) PageResponse() TldLegalAgreementCollectionResponse {
	return p.current
}

// TopLevelDomainCollectionPager provides iteration over TopLevelDomainCollection pages.
type TopLevelDomainCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current TopLevelDomainCollectionResponse.
	PageResponse() TopLevelDomainCollectionResponse
}

type topLevelDomainCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type topLevelDomainCollectionHandleError func(*azcore.Response) error

type topLevelDomainCollectionHandleResponse func(*azcore.Response) (TopLevelDomainCollectionResponse, error)

type topLevelDomainCollectionAdvancePage func(context.Context, TopLevelDomainCollectionResponse) (*azcore.Request, error)

type topLevelDomainCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester topLevelDomainCollectionCreateRequest
	// callback for handling response errors
	errorer topLevelDomainCollectionHandleError
	// callback for handling the HTTP response
	responder topLevelDomainCollectionHandleResponse
	// callback for advancing to the next page
	advancer topLevelDomainCollectionAdvancePage
	// contains the current response
	current TopLevelDomainCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *topLevelDomainCollectionPager) Err() error {
	return p.err
}

func (p *topLevelDomainCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopLevelDomainCollection.NextLink == nil || len(*p.current.TopLevelDomainCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *topLevelDomainCollectionPager) PageResponse() TopLevelDomainCollectionResponse {
	return p.current
}

// TriggeredJobHistoryCollectionPager provides iteration over TriggeredJobHistoryCollection pages.
type TriggeredJobHistoryCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current TriggeredJobHistoryCollectionResponse.
	PageResponse() TriggeredJobHistoryCollectionResponse
}

type triggeredJobHistoryCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type triggeredJobHistoryCollectionHandleError func(*azcore.Response) error

type triggeredJobHistoryCollectionHandleResponse func(*azcore.Response) (TriggeredJobHistoryCollectionResponse, error)

type triggeredJobHistoryCollectionAdvancePage func(context.Context, TriggeredJobHistoryCollectionResponse) (*azcore.Request, error)

type triggeredJobHistoryCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester triggeredJobHistoryCollectionCreateRequest
	// callback for handling response errors
	errorer triggeredJobHistoryCollectionHandleError
	// callback for handling the HTTP response
	responder triggeredJobHistoryCollectionHandleResponse
	// callback for advancing to the next page
	advancer triggeredJobHistoryCollectionAdvancePage
	// contains the current response
	current TriggeredJobHistoryCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *triggeredJobHistoryCollectionPager) Err() error {
	return p.err
}

func (p *triggeredJobHistoryCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggeredJobHistoryCollection.NextLink == nil || len(*p.current.TriggeredJobHistoryCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *triggeredJobHistoryCollectionPager) PageResponse() TriggeredJobHistoryCollectionResponse {
	return p.current
}

// TriggeredWebJobCollectionPager provides iteration over TriggeredWebJobCollection pages.
type TriggeredWebJobCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current TriggeredWebJobCollectionResponse.
	PageResponse() TriggeredWebJobCollectionResponse
}

type triggeredWebJobCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type triggeredWebJobCollectionHandleError func(*azcore.Response) error

type triggeredWebJobCollectionHandleResponse func(*azcore.Response) (TriggeredWebJobCollectionResponse, error)

type triggeredWebJobCollectionAdvancePage func(context.Context, TriggeredWebJobCollectionResponse) (*azcore.Request, error)

type triggeredWebJobCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester triggeredWebJobCollectionCreateRequest
	// callback for handling response errors
	errorer triggeredWebJobCollectionHandleError
	// callback for handling the HTTP response
	responder triggeredWebJobCollectionHandleResponse
	// callback for advancing to the next page
	advancer triggeredWebJobCollectionAdvancePage
	// contains the current response
	current TriggeredWebJobCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *triggeredWebJobCollectionPager) Err() error {
	return p.err
}

func (p *triggeredWebJobCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggeredWebJobCollection.NextLink == nil || len(*p.current.TriggeredWebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *triggeredWebJobCollectionPager) PageResponse() TriggeredWebJobCollectionResponse {
	return p.current
}

// UsageCollectionPager provides iteration over UsageCollection pages.
type UsageCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current UsageCollectionResponse.
	PageResponse() UsageCollectionResponse
}

type usageCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type usageCollectionHandleError func(*azcore.Response) error

type usageCollectionHandleResponse func(*azcore.Response) (UsageCollectionResponse, error)

type usageCollectionAdvancePage func(context.Context, UsageCollectionResponse) (*azcore.Request, error)

type usageCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester usageCollectionCreateRequest
	// callback for handling response errors
	errorer usageCollectionHandleError
	// callback for handling the HTTP response
	responder usageCollectionHandleResponse
	// callback for advancing to the next page
	advancer usageCollectionAdvancePage
	// contains the current response
	current UsageCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *usageCollectionPager) Err() error {
	return p.err
}

func (p *usageCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsageCollection.NextLink == nil || len(*p.current.UsageCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *usageCollectionPager) PageResponse() UsageCollectionResponse {
	return p.current
}

// WebAppCollectionPager provides iteration over WebAppCollection pages.
type WebAppCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current WebAppCollectionResponse.
	PageResponse() WebAppCollectionResponse
}

type webAppCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type webAppCollectionHandleError func(*azcore.Response) error

type webAppCollectionHandleResponse func(*azcore.Response) (WebAppCollectionResponse, error)

type webAppCollectionAdvancePage func(context.Context, WebAppCollectionResponse) (*azcore.Request, error)

type webAppCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester webAppCollectionCreateRequest
	// callback for handling response errors
	errorer webAppCollectionHandleError
	// callback for handling the HTTP response
	responder webAppCollectionHandleResponse
	// callback for advancing to the next page
	advancer webAppCollectionAdvancePage
	// contains the current response
	current WebAppCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
	// previous response from the endpoint (LRO case)
	resp *azcore.Response
}

func (p *webAppCollectionPager) Err() error {
	return p.err
}

func (p *webAppCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppCollection.NextLink == nil || len(*p.current.WebAppCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else if p.resp == nil {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp := p.resp
	if resp == nil {
		resp, err = p.pipeline.Do(req)
	} else {
		p.resp = nil
	}
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *webAppCollectionPager) PageResponse() WebAppCollectionResponse {
	return p.current
}

// WebAppInstanceStatusCollectionPager provides iteration over WebAppInstanceStatusCollection pages.
type WebAppInstanceStatusCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current WebAppInstanceStatusCollectionResponse.
	PageResponse() WebAppInstanceStatusCollectionResponse
}

type webAppInstanceStatusCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type webAppInstanceStatusCollectionHandleError func(*azcore.Response) error

type webAppInstanceStatusCollectionHandleResponse func(*azcore.Response) (WebAppInstanceStatusCollectionResponse, error)

type webAppInstanceStatusCollectionAdvancePage func(context.Context, WebAppInstanceStatusCollectionResponse) (*azcore.Request, error)

type webAppInstanceStatusCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester webAppInstanceStatusCollectionCreateRequest
	// callback for handling response errors
	errorer webAppInstanceStatusCollectionHandleError
	// callback for handling the HTTP response
	responder webAppInstanceStatusCollectionHandleResponse
	// callback for advancing to the next page
	advancer webAppInstanceStatusCollectionAdvancePage
	// contains the current response
	current WebAppInstanceStatusCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *webAppInstanceStatusCollectionPager) Err() error {
	return p.err
}

func (p *webAppInstanceStatusCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppInstanceStatusCollection.NextLink == nil || len(*p.current.WebAppInstanceStatusCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *webAppInstanceStatusCollectionPager) PageResponse() WebAppInstanceStatusCollectionResponse {
	return p.current
}

// WebAppStackCollectionPager provides iteration over WebAppStackCollection pages.
type WebAppStackCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current WebAppStackCollectionResponse.
	PageResponse() WebAppStackCollectionResponse
}

type webAppStackCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type webAppStackCollectionHandleError func(*azcore.Response) error

type webAppStackCollectionHandleResponse func(*azcore.Response) (WebAppStackCollectionResponse, error)

type webAppStackCollectionAdvancePage func(context.Context, WebAppStackCollectionResponse) (*azcore.Request, error)

type webAppStackCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester webAppStackCollectionCreateRequest
	// callback for handling response errors
	errorer webAppStackCollectionHandleError
	// callback for handling the HTTP response
	responder webAppStackCollectionHandleResponse
	// callback for advancing to the next page
	advancer webAppStackCollectionAdvancePage
	// contains the current response
	current WebAppStackCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *webAppStackCollectionPager) Err() error {
	return p.err
}

func (p *webAppStackCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebAppStackCollection.NextLink == nil || len(*p.current.WebAppStackCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *webAppStackCollectionPager) PageResponse() WebAppStackCollectionResponse {
	return p.current
}

// WebJobCollectionPager provides iteration over WebJobCollection pages.
type WebJobCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current WebJobCollectionResponse.
	PageResponse() WebJobCollectionResponse
}

type webJobCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type webJobCollectionHandleError func(*azcore.Response) error

type webJobCollectionHandleResponse func(*azcore.Response) (WebJobCollectionResponse, error)

type webJobCollectionAdvancePage func(context.Context, WebJobCollectionResponse) (*azcore.Request, error)

type webJobCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester webJobCollectionCreateRequest
	// callback for handling response errors
	errorer webJobCollectionHandleError
	// callback for handling the HTTP response
	responder webJobCollectionHandleResponse
	// callback for advancing to the next page
	advancer webJobCollectionAdvancePage
	// contains the current response
	current WebJobCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *webJobCollectionPager) Err() error {
	return p.err
}

func (p *webJobCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebJobCollection.NextLink == nil || len(*p.current.WebJobCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *webJobCollectionPager) PageResponse() WebJobCollectionResponse {
	return p.current
}

// WorkerPoolCollectionPager provides iteration over WorkerPoolCollection pages.
type WorkerPoolCollectionPager interface {
	azcore.Pager

	// PageResponse returns the current WorkerPoolCollectionResponse.
	PageResponse() WorkerPoolCollectionResponse
}

type workerPoolCollectionCreateRequest func(context.Context) (*azcore.Request, error)

type workerPoolCollectionHandleError func(*azcore.Response) error

type workerPoolCollectionHandleResponse func(*azcore.Response) (WorkerPoolCollectionResponse, error)

type workerPoolCollectionAdvancePage func(context.Context, WorkerPoolCollectionResponse) (*azcore.Request, error)

type workerPoolCollectionPager struct {
	// the pipeline for making the request
	pipeline azcore.Pipeline
	// creates the initial request (non-LRO case)
	requester workerPoolCollectionCreateRequest
	// callback for handling response errors
	errorer workerPoolCollectionHandleError
	// callback for handling the HTTP response
	responder workerPoolCollectionHandleResponse
	// callback for advancing to the next page
	advancer workerPoolCollectionAdvancePage
	// contains the current response
	current WorkerPoolCollectionResponse
	// status codes for successful retrieval
	statusCodes []int
	// any error encountered
	err error
}

func (p *workerPoolCollectionPager) Err() error {
	return p.err
}

func (p *workerPoolCollectionPager) NextPage(ctx context.Context) bool {
	var req *azcore.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkerPoolCollection.NextLink == nil || len(*p.current.WorkerPoolCollection.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.pipeline.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !resp.HasStatusCode(p.statusCodes...) {
		p.err = p.errorer(resp)
		return false
	}
	result, err := p.responder(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

func (p *workerPoolCollectionPager) PageResponse() WorkerPoolCollectionResponse {
	return p.current
}
