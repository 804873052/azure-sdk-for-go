// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// WebAppsClient contains the methods for the WebApps group.
// Don't use this type directly, use NewWebAppsClient() instead.
type WebAppsClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewWebAppsClient creates a new instance of WebAppsClient with the specified values.
func NewWebAppsClient(con *armcore.Connection, subscriptionID string) *WebAppsClient {
	return &WebAppsClient{con: con, subscriptionID: subscriptionID}
}

// AddPremierAddOn - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AddPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnOptions) (PremierAddOnResponse, error) {
	req, err := client.addPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.addPremierAddOnHandleError(resp)
	}
	return client.addPremierAddOnHandleResponse(resp)
}

// addPremierAddOnCreateRequest creates the AddPremierAddOn request.
func (client *WebAppsClient) addPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(premierAddOn)
}

// addPremierAddOnHandleResponse handles the AddPremierAddOn response.
func (client *WebAppsClient) addPremierAddOnHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// addPremierAddOnHandleError handles the AddPremierAddOn error response.
func (client *WebAppsClient) addPremierAddOnHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// AddPremierAddOnSlot - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AddPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnSlotOptions) (PremierAddOnResponse, error) {
	req, err := client.addPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.addPremierAddOnSlotHandleError(resp)
	}
	return client.addPremierAddOnSlotHandleResponse(resp)
}

// addPremierAddOnSlotCreateRequest creates the AddPremierAddOnSlot request.
func (client *WebAppsClient) addPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(premierAddOn)
}

// addPremierAddOnSlotHandleResponse handles the AddPremierAddOnSlot response.
func (client *WebAppsClient) addPremierAddOnSlotHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// addPremierAddOnSlotHandleError handles the AddPremierAddOnSlot error response.
func (client *WebAppsClient) addPremierAddOnSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// AnalyzeCustomHostname - Description for Analyze a custom hostname.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AnalyzeCustomHostname(ctx context.Context, resourceGroupName string, name string, options *WebAppsAnalyzeCustomHostnameOptions) (CustomHostnameAnalysisResultResponse, error) {
	req, err := client.analyzeCustomHostnameCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return CustomHostnameAnalysisResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CustomHostnameAnalysisResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CustomHostnameAnalysisResultResponse{}, client.analyzeCustomHostnameHandleError(resp)
	}
	return client.analyzeCustomHostnameHandleResponse(resp)
}

// analyzeCustomHostnameCreateRequest creates the AnalyzeCustomHostname request.
func (client *WebAppsClient) analyzeCustomHostnameCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsAnalyzeCustomHostnameOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// analyzeCustomHostnameHandleResponse handles the AnalyzeCustomHostname response.
func (client *WebAppsClient) analyzeCustomHostnameHandleResponse(resp *azcore.Response) (CustomHostnameAnalysisResultResponse, error) {
	var val *CustomHostnameAnalysisResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CustomHostnameAnalysisResultResponse{}, err
	}
	return CustomHostnameAnalysisResultResponse{RawResponse: resp.Response, CustomHostnameAnalysisResult: val}, nil
}

// analyzeCustomHostnameHandleError handles the AnalyzeCustomHostname error response.
func (client *WebAppsClient) analyzeCustomHostnameHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// AnalyzeCustomHostnameSlot - Description for Analyze a custom hostname.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AnalyzeCustomHostnameSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsAnalyzeCustomHostnameSlotOptions) (CustomHostnameAnalysisResultResponse, error) {
	req, err := client.analyzeCustomHostnameSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return CustomHostnameAnalysisResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CustomHostnameAnalysisResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CustomHostnameAnalysisResultResponse{}, client.analyzeCustomHostnameSlotHandleError(resp)
	}
	return client.analyzeCustomHostnameSlotHandleResponse(resp)
}

// analyzeCustomHostnameSlotCreateRequest creates the AnalyzeCustomHostnameSlot request.
func (client *WebAppsClient) analyzeCustomHostnameSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsAnalyzeCustomHostnameSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// analyzeCustomHostnameSlotHandleResponse handles the AnalyzeCustomHostnameSlot response.
func (client *WebAppsClient) analyzeCustomHostnameSlotHandleResponse(resp *azcore.Response) (CustomHostnameAnalysisResultResponse, error) {
	var val *CustomHostnameAnalysisResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CustomHostnameAnalysisResultResponse{}, err
	}
	return CustomHostnameAnalysisResultResponse{RawResponse: resp.Response, CustomHostnameAnalysisResult: val}, nil
}

// analyzeCustomHostnameSlotHandleError handles the AnalyzeCustomHostnameSlot error response.
func (client *WebAppsClient) analyzeCustomHostnameSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ApplySlotConfigToProduction - Description for Applies the configuration settings from the target slot onto the current slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ApplySlotConfigToProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigToProductionOptions) (*http.Response, error) {
	req, err := client.applySlotConfigToProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.applySlotConfigToProductionHandleError(resp)
	}
	return resp.Response, nil
}

// applySlotConfigToProductionCreateRequest creates the ApplySlotConfigToProduction request.
func (client *WebAppsClient) applySlotConfigToProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigToProductionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(slotSwapEntity)
}

// applySlotConfigToProductionHandleError handles the ApplySlotConfigToProduction error response.
func (client *WebAppsClient) applySlotConfigToProductionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ApplySlotConfigurationSlot - Description for Applies the configuration settings from the target slot onto the current slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ApplySlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigurationSlotOptions) (*http.Response, error) {
	req, err := client.applySlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.applySlotConfigurationSlotHandleError(resp)
	}
	return resp.Response, nil
}

// applySlotConfigurationSlotCreateRequest creates the ApplySlotConfigurationSlot request.
func (client *WebAppsClient) applySlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(slotSwapEntity)
}

// applySlotConfigurationSlotHandleError handles the ApplySlotConfigurationSlot error response.
func (client *WebAppsClient) applySlotConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginApproveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionOptions) (RemotePrivateEndpointConnectionARMResourcePollerResponse, error) {
	resp, err := client.approveOrRejectPrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	result := RemotePrivateEndpointConnectionARMResourcePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.ApproveOrRejectPrivateEndpointConnection", "", resp, client.con.Pipeline(), client.approveOrRejectPrivateEndpointConnectionHandleError)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	poller := &remotePrivateEndpointConnectionARMResourcePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeApproveOrRejectPrivateEndpointConnection creates a new RemotePrivateEndpointConnectionARMResourcePoller from the specified resume token.
// token - The value must come from a previous call to RemotePrivateEndpointConnectionARMResourcePoller.ResumeToken().
func (client *WebAppsClient) ResumeApproveOrRejectPrivateEndpointConnection(ctx context.Context, token string) (RemotePrivateEndpointConnectionARMResourcePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.ApproveOrRejectPrivateEndpointConnection", token, client.con.Pipeline(), client.approveOrRejectPrivateEndpointConnectionHandleError)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	poller := &remotePrivateEndpointConnectionARMResourcePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	result := RemotePrivateEndpointConnectionARMResourcePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionOptions) (*azcore.Response, error) {
	req, err := client.approveOrRejectPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.approveOrRejectPrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// approveOrRejectPrivateEndpointConnectionCreateRequest creates the ApproveOrRejectPrivateEndpointConnection request.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(privateEndpointWrapper)
}

// approveOrRejectPrivateEndpointConnectionHandleError handles the ApproveOrRejectPrivateEndpointConnection error response.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginApproveOrRejectPrivateEndpointConnectionSlot - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginApproveOrRejectPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (RemotePrivateEndpointConnectionARMResourcePollerResponse, error) {
	resp, err := client.approveOrRejectPrivateEndpointConnectionSlot(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	result := RemotePrivateEndpointConnectionARMResourcePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.ApproveOrRejectPrivateEndpointConnectionSlot", "", resp, client.con.Pipeline(), client.approveOrRejectPrivateEndpointConnectionSlotHandleError)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	poller := &remotePrivateEndpointConnectionARMResourcePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeApproveOrRejectPrivateEndpointConnectionSlot creates a new RemotePrivateEndpointConnectionARMResourcePoller from the specified resume token.
// token - The value must come from a previous call to RemotePrivateEndpointConnectionARMResourcePoller.ResumeToken().
func (client *WebAppsClient) ResumeApproveOrRejectPrivateEndpointConnectionSlot(ctx context.Context, token string) (RemotePrivateEndpointConnectionARMResourcePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.ApproveOrRejectPrivateEndpointConnectionSlot", token, client.con.Pipeline(), client.approveOrRejectPrivateEndpointConnectionSlotHandleError)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	poller := &remotePrivateEndpointConnectionARMResourcePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourcePollerResponse{}, err
	}
	result := RemotePrivateEndpointConnectionARMResourcePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ApproveOrRejectPrivateEndpointConnectionSlot - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (*azcore.Response, error) {
	req, err := client.approveOrRejectPrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.approveOrRejectPrivateEndpointConnectionSlotHandleError(resp)
	}
	return resp, nil
}

// approveOrRejectPrivateEndpointConnectionSlotCreateRequest creates the ApproveOrRejectPrivateEndpointConnectionSlot request.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(privateEndpointWrapper)
}

// approveOrRejectPrivateEndpointConnectionSlotHandleError handles the ApproveOrRejectPrivateEndpointConnectionSlot error response.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Backup - Description for Creates a backup of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Backup(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsBackupOptions) (BackupItemResponse, error) {
	req, err := client.backupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return BackupItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupItemResponse{}, client.backupHandleError(resp)
	}
	return client.backupHandleResponse(resp)
}

// backupCreateRequest creates the Backup request.
func (client *WebAppsClient) backupCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsBackupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// backupHandleResponse handles the Backup response.
func (client *WebAppsClient) backupHandleResponse(resp *azcore.Response) (BackupItemResponse, error) {
	var val *BackupItem
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemResponse{}, err
	}
	return BackupItemResponse{RawResponse: resp.Response, BackupItem: val}, nil
}

// backupHandleError handles the Backup error response.
func (client *WebAppsClient) backupHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BackupSlot - Description for Creates a backup of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsBackupSlotOptions) (BackupItemResponse, error) {
	req, err := client.backupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return BackupItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupItemResponse{}, client.backupSlotHandleError(resp)
	}
	return client.backupSlotHandleResponse(resp)
}

// backupSlotCreateRequest creates the BackupSlot request.
func (client *WebAppsClient) backupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsBackupSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// backupSlotHandleResponse handles the BackupSlot response.
func (client *WebAppsClient) backupSlotHandleResponse(resp *azcore.Response) (BackupItemResponse, error) {
	var val *BackupItem
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemResponse{}, err
	}
	return BackupItemResponse{RawResponse: resp.Response, BackupItem: val}, nil
}

// backupSlotHandleError handles the BackupSlot error response.
func (client *WebAppsClient) backupSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateDeployment - Description for Create a deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateDeployment(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *WebAppsCreateDeploymentOptions) (DeploymentResponse, error) {
	req, err := client.createDeploymentCreateRequest(ctx, resourceGroupName, name, id, deployment, options)
	if err != nil {
		return DeploymentResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentResponse{}, client.createDeploymentHandleError(resp)
	}
	return client.createDeploymentHandleResponse(resp)
}

// createDeploymentCreateRequest creates the CreateDeployment request.
func (client *WebAppsClient) createDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *WebAppsCreateDeploymentOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(deployment)
}

// createDeploymentHandleResponse handles the CreateDeployment response.
func (client *WebAppsClient) createDeploymentHandleResponse(resp *azcore.Response) (DeploymentResponse, error) {
	var val *Deployment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentResponse{}, err
	}
	return DeploymentResponse{RawResponse: resp.Response, Deployment: val}, nil
}

// createDeploymentHandleError handles the CreateDeployment error response.
func (client *WebAppsClient) createDeploymentHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateDeploymentSlot - Description for Create a deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *WebAppsCreateDeploymentSlotOptions) (DeploymentResponse, error) {
	req, err := client.createDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, deployment, options)
	if err != nil {
		return DeploymentResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentResponse{}, client.createDeploymentSlotHandleError(resp)
	}
	return client.createDeploymentSlotHandleResponse(resp)
}

// createDeploymentSlotCreateRequest creates the CreateDeploymentSlot request.
func (client *WebAppsClient) createDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *WebAppsCreateDeploymentSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(deployment)
}

// createDeploymentSlotHandleResponse handles the CreateDeploymentSlot response.
func (client *WebAppsClient) createDeploymentSlotHandleResponse(resp *azcore.Response) (DeploymentResponse, error) {
	var val *Deployment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentResponse{}, err
	}
	return DeploymentResponse{RawResponse: resp.Response, Deployment: val}, nil
}

// createDeploymentSlotHandleError handles the CreateDeploymentSlot error response.
func (client *WebAppsClient) createDeploymentSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateFunction - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateFunctionOptions) (FunctionEnvelopePollerResponse, error) {
	resp, err := client.createFunction(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	result := FunctionEnvelopePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateFunction", "", resp, client.con.Pipeline(), client.createFunctionHandleError)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	poller := &functionEnvelopePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (FunctionEnvelopeResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateFunction creates a new FunctionEnvelopePoller from the specified resume token.
// token - The value must come from a previous call to FunctionEnvelopePoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateFunction(ctx context.Context, token string) (FunctionEnvelopePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateFunction", token, client.con.Pipeline(), client.createFunctionHandleError)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	poller := &functionEnvelopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	result := FunctionEnvelopePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (FunctionEnvelopeResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateFunction - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateFunctionOptions) (*azcore.Response, error) {
	req, err := client.createFunctionCreateRequest(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.createFunctionHandleError(resp)
	}
	return resp, nil
}

// createFunctionCreateRequest creates the CreateFunction request.
func (client *WebAppsClient) createFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateFunctionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(functionEnvelope)
}

// createFunctionHandleError handles the CreateFunction error response.
func (client *WebAppsClient) createFunctionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateInstanceFunctionSlot - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateInstanceFunctionSlotOptions) (FunctionEnvelopePollerResponse, error) {
	resp, err := client.createInstanceFunctionSlot(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	result := FunctionEnvelopePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateInstanceFunctionSlot", "", resp, client.con.Pipeline(), client.createInstanceFunctionSlotHandleError)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	poller := &functionEnvelopePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (FunctionEnvelopeResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateInstanceFunctionSlot creates a new FunctionEnvelopePoller from the specified resume token.
// token - The value must come from a previous call to FunctionEnvelopePoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateInstanceFunctionSlot(ctx context.Context, token string) (FunctionEnvelopePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateInstanceFunctionSlot", token, client.con.Pipeline(), client.createInstanceFunctionSlotHandleError)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	poller := &functionEnvelopePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return FunctionEnvelopePollerResponse{}, err
	}
	result := FunctionEnvelopePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (FunctionEnvelopeResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateInstanceFunctionSlot - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateInstanceFunctionSlotOptions) (*azcore.Response, error) {
	req, err := client.createInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.createInstanceFunctionSlotHandleError(resp)
	}
	return resp, nil
}

// createInstanceFunctionSlotCreateRequest creates the CreateInstanceFunctionSlot request.
func (client *WebAppsClient) createInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateInstanceFunctionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(functionEnvelope)
}

// createInstanceFunctionSlotHandleError handles the CreateInstanceFunctionSlot error response.
func (client *WebAppsClient) createInstanceFunctionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateInstanceMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationOptions) (MSDeployStatusPollerResponse, error) {
	resp, err := client.createInstanceMSDeployOperation(ctx, resourceGroupName, name, instanceID, msDeploy, options)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateInstanceMSDeployOperation", "", resp, client.con.Pipeline(), client.createInstanceMSDeployOperationHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateInstanceMSDeployOperation creates a new MSDeployStatusPoller from the specified resume token.
// token - The value must come from a previous call to MSDeployStatusPoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateInstanceMSDeployOperation(ctx context.Context, token string) (MSDeployStatusPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateInstanceMSDeployOperation", token, client.con.Pipeline(), client.createInstanceMSDeployOperationHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateInstanceMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationOptions) (*azcore.Response, error) {
	req, err := client.createInstanceMSDeployOperationCreateRequest(ctx, resourceGroupName, name, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.createInstanceMSDeployOperationHandleError(resp)
	}
	return resp, nil
}

// createInstanceMSDeployOperationCreateRequest creates the CreateInstanceMSDeployOperation request.
func (client *WebAppsClient) createInstanceMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(msDeploy)
}

// createInstanceMSDeployOperationHandleError handles the CreateInstanceMSDeployOperation error response.
func (client *WebAppsClient) createInstanceMSDeployOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// BeginCreateInstanceMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationSlotOptions) (MSDeployStatusPollerResponse, error) {
	resp, err := client.createInstanceMSDeployOperationSlot(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateInstanceMSDeployOperationSlot", "", resp, client.con.Pipeline(), client.createInstanceMSDeployOperationSlotHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateInstanceMSDeployOperationSlot creates a new MSDeployStatusPoller from the specified resume token.
// token - The value must come from a previous call to MSDeployStatusPoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateInstanceMSDeployOperationSlot(ctx context.Context, token string) (MSDeployStatusPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateInstanceMSDeployOperationSlot", token, client.con.Pipeline(), client.createInstanceMSDeployOperationSlotHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateInstanceMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationSlotOptions) (*azcore.Response, error) {
	req, err := client.createInstanceMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.createInstanceMSDeployOperationSlotHandleError(resp)
	}
	return resp, nil
}

// createInstanceMSDeployOperationSlotCreateRequest creates the CreateInstanceMSDeployOperationSlot request.
func (client *WebAppsClient) createInstanceMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(msDeploy)
}

// createInstanceMSDeployOperationSlotHandleError handles the CreateInstanceMSDeployOperationSlot error response.
func (client *WebAppsClient) createInstanceMSDeployOperationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// BeginCreateMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationOptions) (MSDeployStatusPollerResponse, error) {
	resp, err := client.createMSDeployOperation(ctx, resourceGroupName, name, msDeploy, options)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateMSDeployOperation", "", resp, client.con.Pipeline(), client.createMSDeployOperationHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateMSDeployOperation creates a new MSDeployStatusPoller from the specified resume token.
// token - The value must come from a previous call to MSDeployStatusPoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateMSDeployOperation(ctx context.Context, token string) (MSDeployStatusPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateMSDeployOperation", token, client.con.Pipeline(), client.createMSDeployOperationHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationOptions) (*azcore.Response, error) {
	req, err := client.createMSDeployOperationCreateRequest(ctx, resourceGroupName, name, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.createMSDeployOperationHandleError(resp)
	}
	return resp, nil
}

// createMSDeployOperationCreateRequest creates the CreateMSDeployOperation request.
func (client *WebAppsClient) createMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(msDeploy)
}

// createMSDeployOperationHandleError handles the CreateMSDeployOperation error response.
func (client *WebAppsClient) createMSDeployOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// BeginCreateMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationSlotOptions) (MSDeployStatusPollerResponse, error) {
	resp, err := client.createMSDeployOperationSlot(ctx, resourceGroupName, name, slot, msDeploy, options)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateMSDeployOperationSlot", "", resp, client.con.Pipeline(), client.createMSDeployOperationSlotHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateMSDeployOperationSlot creates a new MSDeployStatusPoller from the specified resume token.
// token - The value must come from a previous call to MSDeployStatusPoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateMSDeployOperationSlot(ctx context.Context, token string) (MSDeployStatusPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateMSDeployOperationSlot", token, client.con.Pipeline(), client.createMSDeployOperationSlotHandleError)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	poller := &msDeployStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return MSDeployStatusPollerResponse{}, err
	}
	result := MSDeployStatusPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (MSDeployStatusResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationSlotOptions) (*azcore.Response, error) {
	req, err := client.createMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.createMSDeployOperationSlotHandleError(resp)
	}
	return resp, nil
}

// createMSDeployOperationSlotCreateRequest creates the CreateMSDeployOperationSlot request.
func (client *WebAppsClient) createMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(msDeploy)
}

// createMSDeployOperationSlotHandleError handles the CreateMSDeployOperationSlot error response.
func (client *WebAppsClient) createMSDeployOperationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// BeginCreateOrUpdate - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateOptions) (SitePollerResponse, error) {
	resp, err := client.createOrUpdate(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return SitePollerResponse{}, err
	}
	result := SitePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateOrUpdate", "", resp, client.con.Pipeline(), client.createOrUpdateHandleError)
	if err != nil {
		return SitePollerResponse{}, err
	}
	poller := &sitePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdate creates a new SitePoller from the specified resume token.
// token - The value must come from a previous call to SitePoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateOrUpdate(ctx context.Context, token string) (SitePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateOrUpdate", token, client.con.Pipeline(), client.createOrUpdateHandleError)
	if err != nil {
		return SitePollerResponse{}, err
	}
	poller := &sitePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SitePollerResponse{}, err
	}
	result := SitePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdate - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *WebAppsClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteEnvelope)
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *WebAppsClient) createOrUpdateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateConfiguration - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationOptions) (SiteConfigResourceResponse, error) {
	req, err := client.createOrUpdateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.createOrUpdateConfigurationHandleError(resp)
	}
	return client.createOrUpdateConfigurationHandleResponse(resp)
}

// createOrUpdateConfigurationCreateRequest creates the CreateOrUpdateConfiguration request.
func (client *WebAppsClient) createOrUpdateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteConfig)
}

// createOrUpdateConfigurationHandleResponse handles the CreateOrUpdateConfiguration response.
func (client *WebAppsClient) createOrUpdateConfigurationHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// createOrUpdateConfigurationHandleError handles the CreateOrUpdateConfiguration error response.
func (client *WebAppsClient) createOrUpdateConfigurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateConfigurationSlot - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationSlotOptions) (SiteConfigResourceResponse, error) {
	req, err := client.createOrUpdateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.createOrUpdateConfigurationSlotHandleError(resp)
	}
	return client.createOrUpdateConfigurationSlotHandleResponse(resp)
}

// createOrUpdateConfigurationSlotCreateRequest creates the CreateOrUpdateConfigurationSlot request.
func (client *WebAppsClient) createOrUpdateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteConfig)
}

// createOrUpdateConfigurationSlotHandleResponse handles the CreateOrUpdateConfigurationSlot response.
func (client *WebAppsClient) createOrUpdateConfigurationSlotHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// createOrUpdateConfigurationSlotHandleError handles the CreateOrUpdateConfigurationSlot error response.
func (client *WebAppsClient) createOrUpdateConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateDomainOwnershipIdentifier - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierOptions) (IdentifierResponse, error) {
	req, err := client.createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return IdentifierResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IdentifierResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IdentifierResponse{}, client.createOrUpdateDomainOwnershipIdentifierHandleError(resp)
	}
	return client.createOrUpdateDomainOwnershipIdentifierHandleResponse(resp)
}

// createOrUpdateDomainOwnershipIdentifierCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifier request.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(domainOwnershipIdentifier)
}

// createOrUpdateDomainOwnershipIdentifierHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifier response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierHandleResponse(resp *azcore.Response) (IdentifierResponse, error) {
	var val *Identifier
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierResponse{}, err
	}
	return IdentifierResponse{RawResponse: resp.Response, Identifier: val}, nil
}

// createOrUpdateDomainOwnershipIdentifierHandleError handles the CreateOrUpdateDomainOwnershipIdentifier error response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateDomainOwnershipIdentifierSlot - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (IdentifierResponse, error) {
	req, err := client.createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return IdentifierResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IdentifierResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IdentifierResponse{}, client.createOrUpdateDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return client.createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// createOrUpdateDomainOwnershipIdentifierSlotCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(domainOwnershipIdentifier)
}

// createOrUpdateDomainOwnershipIdentifierSlotHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(resp *azcore.Response) (IdentifierResponse, error) {
	var val *Identifier
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierResponse{}, err
	}
	return IdentifierResponse{RawResponse: resp.Response, Identifier: val}, nil
}

// createOrUpdateDomainOwnershipIdentifierSlotHandleError handles the CreateOrUpdateDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateFunctionSecret - Description for Add or update a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretOptions) (KeyInfoResponse, error) {
	req, err := client.createOrUpdateFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, key, options)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return KeyInfoResponse{}, client.createOrUpdateFunctionSecretHandleError(resp)
	}
	return client.createOrUpdateFunctionSecretHandleResponse(resp)
}

// createOrUpdateFunctionSecretCreateRequest creates the CreateOrUpdateFunctionSecret request.
func (client *WebAppsClient) createOrUpdateFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(key)
}

// createOrUpdateFunctionSecretHandleResponse handles the CreateOrUpdateFunctionSecret response.
func (client *WebAppsClient) createOrUpdateFunctionSecretHandleResponse(resp *azcore.Response) (KeyInfoResponse, error) {
	var val *KeyInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyInfoResponse{}, err
	}
	return KeyInfoResponse{RawResponse: resp.Response, KeyInfo: val}, nil
}

// createOrUpdateFunctionSecretHandleError handles the CreateOrUpdateFunctionSecret error response.
func (client *WebAppsClient) createOrUpdateFunctionSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateFunctionSecretSlot - Description for Add or update a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretSlotOptions) (KeyInfoResponse, error) {
	req, err := client.createOrUpdateFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, key, options)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return KeyInfoResponse{}, client.createOrUpdateFunctionSecretSlotHandleError(resp)
	}
	return client.createOrUpdateFunctionSecretSlotHandleResponse(resp)
}

// createOrUpdateFunctionSecretSlotCreateRequest creates the CreateOrUpdateFunctionSecretSlot request.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(key)
}

// createOrUpdateFunctionSecretSlotHandleResponse handles the CreateOrUpdateFunctionSecretSlot response.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotHandleResponse(resp *azcore.Response) (KeyInfoResponse, error) {
	var val *KeyInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyInfoResponse{}, err
	}
	return KeyInfoResponse{RawResponse: resp.Response, KeyInfo: val}, nil
}

// createOrUpdateFunctionSecretSlotHandleError handles the CreateOrUpdateFunctionSecretSlot error response.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateHostNameBinding - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingOptions) (HostNameBindingResponse, error) {
	req, err := client.createOrUpdateHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, hostNameBinding, options)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HostNameBindingResponse{}, client.createOrUpdateHostNameBindingHandleError(resp)
	}
	return client.createOrUpdateHostNameBindingHandleResponse(resp)
}

// createOrUpdateHostNameBindingCreateRequest creates the CreateOrUpdateHostNameBinding request.
func (client *WebAppsClient) createOrUpdateHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(hostNameBinding)
}

// createOrUpdateHostNameBindingHandleResponse handles the CreateOrUpdateHostNameBinding response.
func (client *WebAppsClient) createOrUpdateHostNameBindingHandleResponse(resp *azcore.Response) (HostNameBindingResponse, error) {
	var val *HostNameBinding
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostNameBindingResponse{}, err
	}
	return HostNameBindingResponse{RawResponse: resp.Response, HostNameBinding: val}, nil
}

// createOrUpdateHostNameBindingHandleError handles the CreateOrUpdateHostNameBinding error response.
func (client *WebAppsClient) createOrUpdateHostNameBindingHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateHostNameBindingSlot - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingSlotOptions) (HostNameBindingResponse, error) {
	req, err := client.createOrUpdateHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, hostName, slot, hostNameBinding, options)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HostNameBindingResponse{}, client.createOrUpdateHostNameBindingSlotHandleError(resp)
	}
	return client.createOrUpdateHostNameBindingSlotHandleResponse(resp)
}

// createOrUpdateHostNameBindingSlotCreateRequest creates the CreateOrUpdateHostNameBindingSlot request.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(hostNameBinding)
}

// createOrUpdateHostNameBindingSlotHandleResponse handles the CreateOrUpdateHostNameBindingSlot response.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotHandleResponse(resp *azcore.Response) (HostNameBindingResponse, error) {
	var val *HostNameBinding
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostNameBindingResponse{}, err
	}
	return HostNameBindingResponse{RawResponse: resp.Response, HostNameBinding: val}, nil
}

// createOrUpdateHostNameBindingSlotHandleError handles the CreateOrUpdateHostNameBindingSlot error response.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateHostSecret - Description for Add or update a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretOptions) (KeyInfoResponse, error) {
	req, err := client.createOrUpdateHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, key, options)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return KeyInfoResponse{}, client.createOrUpdateHostSecretHandleError(resp)
	}
	return client.createOrUpdateHostSecretHandleResponse(resp)
}

// createOrUpdateHostSecretCreateRequest creates the CreateOrUpdateHostSecret request.
func (client *WebAppsClient) createOrUpdateHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(key)
}

// createOrUpdateHostSecretHandleResponse handles the CreateOrUpdateHostSecret response.
func (client *WebAppsClient) createOrUpdateHostSecretHandleResponse(resp *azcore.Response) (KeyInfoResponse, error) {
	var val *KeyInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyInfoResponse{}, err
	}
	return KeyInfoResponse{RawResponse: resp.Response, KeyInfo: val}, nil
}

// createOrUpdateHostSecretHandleError handles the CreateOrUpdateHostSecret error response.
func (client *WebAppsClient) createOrUpdateHostSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateHostSecretSlot - Description for Add or update a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretSlotOptions) (KeyInfoResponse, error) {
	req, err := client.createOrUpdateHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, key, options)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return KeyInfoResponse{}, client.createOrUpdateHostSecretSlotHandleError(resp)
	}
	return client.createOrUpdateHostSecretSlotHandleResponse(resp)
}

// createOrUpdateHostSecretSlotCreateRequest creates the CreateOrUpdateHostSecretSlot request.
func (client *WebAppsClient) createOrUpdateHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(key)
}

// createOrUpdateHostSecretSlotHandleResponse handles the CreateOrUpdateHostSecretSlot response.
func (client *WebAppsClient) createOrUpdateHostSecretSlotHandleResponse(resp *azcore.Response) (KeyInfoResponse, error) {
	var val *KeyInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyInfoResponse{}, err
	}
	return KeyInfoResponse{RawResponse: resp.Response, KeyInfo: val}, nil
}

// createOrUpdateHostSecretSlotHandleError handles the CreateOrUpdateHostSecretSlot error response.
func (client *WebAppsClient) createOrUpdateHostSecretSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateHybridConnection - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionOptions) (HybridConnectionResponse, error) {
	req, err := client.createOrUpdateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.createOrUpdateHybridConnectionHandleError(resp)
	}
	return client.createOrUpdateHybridConnectionHandleResponse(resp)
}

// createOrUpdateHybridConnectionCreateRequest creates the CreateOrUpdateHybridConnection request.
func (client *WebAppsClient) createOrUpdateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateHybridConnectionHandleResponse handles the CreateOrUpdateHybridConnection response.
func (client *WebAppsClient) createOrUpdateHybridConnectionHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// createOrUpdateHybridConnectionHandleError handles the CreateOrUpdateHybridConnection error response.
func (client *WebAppsClient) createOrUpdateHybridConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateHybridConnectionSlot - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionSlotOptions) (HybridConnectionResponse, error) {
	req, err := client.createOrUpdateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.createOrUpdateHybridConnectionSlotHandleError(resp)
	}
	return client.createOrUpdateHybridConnectionSlotHandleResponse(resp)
}

// createOrUpdateHybridConnectionSlotCreateRequest creates the CreateOrUpdateHybridConnectionSlot request.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateHybridConnectionSlotHandleResponse handles the CreateOrUpdateHybridConnectionSlot response.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// createOrUpdateHybridConnectionSlotHandleError handles the CreateOrUpdateHybridConnectionSlot error response.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdatePublicCertificate - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdatePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateOptions) (PublicCertificateResponse, error) {
	req, err := client.createOrUpdatePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, publicCertificate, options)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PublicCertificateResponse{}, client.createOrUpdatePublicCertificateHandleError(resp)
	}
	return client.createOrUpdatePublicCertificateHandleResponse(resp)
}

// createOrUpdatePublicCertificateCreateRequest creates the CreateOrUpdatePublicCertificate request.
func (client *WebAppsClient) createOrUpdatePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(publicCertificate)
}

// createOrUpdatePublicCertificateHandleResponse handles the CreateOrUpdatePublicCertificate response.
func (client *WebAppsClient) createOrUpdatePublicCertificateHandleResponse(resp *azcore.Response) (PublicCertificateResponse, error) {
	var val *PublicCertificate
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublicCertificateResponse{}, err
	}
	return PublicCertificateResponse{RawResponse: resp.Response, PublicCertificate: val}, nil
}

// createOrUpdatePublicCertificateHandleError handles the CreateOrUpdatePublicCertificate error response.
func (client *WebAppsClient) createOrUpdatePublicCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdatePublicCertificateSlot - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdatePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateSlotOptions) (PublicCertificateResponse, error) {
	req, err := client.createOrUpdatePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, publicCertificateName, slot, publicCertificate, options)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PublicCertificateResponse{}, client.createOrUpdatePublicCertificateSlotHandleError(resp)
	}
	return client.createOrUpdatePublicCertificateSlotHandleResponse(resp)
}

// createOrUpdatePublicCertificateSlotCreateRequest creates the CreateOrUpdatePublicCertificateSlot request.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(publicCertificate)
}

// createOrUpdatePublicCertificateSlotHandleResponse handles the CreateOrUpdatePublicCertificateSlot response.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotHandleResponse(resp *azcore.Response) (PublicCertificateResponse, error) {
	var val *PublicCertificate
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublicCertificateResponse{}, err
	}
	return PublicCertificateResponse{RawResponse: resp.Response, PublicCertificate: val}, nil
}

// createOrUpdatePublicCertificateSlotHandleError handles the CreateOrUpdatePublicCertificateSlot error response.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateRelayServiceConnection - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.createOrUpdateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.createOrUpdateRelayServiceConnectionHandleError(resp)
	}
	return client.createOrUpdateRelayServiceConnectionHandleResponse(resp)
}

// createOrUpdateRelayServiceConnectionCreateRequest creates the CreateOrUpdateRelayServiceConnection request.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateRelayServiceConnectionHandleResponse handles the CreateOrUpdateRelayServiceConnection response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// createOrUpdateRelayServiceConnectionHandleError handles the CreateOrUpdateRelayServiceConnection error response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateRelayServiceConnectionSlot - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionSlotOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.createOrUpdateRelayServiceConnectionSlotHandleError(resp)
	}
	return client.createOrUpdateRelayServiceConnectionSlotHandleResponse(resp)
}

// createOrUpdateRelayServiceConnectionSlotCreateRequest creates the CreateOrUpdateRelayServiceConnectionSlot request.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateRelayServiceConnectionSlotHandleResponse handles the CreateOrUpdateRelayServiceConnectionSlot response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// createOrUpdateRelayServiceConnectionSlotHandleError handles the CreateOrUpdateRelayServiceConnectionSlot error response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateSlotOptions) (SitePollerResponse, error) {
	resp, err := client.createOrUpdateSlot(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return SitePollerResponse{}, err
	}
	result := SitePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateOrUpdateSlot", "", resp, client.con.Pipeline(), client.createOrUpdateSlotHandleError)
	if err != nil {
		return SitePollerResponse{}, err
	}
	poller := &sitePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdateSlot creates a new SitePoller from the specified resume token.
// token - The value must come from a previous call to SitePoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateOrUpdateSlot(ctx context.Context, token string) (SitePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateOrUpdateSlot", token, client.con.Pipeline(), client.createOrUpdateSlotHandleError)
	if err != nil {
		return SitePollerResponse{}, err
	}
	poller := &sitePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SitePollerResponse{}, err
	}
	result := SitePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateSlotOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateSlotHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateSlotCreateRequest creates the CreateOrUpdateSlot request.
func (client *WebAppsClient) createOrUpdateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteEnvelope)
}

// createOrUpdateSlotHandleError handles the CreateOrUpdateSlot error response.
func (client *WebAppsClient) createOrUpdateSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlOptions) (SiteSourceControlPollerResponse, error) {
	resp, err := client.createOrUpdateSourceControl(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	result := SiteSourceControlPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateOrUpdateSourceControl", "", resp, client.con.Pipeline(), client.createOrUpdateSourceControlHandleError)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	poller := &siteSourceControlPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteSourceControlResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdateSourceControl creates a new SiteSourceControlPoller from the specified resume token.
// token - The value must come from a previous call to SiteSourceControlPoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateOrUpdateSourceControl(ctx context.Context, token string) (SiteSourceControlPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateOrUpdateSourceControl", token, client.con.Pipeline(), client.createOrUpdateSourceControlHandleError)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	poller := &siteSourceControlPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	result := SiteSourceControlPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteSourceControlResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, client.createOrUpdateSourceControlHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateSourceControlCreateRequest creates the CreateOrUpdateSourceControl request.
func (client *WebAppsClient) createOrUpdateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteSourceControl)
}

// createOrUpdateSourceControlHandleError handles the CreateOrUpdateSourceControl error response.
func (client *WebAppsClient) createOrUpdateSourceControlHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlSlotOptions) (SiteSourceControlPollerResponse, error) {
	resp, err := client.createOrUpdateSourceControlSlot(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	result := SiteSourceControlPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.CreateOrUpdateSourceControlSlot", "", resp, client.con.Pipeline(), client.createOrUpdateSourceControlSlotHandleError)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	poller := &siteSourceControlPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteSourceControlResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdateSourceControlSlot creates a new SiteSourceControlPoller from the specified resume token.
// token - The value must come from a previous call to SiteSourceControlPoller.ResumeToken().
func (client *WebAppsClient) ResumeCreateOrUpdateSourceControlSlot(ctx context.Context, token string) (SiteSourceControlPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.CreateOrUpdateSourceControlSlot", token, client.con.Pipeline(), client.createOrUpdateSourceControlSlotHandleError)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	poller := &siteSourceControlPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SiteSourceControlPollerResponse{}, err
	}
	result := SiteSourceControlPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteSourceControlResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlSlotOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, client.createOrUpdateSourceControlSlotHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateSourceControlSlotCreateRequest creates the CreateOrUpdateSourceControlSlot request.
func (client *WebAppsClient) createOrUpdateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteSourceControl)
}

// createOrUpdateSourceControlSlotHandleError handles the CreateOrUpdateSourceControlSlot error response.
func (client *WebAppsClient) createOrUpdateSourceControlSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (SwiftVirtualNetworkResponse, error) {
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SwiftVirtualNetworkResponse{}, client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleError(resp)
	}
	return client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck request.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp *azcore.Response) (SwiftVirtualNetworkResponse, error) {
	var val *SwiftVirtualNetwork
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	return SwiftVirtualNetworkResponse{RawResponse: resp.Response, SwiftVirtualNetwork: val}, nil
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleError handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck error response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (SwiftVirtualNetworkResponse, error) {
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SwiftVirtualNetworkResponse{}, client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp)
	}
	return client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot request.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp *azcore.Response) (SwiftVirtualNetworkResponse, error) {
	var val *SwiftVirtualNetwork
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	return SwiftVirtualNetworkResponse{RawResponse: resp.Response, SwiftVirtualNetwork: val}, nil
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleError handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot error response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateVnetConnection - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *WebAppsCreateOrUpdateVnetConnectionOptions) (VnetInfoResponse, error) {
	req, err := client.createOrUpdateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoResponse{}, client.createOrUpdateVnetConnectionHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionHandleResponse(resp)
}

// createOrUpdateVnetConnectionCreateRequest creates the CreateOrUpdateVnetConnection request.
func (client *WebAppsClient) createOrUpdateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *WebAppsCreateOrUpdateVnetConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateVnetConnectionHandleResponse handles the CreateOrUpdateVnetConnection response.
func (client *WebAppsClient) createOrUpdateVnetConnectionHandleResponse(resp *azcore.Response) (VnetInfoResponse, error) {
	var val *VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoResponse{}, err
	}
	return VnetInfoResponse{RawResponse: resp.Response, VnetInfo: val}, nil
}

// createOrUpdateVnetConnectionHandleError handles the CreateOrUpdateVnetConnection error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateVnetConnectionGateway - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewayOptions) (VnetGatewayResponse, error) {
	req, err := client.createOrUpdateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetGatewayResponse{}, client.createOrUpdateVnetConnectionGatewayHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionGatewayHandleResponse(resp)
}

// createOrUpdateVnetConnectionGatewayCreateRequest creates the CreateOrUpdateVnetConnectionGateway request.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewayOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateVnetConnectionGatewayHandleResponse handles the CreateOrUpdateVnetConnectionGateway response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayHandleResponse(resp *azcore.Response) (VnetGatewayResponse, error) {
	var val *VnetGateway
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetGatewayResponse{}, err
	}
	return VnetGatewayResponse{RawResponse: resp.Response, VnetGateway: val}, nil
}

// createOrUpdateVnetConnectionGatewayHandleError handles the CreateOrUpdateVnetConnectionGateway error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateVnetConnectionGatewaySlot - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewaySlotOptions) (VnetGatewayResponse, error) {
	req, err := client.createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetGatewayResponse{}, client.createOrUpdateVnetConnectionGatewaySlotHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionGatewaySlotHandleResponse(resp)
}

// createOrUpdateVnetConnectionGatewaySlotCreateRequest creates the CreateOrUpdateVnetConnectionGatewaySlot request.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewaySlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateVnetConnectionGatewaySlotHandleResponse handles the CreateOrUpdateVnetConnectionGatewaySlot response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotHandleResponse(resp *azcore.Response) (VnetGatewayResponse, error) {
	var val *VnetGateway
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetGatewayResponse{}, err
	}
	return VnetGatewayResponse{RawResponse: resp.Response, VnetGateway: val}, nil
}

// createOrUpdateVnetConnectionGatewaySlotHandleError handles the CreateOrUpdateVnetConnectionGatewaySlot error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateOrUpdateVnetConnectionSlot - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *WebAppsCreateOrUpdateVnetConnectionSlotOptions) (VnetInfoResponse, error) {
	req, err := client.createOrUpdateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoResponse{}, client.createOrUpdateVnetConnectionSlotHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionSlotHandleResponse(resp)
}

// createOrUpdateVnetConnectionSlotCreateRequest creates the CreateOrUpdateVnetConnectionSlot request.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *WebAppsCreateOrUpdateVnetConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// createOrUpdateVnetConnectionSlotHandleResponse handles the CreateOrUpdateVnetConnectionSlot response.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotHandleResponse(resp *azcore.Response) (VnetInfoResponse, error) {
	var val *VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoResponse{}, err
	}
	return VnetInfoResponse{RawResponse: resp.Response, VnetInfo: val}, nil
}

// createOrUpdateVnetConnectionSlotHandleError handles the CreateOrUpdateVnetConnectionSlot error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Delete - Description for Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Delete(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteOptions) (*http.Response, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return resp.Response, nil
}

// deleteCreateRequest creates the Delete request.
func (client *WebAppsClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *WebAppsClient) deleteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteBackup - Description for Deletes a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackup(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsDeleteBackupOptions) (*http.Response, error) {
	req, err := client.deleteBackupCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteBackupHandleError(resp)
	}
	return resp.Response, nil
}

// deleteBackupCreateRequest creates the DeleteBackup request.
func (client *WebAppsClient) deleteBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsDeleteBackupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupHandleError handles the DeleteBackup error response.
func (client *WebAppsClient) deleteBackupHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteBackupConfiguration - Description for Deletes the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteBackupConfigurationOptions) (*http.Response, error) {
	req, err := client.deleteBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteBackupConfigurationHandleError(resp)
	}
	return resp.Response, nil
}

// deleteBackupConfigurationCreateRequest creates the DeleteBackupConfiguration request.
func (client *WebAppsClient) deleteBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteBackupConfigurationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupConfigurationHandleError handles the DeleteBackupConfiguration error response.
func (client *WebAppsClient) deleteBackupConfigurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteBackupConfigurationSlot - Description for Deletes the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteBackupConfigurationSlotOptions) (*http.Response, error) {
	req, err := client.deleteBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteBackupConfigurationSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteBackupConfigurationSlotCreateRequest creates the DeleteBackupConfigurationSlot request.
func (client *WebAppsClient) deleteBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteBackupConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupConfigurationSlotHandleError handles the DeleteBackupConfigurationSlot error response.
func (client *WebAppsClient) deleteBackupConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteBackupSlot - Description for Deletes a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackupSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsDeleteBackupSlotOptions) (*http.Response, error) {
	req, err := client.deleteBackupSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteBackupSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteBackupSlotCreateRequest creates the DeleteBackupSlot request.
func (client *WebAppsClient) deleteBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsDeleteBackupSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupSlotHandleError handles the DeleteBackupSlot error response.
func (client *WebAppsClient) deleteBackupSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteContinuousWebJob - Description for Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteContinuousWebJobOptions) (*http.Response, error) {
	req, err := client.deleteContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteContinuousWebJobHandleError(resp)
	}
	return resp.Response, nil
}

// deleteContinuousWebJobCreateRequest creates the DeleteContinuousWebJob request.
func (client *WebAppsClient) deleteContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteContinuousWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteContinuousWebJobHandleError handles the DeleteContinuousWebJob error response.
func (client *WebAppsClient) deleteContinuousWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteContinuousWebJobSlot - Description for Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteContinuousWebJobSlotOptions) (*http.Response, error) {
	req, err := client.deleteContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteContinuousWebJobSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteContinuousWebJobSlotCreateRequest creates the DeleteContinuousWebJobSlot request.
func (client *WebAppsClient) deleteContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteContinuousWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteContinuousWebJobSlotHandleError handles the DeleteContinuousWebJobSlot error response.
func (client *WebAppsClient) deleteContinuousWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteDeployment - Description for Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsDeleteDeploymentOptions) (*http.Response, error) {
	req, err := client.deleteDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteDeploymentHandleError(resp)
	}
	return resp.Response, nil
}

// deleteDeploymentCreateRequest creates the DeleteDeployment request.
func (client *WebAppsClient) deleteDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsDeleteDeploymentOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDeploymentHandleError handles the DeleteDeployment error response.
func (client *WebAppsClient) deleteDeploymentHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteDeploymentSlot - Description for Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsDeleteDeploymentSlotOptions) (*http.Response, error) {
	req, err := client.deleteDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteDeploymentSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteDeploymentSlotCreateRequest creates the DeleteDeploymentSlot request.
func (client *WebAppsClient) deleteDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsDeleteDeploymentSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDeploymentSlotHandleError handles the DeleteDeploymentSlot error response.
func (client *WebAppsClient) deleteDeploymentSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteDomainOwnershipIdentifier - Description for Deletes a domain ownership identifier for a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsDeleteDomainOwnershipIdentifierOptions) (*http.Response, error) {
	req, err := client.deleteDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteDomainOwnershipIdentifierHandleError(resp)
	}
	return resp.Response, nil
}

// deleteDomainOwnershipIdentifierCreateRequest creates the DeleteDomainOwnershipIdentifier request.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsDeleteDomainOwnershipIdentifierOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDomainOwnershipIdentifierHandleError handles the DeleteDomainOwnershipIdentifier error response.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteDomainOwnershipIdentifierSlot - Description for Deletes a domain ownership identifier for a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsDeleteDomainOwnershipIdentifierSlotOptions) (*http.Response, error) {
	req, err := client.deleteDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteDomainOwnershipIdentifierSlotCreateRequest creates the DeleteDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsDeleteDomainOwnershipIdentifierSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDomainOwnershipIdentifierSlotHandleError handles the DeleteDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteFunction - Description for Delete a function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsDeleteFunctionOptions) (*http.Response, error) {
	req, err := client.deleteFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteFunctionHandleError(resp)
	}
	return resp.Response, nil
}

// deleteFunctionCreateRequest creates the DeleteFunction request.
func (client *WebAppsClient) deleteFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsDeleteFunctionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteFunctionHandleError handles the DeleteFunction error response.
func (client *WebAppsClient) deleteFunctionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteFunctionSecret - Description for Delete a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *WebAppsDeleteFunctionSecretOptions) (*http.Response, error) {
	req, err := client.deleteFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteFunctionSecretHandleError(resp)
	}
	return resp.Response, nil
}

// deleteFunctionSecretCreateRequest creates the DeleteFunctionSecret request.
func (client *WebAppsClient) deleteFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *WebAppsDeleteFunctionSecretOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteFunctionSecretHandleError handles the DeleteFunctionSecret error response.
func (client *WebAppsClient) deleteFunctionSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteFunctionSecretSlot - Description for Delete a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *WebAppsDeleteFunctionSecretSlotOptions) (*http.Response, error) {
	req, err := client.deleteFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteFunctionSecretSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteFunctionSecretSlotCreateRequest creates the DeleteFunctionSecretSlot request.
func (client *WebAppsClient) deleteFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *WebAppsDeleteFunctionSecretSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteFunctionSecretSlotHandleError handles the DeleteFunctionSecretSlot error response.
func (client *WebAppsClient) deleteFunctionSecretSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteHostNameBinding - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsDeleteHostNameBindingOptions) (*http.Response, error) {
	req, err := client.deleteHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteHostNameBindingHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHostNameBindingCreateRequest creates the DeleteHostNameBinding request.
func (client *WebAppsClient) deleteHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsDeleteHostNameBindingOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostNameBindingHandleError handles the DeleteHostNameBinding error response.
func (client *WebAppsClient) deleteHostNameBindingHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteHostNameBindingSlot - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsDeleteHostNameBindingSlotOptions) (*http.Response, error) {
	req, err := client.deleteHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteHostNameBindingSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHostNameBindingSlotCreateRequest creates the DeleteHostNameBindingSlot request.
func (client *WebAppsClient) deleteHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsDeleteHostNameBindingSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostNameBindingSlotHandleError handles the DeleteHostNameBindingSlot error response.
func (client *WebAppsClient) deleteHostNameBindingSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteHostSecret - Description for Delete a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *WebAppsDeleteHostSecretOptions) (*http.Response, error) {
	req, err := client.deleteHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteHostSecretHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHostSecretCreateRequest creates the DeleteHostSecret request.
func (client *WebAppsClient) deleteHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *WebAppsDeleteHostSecretOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostSecretHandleError handles the DeleteHostSecret error response.
func (client *WebAppsClient) deleteHostSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteHostSecretSlot - Description for Delete a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *WebAppsDeleteHostSecretSlotOptions) (*http.Response, error) {
	req, err := client.deleteHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteHostSecretSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHostSecretSlotCreateRequest creates the DeleteHostSecretSlot request.
func (client *WebAppsClient) deleteHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *WebAppsDeleteHostSecretSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostSecretSlotHandleError handles the DeleteHostSecretSlot error response.
func (client *WebAppsClient) deleteHostSecretSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteHybridConnection - Description for Removes a Hybrid Connection from this site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsDeleteHybridConnectionOptions) (*http.Response, error) {
	req, err := client.deleteHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteHybridConnectionHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHybridConnectionCreateRequest creates the DeleteHybridConnection request.
func (client *WebAppsClient) deleteHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsDeleteHybridConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHybridConnectionHandleError handles the DeleteHybridConnection error response.
func (client *WebAppsClient) deleteHybridConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteHybridConnectionSlot - Description for Removes a Hybrid Connection from this site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsDeleteHybridConnectionSlotOptions) (*http.Response, error) {
	req, err := client.deleteHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteHybridConnectionSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHybridConnectionSlotCreateRequest creates the DeleteHybridConnectionSlot request.
func (client *WebAppsClient) deleteHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsDeleteHybridConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHybridConnectionSlotHandleError handles the DeleteHybridConnectionSlot error response.
func (client *WebAppsClient) deleteHybridConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteInstanceFunctionSlot - Description for Delete a function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsDeleteInstanceFunctionSlotOptions) (*http.Response, error) {
	req, err := client.deleteInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteInstanceFunctionSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteInstanceFunctionSlotCreateRequest creates the DeleteInstanceFunctionSlot request.
func (client *WebAppsClient) deleteInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsDeleteInstanceFunctionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteInstanceFunctionSlotHandleError handles the DeleteInstanceFunctionSlot error response.
func (client *WebAppsClient) deleteInstanceFunctionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteInstanceProcess - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web
// site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsDeleteInstanceProcessOptions) (*http.Response, error) {
	req, err := client.deleteInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteInstanceProcessHandleError(resp)
	}
	return resp.Response, nil
}

// deleteInstanceProcessCreateRequest creates the DeleteInstanceProcess request.
func (client *WebAppsClient) deleteInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsDeleteInstanceProcessOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteInstanceProcessHandleError handles the DeleteInstanceProcess error response.
func (client *WebAppsClient) deleteInstanceProcessHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteInstanceProcessSlot - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a
// web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsDeleteInstanceProcessSlotOptions) (*http.Response, error) {
	req, err := client.deleteInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteInstanceProcessSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteInstanceProcessSlotCreateRequest creates the DeleteInstanceProcessSlot request.
func (client *WebAppsClient) deleteInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsDeleteInstanceProcessSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteInstanceProcessSlotHandleError handles the DeleteInstanceProcessSlot error response.
func (client *WebAppsClient) deleteInstanceProcessSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeletePremierAddOn - Description for Delete a premier add-on from an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsDeletePremierAddOnOptions) (*http.Response, error) {
	req, err := client.deletePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deletePremierAddOnHandleError(resp)
	}
	return resp.Response, nil
}

// deletePremierAddOnCreateRequest creates the DeletePremierAddOn request.
func (client *WebAppsClient) deletePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsDeletePremierAddOnOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePremierAddOnHandleError handles the DeletePremierAddOn error response.
func (client *WebAppsClient) deletePremierAddOnHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeletePremierAddOnSlot - Description for Delete a premier add-on from an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsDeletePremierAddOnSlotOptions) (*http.Response, error) {
	req, err := client.deletePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deletePremierAddOnSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deletePremierAddOnSlotCreateRequest creates the DeletePremierAddOnSlot request.
func (client *WebAppsClient) deletePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsDeletePremierAddOnSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePremierAddOnSlotHandleError handles the DeletePremierAddOnSlot error response.
func (client *WebAppsClient) deletePremierAddOnSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginDeletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsBeginDeletePrivateEndpointConnectionOptions) (ObjectPollerResponse, error) {
	resp, err := client.deletePrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	result := ObjectPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.DeletePrivateEndpointConnection", "", resp, client.con.Pipeline(), client.deletePrivateEndpointConnectionHandleError)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	poller := &objectPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ObjectResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeletePrivateEndpointConnection creates a new ObjectPoller from the specified resume token.
// token - The value must come from a previous call to ObjectPoller.ResumeToken().
func (client *WebAppsClient) ResumeDeletePrivateEndpointConnection(ctx context.Context, token string) (ObjectPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.DeletePrivateEndpointConnection", token, client.con.Pipeline(), client.deletePrivateEndpointConnectionHandleError)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	poller := &objectPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	result := ObjectPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ObjectResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) deletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsBeginDeletePrivateEndpointConnectionOptions) (*azcore.Response, error) {
	req, err := client.deletePrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// deletePrivateEndpointConnectionCreateRequest creates the DeletePrivateEndpointConnection request.
func (client *WebAppsClient) deletePrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsBeginDeletePrivateEndpointConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePrivateEndpointConnectionHandleError handles the DeletePrivateEndpointConnection error response.
func (client *WebAppsClient) deletePrivateEndpointConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeletePrivateEndpointConnectionSlot - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginDeletePrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsBeginDeletePrivateEndpointConnectionSlotOptions) (ObjectPollerResponse, error) {
	resp, err := client.deletePrivateEndpointConnectionSlot(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	result := ObjectPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.DeletePrivateEndpointConnectionSlot", "", resp, client.con.Pipeline(), client.deletePrivateEndpointConnectionSlotHandleError)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	poller := &objectPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ObjectResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeletePrivateEndpointConnectionSlot creates a new ObjectPoller from the specified resume token.
// token - The value must come from a previous call to ObjectPoller.ResumeToken().
func (client *WebAppsClient) ResumeDeletePrivateEndpointConnectionSlot(ctx context.Context, token string) (ObjectPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.DeletePrivateEndpointConnectionSlot", token, client.con.Pipeline(), client.deletePrivateEndpointConnectionSlotHandleError)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	poller := &objectPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return ObjectPollerResponse{}, err
	}
	result := ObjectPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ObjectResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeletePrivateEndpointConnectionSlot - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) deletePrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsBeginDeletePrivateEndpointConnectionSlotOptions) (*azcore.Response, error) {
	req, err := client.deletePrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePrivateEndpointConnectionSlotHandleError(resp)
	}
	return resp, nil
}

// deletePrivateEndpointConnectionSlotCreateRequest creates the DeletePrivateEndpointConnectionSlot request.
func (client *WebAppsClient) deletePrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsBeginDeletePrivateEndpointConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePrivateEndpointConnectionSlotHandleError handles the DeletePrivateEndpointConnectionSlot error response.
func (client *WebAppsClient) deletePrivateEndpointConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteProcess - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsDeleteProcessOptions) (*http.Response, error) {
	req, err := client.deleteProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteProcessHandleError(resp)
	}
	return resp.Response, nil
}

// deleteProcessCreateRequest creates the DeleteProcess request.
func (client *WebAppsClient) deleteProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsDeleteProcessOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProcessHandleError handles the DeleteProcess error response.
func (client *WebAppsClient) deleteProcessHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteProcessSlot - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsDeleteProcessSlotOptions) (*http.Response, error) {
	req, err := client.deleteProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteProcessSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteProcessSlotCreateRequest creates the DeleteProcessSlot request.
func (client *WebAppsClient) deleteProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsDeleteProcessSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProcessSlotHandleError handles the DeleteProcessSlot error response.
func (client *WebAppsClient) deleteProcessSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeletePublicCertificate - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsDeletePublicCertificateOptions) (*http.Response, error) {
	req, err := client.deletePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deletePublicCertificateHandleError(resp)
	}
	return resp.Response, nil
}

// deletePublicCertificateCreateRequest creates the DeletePublicCertificate request.
func (client *WebAppsClient) deletePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsDeletePublicCertificateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePublicCertificateHandleError handles the DeletePublicCertificate error response.
func (client *WebAppsClient) deletePublicCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeletePublicCertificateSlot - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsDeletePublicCertificateSlotOptions) (*http.Response, error) {
	req, err := client.deletePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deletePublicCertificateSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deletePublicCertificateSlotCreateRequest creates the DeletePublicCertificateSlot request.
func (client *WebAppsClient) deletePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsDeletePublicCertificateSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePublicCertificateSlotHandleError handles the DeletePublicCertificateSlot error response.
func (client *WebAppsClient) deletePublicCertificateSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteRelayServiceConnection - Description for Deletes a relay service connection by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsDeleteRelayServiceConnectionOptions) (*http.Response, error) {
	req, err := client.deleteRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteRelayServiceConnectionHandleError(resp)
	}
	return resp.Response, nil
}

// deleteRelayServiceConnectionCreateRequest creates the DeleteRelayServiceConnection request.
func (client *WebAppsClient) deleteRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsDeleteRelayServiceConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteRelayServiceConnectionHandleError handles the DeleteRelayServiceConnection error response.
func (client *WebAppsClient) deleteRelayServiceConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteRelayServiceConnectionSlot - Description for Deletes a relay service connection by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsDeleteRelayServiceConnectionSlotOptions) (*http.Response, error) {
	req, err := client.deleteRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteRelayServiceConnectionSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteRelayServiceConnectionSlotCreateRequest creates the DeleteRelayServiceConnectionSlot request.
func (client *WebAppsClient) deleteRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsDeleteRelayServiceConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteRelayServiceConnectionSlotHandleError handles the DeleteRelayServiceConnectionSlot error response.
func (client *WebAppsClient) deleteRelayServiceConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteSiteExtension - Description for Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsDeleteSiteExtensionOptions) (*http.Response, error) {
	req, err := client.deleteSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteSiteExtensionHandleError(resp)
	}
	return resp.Response, nil
}

// deleteSiteExtensionCreateRequest creates the DeleteSiteExtension request.
func (client *WebAppsClient) deleteSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsDeleteSiteExtensionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSiteExtensionHandleError handles the DeleteSiteExtension error response.
func (client *WebAppsClient) deleteSiteExtensionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteSiteExtensionSlot - Description for Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsDeleteSiteExtensionSlotOptions) (*http.Response, error) {
	req, err := client.deleteSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteSiteExtensionSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteSiteExtensionSlotCreateRequest creates the DeleteSiteExtensionSlot request.
func (client *WebAppsClient) deleteSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsDeleteSiteExtensionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSiteExtensionSlotHandleError handles the DeleteSiteExtensionSlot error response.
func (client *WebAppsClient) deleteSiteExtensionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteSlot - Description for Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSlotOptions) (*http.Response, error) {
	req, err := client.deleteSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteSlotCreateRequest creates the DeleteSlot request.
func (client *WebAppsClient) deleteSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSlotHandleError handles the DeleteSlot error response.
func (client *WebAppsClient) deleteSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteSourceControl - Description for Deletes the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSourceControl(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSourceControlOptions) (*http.Response, error) {
	req, err := client.deleteSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.deleteSourceControlHandleError(resp)
	}
	return resp.Response, nil
}

// deleteSourceControlCreateRequest creates the DeleteSourceControl request.
func (client *WebAppsClient) deleteSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSourceControlOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.AdditionalFlags != nil {
		reqQP.Set("additionalFlags", *options.AdditionalFlags)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSourceControlHandleError handles the DeleteSourceControl error response.
func (client *WebAppsClient) deleteSourceControlHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteSourceControlSlot - Description for Deletes the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSourceControlSlotOptions) (*http.Response, error) {
	req, err := client.deleteSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.deleteSourceControlSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteSourceControlSlotCreateRequest creates the DeleteSourceControlSlot request.
func (client *WebAppsClient) deleteSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSourceControlSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.AdditionalFlags != nil {
		reqQP.Set("additionalFlags", *options.AdditionalFlags)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSourceControlSlotHandleError handles the DeleteSourceControlSlot error response.
func (client *WebAppsClient) deleteSourceControlSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteSwiftVirtualNetwork - Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSwiftVirtualNetwork(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSwiftVirtualNetworkOptions) (*http.Response, error) {
	req, err := client.deleteSwiftVirtualNetworkCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteSwiftVirtualNetworkHandleError(resp)
	}
	return resp.Response, nil
}

// deleteSwiftVirtualNetworkCreateRequest creates the DeleteSwiftVirtualNetwork request.
func (client *WebAppsClient) deleteSwiftVirtualNetworkCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSwiftVirtualNetworkOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSwiftVirtualNetworkHandleError handles the DeleteSwiftVirtualNetwork error response.
func (client *WebAppsClient) deleteSwiftVirtualNetworkHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteSwiftVirtualNetworkSlot - Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSwiftVirtualNetworkSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSwiftVirtualNetworkSlotOptions) (*http.Response, error) {
	req, err := client.deleteSwiftVirtualNetworkSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteSwiftVirtualNetworkSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteSwiftVirtualNetworkSlotCreateRequest creates the DeleteSwiftVirtualNetworkSlot request.
func (client *WebAppsClient) deleteSwiftVirtualNetworkSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSwiftVirtualNetworkSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSwiftVirtualNetworkSlotHandleError handles the DeleteSwiftVirtualNetworkSlot error response.
func (client *WebAppsClient) deleteSwiftVirtualNetworkSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteTriggeredWebJob - Description for Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteTriggeredWebJobOptions) (*http.Response, error) {
	req, err := client.deleteTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteTriggeredWebJobHandleError(resp)
	}
	return resp.Response, nil
}

// deleteTriggeredWebJobCreateRequest creates the DeleteTriggeredWebJob request.
func (client *WebAppsClient) deleteTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteTriggeredWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteTriggeredWebJobHandleError handles the DeleteTriggeredWebJob error response.
func (client *WebAppsClient) deleteTriggeredWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteTriggeredWebJobSlot - Description for Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteTriggeredWebJobSlotOptions) (*http.Response, error) {
	req, err := client.deleteTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteTriggeredWebJobSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteTriggeredWebJobSlotCreateRequest creates the DeleteTriggeredWebJobSlot request.
func (client *WebAppsClient) deleteTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteTriggeredWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteTriggeredWebJobSlotHandleError handles the DeleteTriggeredWebJobSlot error response.
func (client *WebAppsClient) deleteTriggeredWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteVnetConnection - Description for Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsDeleteVnetConnectionOptions) (*http.Response, error) {
	req, err := client.deleteVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteVnetConnectionHandleError(resp)
	}
	return resp.Response, nil
}

// deleteVnetConnectionCreateRequest creates the DeleteVnetConnection request.
func (client *WebAppsClient) deleteVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsDeleteVnetConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteVnetConnectionHandleError handles the DeleteVnetConnection error response.
func (client *WebAppsClient) deleteVnetConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DeleteVnetConnectionSlot - Description for Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsDeleteVnetConnectionSlotOptions) (*http.Response, error) {
	req, err := client.deleteVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteVnetConnectionSlotHandleError(resp)
	}
	return resp.Response, nil
}

// deleteVnetConnectionSlotCreateRequest creates the DeleteVnetConnectionSlot request.
func (client *WebAppsClient) deleteVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsDeleteVnetConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteVnetConnectionSlotHandleError handles the DeleteVnetConnectionSlot error response.
func (client *WebAppsClient) deleteVnetConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// DiscoverBackup - Description for Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to get information about
// the databases stored in a backup.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DiscoverBackup(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsDiscoverBackupOptions) (RestoreRequestResponse, error) {
	req, err := client.discoverBackupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return RestoreRequestResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RestoreRequestResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RestoreRequestResponse{}, client.discoverBackupHandleError(resp)
	}
	return client.discoverBackupHandleResponse(resp)
}

// discoverBackupCreateRequest creates the DiscoverBackup request.
func (client *WebAppsClient) discoverBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsDiscoverBackupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// discoverBackupHandleResponse handles the DiscoverBackup response.
func (client *WebAppsClient) discoverBackupHandleResponse(resp *azcore.Response) (RestoreRequestResponse, error) {
	var val *RestoreRequest
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RestoreRequestResponse{}, err
	}
	return RestoreRequestResponse{RawResponse: resp.Response, RestoreRequest: val}, nil
}

// discoverBackupHandleError handles the DiscoverBackup error response.
func (client *WebAppsClient) discoverBackupHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DiscoverBackupSlot - Description for Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to get information
// about the databases stored in a backup.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DiscoverBackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsDiscoverBackupSlotOptions) (RestoreRequestResponse, error) {
	req, err := client.discoverBackupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return RestoreRequestResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RestoreRequestResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RestoreRequestResponse{}, client.discoverBackupSlotHandleError(resp)
	}
	return client.discoverBackupSlotHandleResponse(resp)
}

// discoverBackupSlotCreateRequest creates the DiscoverBackupSlot request.
func (client *WebAppsClient) discoverBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsDiscoverBackupSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// discoverBackupSlotHandleResponse handles the DiscoverBackupSlot response.
func (client *WebAppsClient) discoverBackupSlotHandleResponse(resp *azcore.Response) (RestoreRequestResponse, error) {
	var val *RestoreRequest
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RestoreRequestResponse{}, err
	}
	return RestoreRequestResponse{RawResponse: resp.Response, RestoreRequest: val}, nil
}

// discoverBackupSlotHandleError handles the DiscoverBackupSlot error response.
func (client *WebAppsClient) discoverBackupSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GenerateNewSitePublishingPassword - Description for Generates a new publishing password for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GenerateNewSitePublishingPassword(ctx context.Context, resourceGroupName string, name string, options *WebAppsGenerateNewSitePublishingPasswordOptions) (*http.Response, error) {
	req, err := client.generateNewSitePublishingPasswordCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.generateNewSitePublishingPasswordHandleError(resp)
	}
	return resp.Response, nil
}

// generateNewSitePublishingPasswordCreateRequest creates the GenerateNewSitePublishingPassword request.
func (client *WebAppsClient) generateNewSitePublishingPasswordCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGenerateNewSitePublishingPasswordOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// generateNewSitePublishingPasswordHandleError handles the GenerateNewSitePublishingPassword error response.
func (client *WebAppsClient) generateNewSitePublishingPasswordHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GenerateNewSitePublishingPasswordSlot - Description for Generates a new publishing password for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GenerateNewSitePublishingPasswordSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGenerateNewSitePublishingPasswordSlotOptions) (*http.Response, error) {
	req, err := client.generateNewSitePublishingPasswordSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.generateNewSitePublishingPasswordSlotHandleError(resp)
	}
	return resp.Response, nil
}

// generateNewSitePublishingPasswordSlotCreateRequest creates the GenerateNewSitePublishingPasswordSlot request.
func (client *WebAppsClient) generateNewSitePublishingPasswordSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGenerateNewSitePublishingPasswordSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// generateNewSitePublishingPasswordSlotHandleError handles the GenerateNewSitePublishingPasswordSlot error response.
func (client *WebAppsClient) generateNewSitePublishingPasswordSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Get - Description for Gets the details of a web, mobile, or API app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Get(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetOptions) (SiteResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SiteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *WebAppsClient) getCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *WebAppsClient) getHandleResponse(resp *azcore.Response) (SiteResponse, error) {
	var val *Site
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteResponse{}, err
	}
	return SiteResponse{RawResponse: resp.Response, Site: val}, nil
}

// getHandleError handles the Get error response.
func (client *WebAppsClient) getHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetAppSettingKeyVaultReference - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingKeyVaultReference(ctx context.Context, resourceGroupName string, name string, appSettingKey string, options *WebAppsGetAppSettingKeyVaultReferenceOptions) (APIKVReferenceResponse, error) {
	req, err := client.getAppSettingKeyVaultReferenceCreateRequest(ctx, resourceGroupName, name, appSettingKey, options)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return APIKVReferenceResponse{}, client.getAppSettingKeyVaultReferenceHandleError(resp)
	}
	return client.getAppSettingKeyVaultReferenceHandleResponse(resp)
}

// getAppSettingKeyVaultReferenceCreateRequest creates the GetAppSettingKeyVaultReference request.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettingKey string, options *WebAppsGetAppSettingKeyVaultReferenceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings/{appSettingKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if appSettingKey == "" {
		return nil, errors.New("parameter appSettingKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{appSettingKey}", url.PathEscape(appSettingKey))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingKeyVaultReferenceHandleResponse handles the GetAppSettingKeyVaultReference response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceHandleResponse(resp *azcore.Response) (APIKVReferenceResponse, error) {
	var val *APIKVReference
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceResponse{}, err
	}
	return APIKVReferenceResponse{RawResponse: resp.Response, APIKVReference: val}, nil
}

// getAppSettingKeyVaultReferenceHandleError handles the GetAppSettingKeyVaultReference error response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAppSettingKeyVaultReferenceSlot - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingKeyVaultReferenceSlot(ctx context.Context, resourceGroupName string, name string, appSettingKey string, slot string, options *WebAppsGetAppSettingKeyVaultReferenceSlotOptions) (APIKVReferenceResponse, error) {
	req, err := client.getAppSettingKeyVaultReferenceSlotCreateRequest(ctx, resourceGroupName, name, appSettingKey, slot, options)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return APIKVReferenceResponse{}, client.getAppSettingKeyVaultReferenceSlotHandleError(resp)
	}
	return client.getAppSettingKeyVaultReferenceSlotHandleResponse(resp)
}

// getAppSettingKeyVaultReferenceSlotCreateRequest creates the GetAppSettingKeyVaultReferenceSlot request.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettingKey string, slot string, options *WebAppsGetAppSettingKeyVaultReferenceSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings/{appSettingKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if appSettingKey == "" {
		return nil, errors.New("parameter appSettingKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{appSettingKey}", url.PathEscape(appSettingKey))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingKeyVaultReferenceSlotHandleResponse handles the GetAppSettingKeyVaultReferenceSlot response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotHandleResponse(resp *azcore.Response) (APIKVReferenceResponse, error) {
	var val *APIKVReference
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceResponse{}, err
	}
	return APIKVReferenceResponse{RawResponse: resp.Response, APIKVReference: val}, nil
}

// getAppSettingKeyVaultReferenceSlotHandleError handles the GetAppSettingKeyVaultReferenceSlot error response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAppSettingsKeyVaultReferences - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingsKeyVaultReferences(resourceGroupName string, name string, options *WebAppsGetAppSettingsKeyVaultReferencesOptions) APIKVReferenceCollectionPager {
	return &apikvReferenceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getAppSettingsKeyVaultReferencesCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.getAppSettingsKeyVaultReferencesHandleResponse,
		errorer:   client.getAppSettingsKeyVaultReferencesHandleError,
		advancer: func(ctx context.Context, resp APIKVReferenceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getAppSettingsKeyVaultReferencesCreateRequest creates the GetAppSettingsKeyVaultReferences request.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAppSettingsKeyVaultReferencesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingsKeyVaultReferencesHandleResponse handles the GetAppSettingsKeyVaultReferences response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesHandleResponse(resp *azcore.Response) (APIKVReferenceCollectionResponse, error) {
	var val *APIKVReferenceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceCollectionResponse{}, err
	}
	return APIKVReferenceCollectionResponse{RawResponse: resp.Response, APIKVReferenceCollection: val}, nil
}

// getAppSettingsKeyVaultReferencesHandleError handles the GetAppSettingsKeyVaultReferences error response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAppSettingsKeyVaultReferencesSlot - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingsKeyVaultReferencesSlot(resourceGroupName string, name string, slot string, options *WebAppsGetAppSettingsKeyVaultReferencesSlotOptions) APIKVReferenceCollectionPager {
	return &apikvReferenceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getAppSettingsKeyVaultReferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.getAppSettingsKeyVaultReferencesSlotHandleResponse,
		errorer:   client.getAppSettingsKeyVaultReferencesSlotHandleError,
		advancer: func(ctx context.Context, resp APIKVReferenceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getAppSettingsKeyVaultReferencesSlotCreateRequest creates the GetAppSettingsKeyVaultReferencesSlot request.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAppSettingsKeyVaultReferencesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingsKeyVaultReferencesSlotHandleResponse handles the GetAppSettingsKeyVaultReferencesSlot response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotHandleResponse(resp *azcore.Response) (APIKVReferenceCollectionResponse, error) {
	var val *APIKVReferenceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceCollectionResponse{}, err
	}
	return APIKVReferenceCollectionResponse{RawResponse: resp.Response, APIKVReferenceCollection: val}, nil
}

// getAppSettingsKeyVaultReferencesSlotHandleError handles the GetAppSettingsKeyVaultReferencesSlot error response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAuthSettings - Description for Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsOptions) (SiteAuthSettingsResponse, error) {
	req, err := client.getAuthSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsResponse{}, client.getAuthSettingsHandleError(resp)
	}
	return client.getAuthSettingsHandleResponse(resp)
}

// getAuthSettingsCreateRequest creates the GetAuthSettings request.
func (client *WebAppsClient) getAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsHandleResponse handles the GetAuthSettings response.
func (client *WebAppsClient) getAuthSettingsHandleResponse(resp *azcore.Response) (SiteAuthSettingsResponse, error) {
	var val *SiteAuthSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	return SiteAuthSettingsResponse{RawResponse: resp.Response, SiteAuthSettings: val}, nil
}

// getAuthSettingsHandleError handles the GetAuthSettings error response.
func (client *WebAppsClient) getAuthSettingsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAuthSettingsSlot - Description for Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsSlotOptions) (SiteAuthSettingsResponse, error) {
	req, err := client.getAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsResponse{}, client.getAuthSettingsSlotHandleError(resp)
	}
	return client.getAuthSettingsSlotHandleResponse(resp)
}

// getAuthSettingsSlotCreateRequest creates the GetAuthSettingsSlot request.
func (client *WebAppsClient) getAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsSlotHandleResponse handles the GetAuthSettingsSlot response.
func (client *WebAppsClient) getAuthSettingsSlotHandleResponse(resp *azcore.Response) (SiteAuthSettingsResponse, error) {
	var val *SiteAuthSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	return SiteAuthSettingsResponse{RawResponse: resp.Response, SiteAuthSettings: val}, nil
}

// getAuthSettingsSlotHandleError handles the GetAuthSettingsSlot error response.
func (client *WebAppsClient) getAuthSettingsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAuthSettingsV2 - Description for Gets site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettingsV2(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsV2Options) (SiteAuthSettingsV2Response, error) {
	req, err := client.getAuthSettingsV2CreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsV2Response{}, client.getAuthSettingsV2HandleError(resp)
	}
	return client.getAuthSettingsV2HandleResponse(resp)
}

// getAuthSettingsV2CreateRequest creates the GetAuthSettingsV2 request.
func (client *WebAppsClient) getAuthSettingsV2CreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsV2Options) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsV2HandleResponse handles the GetAuthSettingsV2 response.
func (client *WebAppsClient) getAuthSettingsV2HandleResponse(resp *azcore.Response) (SiteAuthSettingsV2Response, error) {
	var val *SiteAuthSettingsV2
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	return SiteAuthSettingsV2Response{RawResponse: resp.Response, SiteAuthSettingsV2: val}, nil
}

// getAuthSettingsV2HandleError handles the GetAuthSettingsV2 error response.
func (client *WebAppsClient) getAuthSettingsV2HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAuthSettingsV2Slot - Description for Gets site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettingsV2Slot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsV2SlotOptions) (SiteAuthSettingsV2Response, error) {
	req, err := client.getAuthSettingsV2SlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsV2Response{}, client.getAuthSettingsV2SlotHandleError(resp)
	}
	return client.getAuthSettingsV2SlotHandleResponse(resp)
}

// getAuthSettingsV2SlotCreateRequest creates the GetAuthSettingsV2Slot request.
func (client *WebAppsClient) getAuthSettingsV2SlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsV2SlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsV2SlotHandleResponse handles the GetAuthSettingsV2Slot response.
func (client *WebAppsClient) getAuthSettingsV2SlotHandleResponse(resp *azcore.Response) (SiteAuthSettingsV2Response, error) {
	var val *SiteAuthSettingsV2
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	return SiteAuthSettingsV2Response{RawResponse: resp.Response, SiteAuthSettingsV2: val}, nil
}

// getAuthSettingsV2SlotHandleError handles the GetAuthSettingsV2Slot error response.
func (client *WebAppsClient) getAuthSettingsV2SlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetBackupConfiguration - Description for Gets the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetBackupConfigurationOptions) (BackupRequestResponse, error) {
	req, err := client.getBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupRequestResponse{}, client.getBackupConfigurationHandleError(resp)
	}
	return client.getBackupConfigurationHandleResponse(resp)
}

// getBackupConfigurationCreateRequest creates the GetBackupConfiguration request.
func (client *WebAppsClient) getBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetBackupConfigurationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupConfigurationHandleResponse handles the GetBackupConfiguration response.
func (client *WebAppsClient) getBackupConfigurationHandleResponse(resp *azcore.Response) (BackupRequestResponse, error) {
	var val *BackupRequest
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupRequestResponse{}, err
	}
	return BackupRequestResponse{RawResponse: resp.Response, BackupRequest: val}, nil
}

// getBackupConfigurationHandleError handles the GetBackupConfiguration error response.
func (client *WebAppsClient) getBackupConfigurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetBackupConfigurationSlot - Description for Gets the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetBackupConfigurationSlotOptions) (BackupRequestResponse, error) {
	req, err := client.getBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupRequestResponse{}, client.getBackupConfigurationSlotHandleError(resp)
	}
	return client.getBackupConfigurationSlotHandleResponse(resp)
}

// getBackupConfigurationSlotCreateRequest creates the GetBackupConfigurationSlot request.
func (client *WebAppsClient) getBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetBackupConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupConfigurationSlotHandleResponse handles the GetBackupConfigurationSlot response.
func (client *WebAppsClient) getBackupConfigurationSlotHandleResponse(resp *azcore.Response) (BackupRequestResponse, error) {
	var val *BackupRequest
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupRequestResponse{}, err
	}
	return BackupRequestResponse{RawResponse: resp.Response, BackupRequest: val}, nil
}

// getBackupConfigurationSlotHandleError handles the GetBackupConfigurationSlot error response.
func (client *WebAppsClient) getBackupConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetBackupStatus - Description for Gets a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupStatus(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsGetBackupStatusOptions) (BackupItemResponse, error) {
	req, err := client.getBackupStatusCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return BackupItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupItemResponse{}, client.getBackupStatusHandleError(resp)
	}
	return client.getBackupStatusHandleResponse(resp)
}

// getBackupStatusCreateRequest creates the GetBackupStatus request.
func (client *WebAppsClient) getBackupStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsGetBackupStatusOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupStatusHandleResponse handles the GetBackupStatus response.
func (client *WebAppsClient) getBackupStatusHandleResponse(resp *azcore.Response) (BackupItemResponse, error) {
	var val *BackupItem
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemResponse{}, err
	}
	return BackupItemResponse{RawResponse: resp.Response, BackupItem: val}, nil
}

// getBackupStatusHandleError handles the GetBackupStatus error response.
func (client *WebAppsClient) getBackupStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetBackupStatusSlot - Description for Gets a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupStatusSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsGetBackupStatusSlotOptions) (BackupItemResponse, error) {
	req, err := client.getBackupStatusSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return BackupItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupItemResponse{}, client.getBackupStatusSlotHandleError(resp)
	}
	return client.getBackupStatusSlotHandleResponse(resp)
}

// getBackupStatusSlotCreateRequest creates the GetBackupStatusSlot request.
func (client *WebAppsClient) getBackupStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsGetBackupStatusSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupStatusSlotHandleResponse handles the GetBackupStatusSlot response.
func (client *WebAppsClient) getBackupStatusSlotHandleResponse(resp *azcore.Response) (BackupItemResponse, error) {
	var val *BackupItem
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemResponse{}, err
	}
	return BackupItemResponse{RawResponse: resp.Response, BackupItem: val}, nil
}

// getBackupStatusSlotHandleError handles the GetBackupStatusSlot error response.
func (client *WebAppsClient) getBackupStatusSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetConfiguration - Description for Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always
// On, etc.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetConfigurationOptions) (SiteConfigResourceResponse, error) {
	req, err := client.getConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.getConfigurationHandleError(resp)
	}
	return client.getConfigurationHandleResponse(resp)
}

// getConfigurationCreateRequest creates the GetConfiguration request.
func (client *WebAppsClient) getConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetConfigurationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationHandleResponse handles the GetConfiguration response.
func (client *WebAppsClient) getConfigurationHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// getConfigurationHandleError handles the GetConfiguration error response.
func (client *WebAppsClient) getConfigurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetConfigurationSlot - Description for Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications,
// Always On, etc.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetConfigurationSlotOptions) (SiteConfigResourceResponse, error) {
	req, err := client.getConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.getConfigurationSlotHandleError(resp)
	}
	return client.getConfigurationSlotHandleResponse(resp)
}

// getConfigurationSlotCreateRequest creates the GetConfigurationSlot request.
func (client *WebAppsClient) getConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationSlotHandleResponse handles the GetConfigurationSlot response.
func (client *WebAppsClient) getConfigurationSlotHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// getConfigurationSlotHandleError handles the GetConfigurationSlot error response.
func (client *WebAppsClient) getConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetConfigurationSnapshot - Description for Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsGetConfigurationSnapshotOptions) (SiteConfigResourceResponse, error) {
	req, err := client.getConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.getConfigurationSnapshotHandleError(resp)
	}
	return client.getConfigurationSnapshotHandleResponse(resp)
}

// getConfigurationSnapshotCreateRequest creates the GetConfigurationSnapshot request.
func (client *WebAppsClient) getConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsGetConfigurationSnapshotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationSnapshotHandleResponse handles the GetConfigurationSnapshot response.
func (client *WebAppsClient) getConfigurationSnapshotHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// getConfigurationSnapshotHandleError handles the GetConfigurationSnapshot error response.
func (client *WebAppsClient) getConfigurationSnapshotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetConfigurationSnapshotSlot - Description for Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsGetConfigurationSnapshotSlotOptions) (SiteConfigResourceResponse, error) {
	req, err := client.getConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.getConfigurationSnapshotSlotHandleError(resp)
	}
	return client.getConfigurationSnapshotSlotHandleResponse(resp)
}

// getConfigurationSnapshotSlotCreateRequest creates the GetConfigurationSnapshotSlot request.
func (client *WebAppsClient) getConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsGetConfigurationSnapshotSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationSnapshotSlotHandleResponse handles the GetConfigurationSnapshotSlot response.
func (client *WebAppsClient) getConfigurationSnapshotSlotHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// getConfigurationSnapshotSlotHandleError handles the GetConfigurationSnapshotSlot error response.
func (client *WebAppsClient) getConfigurationSnapshotSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetContainerLogsZip - Description for Gets the ZIP archived docker log files for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetContainerLogsZip(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetContainerLogsZipOptions) (*http.Response, error) {
	req, err := client.getContainerLogsZipCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.getContainerLogsZipHandleError(resp)
	}
	return resp.Response, nil
}

// getContainerLogsZipCreateRequest creates the GetContainerLogsZip request.
func (client *WebAppsClient) getContainerLogsZipCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetContainerLogsZipOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/zip")
	return req, nil
}

// getContainerLogsZipHandleError handles the GetContainerLogsZip error response.
func (client *WebAppsClient) getContainerLogsZipHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetContainerLogsZipSlot - Description for Gets the ZIP archived docker log files for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetContainerLogsZipSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetContainerLogsZipSlotOptions) (*http.Response, error) {
	req, err := client.getContainerLogsZipSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.getContainerLogsZipSlotHandleError(resp)
	}
	return resp.Response, nil
}

// getContainerLogsZipSlotCreateRequest creates the GetContainerLogsZipSlot request.
func (client *WebAppsClient) getContainerLogsZipSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetContainerLogsZipSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/zip")
	return req, nil
}

// getContainerLogsZipSlotHandleError handles the GetContainerLogsZipSlot error response.
func (client *WebAppsClient) getContainerLogsZipSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetContinuousWebJob - Description for Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetContinuousWebJobOptions) (ContinuousWebJobResponse, error) {
	req, err := client.getContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return ContinuousWebJobResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ContinuousWebJobResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ContinuousWebJobResponse{}, client.getContinuousWebJobHandleError(resp)
	}
	return client.getContinuousWebJobHandleResponse(resp)
}

// getContinuousWebJobCreateRequest creates the GetContinuousWebJob request.
func (client *WebAppsClient) getContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetContinuousWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getContinuousWebJobHandleResponse handles the GetContinuousWebJob response.
func (client *WebAppsClient) getContinuousWebJobHandleResponse(resp *azcore.Response) (ContinuousWebJobResponse, error) {
	var val *ContinuousWebJob
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ContinuousWebJobResponse{}, err
	}
	return ContinuousWebJobResponse{RawResponse: resp.Response, ContinuousWebJob: val}, nil
}

// getContinuousWebJobHandleError handles the GetContinuousWebJob error response.
func (client *WebAppsClient) getContinuousWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetContinuousWebJobSlot - Description for Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetContinuousWebJobSlotOptions) (ContinuousWebJobResponse, error) {
	req, err := client.getContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return ContinuousWebJobResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ContinuousWebJobResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ContinuousWebJobResponse{}, client.getContinuousWebJobSlotHandleError(resp)
	}
	return client.getContinuousWebJobSlotHandleResponse(resp)
}

// getContinuousWebJobSlotCreateRequest creates the GetContinuousWebJobSlot request.
func (client *WebAppsClient) getContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetContinuousWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getContinuousWebJobSlotHandleResponse handles the GetContinuousWebJobSlot response.
func (client *WebAppsClient) getContinuousWebJobSlotHandleResponse(resp *azcore.Response) (ContinuousWebJobResponse, error) {
	var val *ContinuousWebJob
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ContinuousWebJobResponse{}, err
	}
	return ContinuousWebJobResponse{RawResponse: resp.Response, ContinuousWebJob: val}, nil
}

// getContinuousWebJobSlotHandleError handles the GetContinuousWebJobSlot error response.
func (client *WebAppsClient) getContinuousWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetDeployment - Description for Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsGetDeploymentOptions) (DeploymentResponse, error) {
	req, err := client.getDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return DeploymentResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentResponse{}, client.getDeploymentHandleError(resp)
	}
	return client.getDeploymentHandleResponse(resp)
}

// getDeploymentCreateRequest creates the GetDeployment request.
func (client *WebAppsClient) getDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsGetDeploymentOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeploymentHandleResponse handles the GetDeployment response.
func (client *WebAppsClient) getDeploymentHandleResponse(resp *azcore.Response) (DeploymentResponse, error) {
	var val *Deployment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentResponse{}, err
	}
	return DeploymentResponse{RawResponse: resp.Response, Deployment: val}, nil
}

// getDeploymentHandleError handles the GetDeployment error response.
func (client *WebAppsClient) getDeploymentHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeploymentSlot - Description for Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsGetDeploymentSlotOptions) (DeploymentResponse, error) {
	req, err := client.getDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return DeploymentResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentResponse{}, client.getDeploymentSlotHandleError(resp)
	}
	return client.getDeploymentSlotHandleResponse(resp)
}

// getDeploymentSlotCreateRequest creates the GetDeploymentSlot request.
func (client *WebAppsClient) getDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsGetDeploymentSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeploymentSlotHandleResponse handles the GetDeploymentSlot response.
func (client *WebAppsClient) getDeploymentSlotHandleResponse(resp *azcore.Response) (DeploymentResponse, error) {
	var val *Deployment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentResponse{}, err
	}
	return DeploymentResponse{RawResponse: resp.Response, Deployment: val}, nil
}

// getDeploymentSlotHandleError handles the GetDeploymentSlot error response.
func (client *WebAppsClient) getDeploymentSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDiagnosticLogsConfiguration - Description for Gets the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDiagnosticLogsConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetDiagnosticLogsConfigurationOptions) (SiteLogsConfigResponse, error) {
	req, err := client.getDiagnosticLogsConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteLogsConfigResponse{}, client.getDiagnosticLogsConfigurationHandleError(resp)
	}
	return client.getDiagnosticLogsConfigurationHandleResponse(resp)
}

// getDiagnosticLogsConfigurationCreateRequest creates the GetDiagnosticLogsConfiguration request.
func (client *WebAppsClient) getDiagnosticLogsConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetDiagnosticLogsConfigurationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDiagnosticLogsConfigurationHandleResponse handles the GetDiagnosticLogsConfiguration response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationHandleResponse(resp *azcore.Response) (SiteLogsConfigResponse, error) {
	var val *SiteLogsConfig
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteLogsConfigResponse{}, err
	}
	return SiteLogsConfigResponse{RawResponse: resp.Response, SiteLogsConfig: val}, nil
}

// getDiagnosticLogsConfigurationHandleError handles the GetDiagnosticLogsConfiguration error response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDiagnosticLogsConfigurationSlot - Description for Gets the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDiagnosticLogsConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetDiagnosticLogsConfigurationSlotOptions) (SiteLogsConfigResponse, error) {
	req, err := client.getDiagnosticLogsConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteLogsConfigResponse{}, client.getDiagnosticLogsConfigurationSlotHandleError(resp)
	}
	return client.getDiagnosticLogsConfigurationSlotHandleResponse(resp)
}

// getDiagnosticLogsConfigurationSlotCreateRequest creates the GetDiagnosticLogsConfigurationSlot request.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetDiagnosticLogsConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDiagnosticLogsConfigurationSlotHandleResponse handles the GetDiagnosticLogsConfigurationSlot response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotHandleResponse(resp *azcore.Response) (SiteLogsConfigResponse, error) {
	var val *SiteLogsConfig
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteLogsConfigResponse{}, err
	}
	return SiteLogsConfigResponse{RawResponse: resp.Response, SiteLogsConfig: val}, nil
}

// getDiagnosticLogsConfigurationSlotHandleError handles the GetDiagnosticLogsConfigurationSlot error response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDomainOwnershipIdentifier - Description for Get domain ownership identifier for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsGetDomainOwnershipIdentifierOptions) (IdentifierResponse, error) {
	req, err := client.getDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return IdentifierResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IdentifierResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IdentifierResponse{}, client.getDomainOwnershipIdentifierHandleError(resp)
	}
	return client.getDomainOwnershipIdentifierHandleResponse(resp)
}

// getDomainOwnershipIdentifierCreateRequest creates the GetDomainOwnershipIdentifier request.
func (client *WebAppsClient) getDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsGetDomainOwnershipIdentifierOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDomainOwnershipIdentifierHandleResponse handles the GetDomainOwnershipIdentifier response.
func (client *WebAppsClient) getDomainOwnershipIdentifierHandleResponse(resp *azcore.Response) (IdentifierResponse, error) {
	var val *Identifier
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierResponse{}, err
	}
	return IdentifierResponse{RawResponse: resp.Response, Identifier: val}, nil
}

// getDomainOwnershipIdentifierHandleError handles the GetDomainOwnershipIdentifier error response.
func (client *WebAppsClient) getDomainOwnershipIdentifierHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDomainOwnershipIdentifierSlot - Description for Get domain ownership identifier for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsGetDomainOwnershipIdentifierSlotOptions) (IdentifierResponse, error) {
	req, err := client.getDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return IdentifierResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IdentifierResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IdentifierResponse{}, client.getDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return client.getDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// getDomainOwnershipIdentifierSlotCreateRequest creates the GetDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsGetDomainOwnershipIdentifierSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDomainOwnershipIdentifierSlotHandleResponse handles the GetDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotHandleResponse(resp *azcore.Response) (IdentifierResponse, error) {
	var val *Identifier
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierResponse{}, err
	}
	return IdentifierResponse{RawResponse: resp.Response, Identifier: val}, nil
}

// getDomainOwnershipIdentifierSlotHandleError handles the GetDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetFtpAllowed - Description for Returns whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFtpAllowed(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFtpAllowedOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.getFtpAllowedCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.getFtpAllowedHandleError(resp)
	}
	return client.getFtpAllowedHandleResponse(resp)
}

// getFtpAllowedCreateRequest creates the GetFtpAllowed request.
func (client *WebAppsClient) getFtpAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFtpAllowedOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getFtpAllowedHandleResponse handles the GetFtpAllowed response.
func (client *WebAppsClient) getFtpAllowedHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// getFtpAllowedHandleError handles the GetFtpAllowed error response.
func (client *WebAppsClient) getFtpAllowedHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetFtpAllowedSlot - Description for Returns whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFtpAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFtpAllowedSlotOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.getFtpAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.getFtpAllowedSlotHandleError(resp)
	}
	return client.getFtpAllowedSlotHandleResponse(resp)
}

// getFtpAllowedSlotCreateRequest creates the GetFtpAllowedSlot request.
func (client *WebAppsClient) getFtpAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFtpAllowedSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getFtpAllowedSlotHandleResponse handles the GetFtpAllowedSlot response.
func (client *WebAppsClient) getFtpAllowedSlotHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// getFtpAllowedSlotHandleError handles the GetFtpAllowedSlot error response.
func (client *WebAppsClient) getFtpAllowedSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetFunction - Description for Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsGetFunctionOptions) (FunctionEnvelopeResponse, error) {
	req, err := client.getFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return FunctionEnvelopeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FunctionEnvelopeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FunctionEnvelopeResponse{}, client.getFunctionHandleError(resp)
	}
	return client.getFunctionHandleResponse(resp)
}

// getFunctionCreateRequest creates the GetFunction request.
func (client *WebAppsClient) getFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsGetFunctionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getFunctionHandleResponse handles the GetFunction response.
func (client *WebAppsClient) getFunctionHandleResponse(resp *azcore.Response) (FunctionEnvelopeResponse, error) {
	var val *FunctionEnvelope
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionEnvelopeResponse{}, err
	}
	return FunctionEnvelopeResponse{RawResponse: resp.Response, FunctionEnvelope: val}, nil
}

// getFunctionHandleError handles the GetFunction error response.
func (client *WebAppsClient) getFunctionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetFunctionsAdminToken - Description for Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFunctionsAdminToken(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFunctionsAdminTokenOptions) (StringResponse, error) {
	req, err := client.getFunctionsAdminTokenCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StringResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringResponse{}, client.getFunctionsAdminTokenHandleError(resp)
	}
	return client.getFunctionsAdminTokenHandleResponse(resp)
}

// getFunctionsAdminTokenCreateRequest creates the GetFunctionsAdminToken request.
func (client *WebAppsClient) getFunctionsAdminTokenCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFunctionsAdminTokenOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getFunctionsAdminTokenHandleResponse handles the GetFunctionsAdminToken response.
func (client *WebAppsClient) getFunctionsAdminTokenHandleResponse(resp *azcore.Response) (StringResponse, error) {
	var val *string
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringResponse{}, err
	}
	return StringResponse{RawResponse: resp.Response, Value: val}, nil
}

// getFunctionsAdminTokenHandleError handles the GetFunctionsAdminToken error response.
func (client *WebAppsClient) getFunctionsAdminTokenHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetFunctionsAdminTokenSlot - Description for Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFunctionsAdminTokenSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFunctionsAdminTokenSlotOptions) (StringResponse, error) {
	req, err := client.getFunctionsAdminTokenSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return StringResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringResponse{}, client.getFunctionsAdminTokenSlotHandleError(resp)
	}
	return client.getFunctionsAdminTokenSlotHandleResponse(resp)
}

// getFunctionsAdminTokenSlotCreateRequest creates the GetFunctionsAdminTokenSlot request.
func (client *WebAppsClient) getFunctionsAdminTokenSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFunctionsAdminTokenSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getFunctionsAdminTokenSlotHandleResponse handles the GetFunctionsAdminTokenSlot response.
func (client *WebAppsClient) getFunctionsAdminTokenSlotHandleResponse(resp *azcore.Response) (StringResponse, error) {
	var val *string
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringResponse{}, err
	}
	return StringResponse{RawResponse: resp.Response, Value: val}, nil
}

// getFunctionsAdminTokenSlotHandleError handles the GetFunctionsAdminTokenSlot error response.
func (client *WebAppsClient) getFunctionsAdminTokenSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetHostNameBinding - Description for Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsGetHostNameBindingOptions) (HostNameBindingResponse, error) {
	req, err := client.getHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HostNameBindingResponse{}, client.getHostNameBindingHandleError(resp)
	}
	return client.getHostNameBindingHandleResponse(resp)
}

// getHostNameBindingCreateRequest creates the GetHostNameBinding request.
func (client *WebAppsClient) getHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsGetHostNameBindingOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHostNameBindingHandleResponse handles the GetHostNameBinding response.
func (client *WebAppsClient) getHostNameBindingHandleResponse(resp *azcore.Response) (HostNameBindingResponse, error) {
	var val *HostNameBinding
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostNameBindingResponse{}, err
	}
	return HostNameBindingResponse{RawResponse: resp.Response, HostNameBinding: val}, nil
}

// getHostNameBindingHandleError handles the GetHostNameBinding error response.
func (client *WebAppsClient) getHostNameBindingHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetHostNameBindingSlot - Description for Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsGetHostNameBindingSlotOptions) (HostNameBindingResponse, error) {
	req, err := client.getHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HostNameBindingResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HostNameBindingResponse{}, client.getHostNameBindingSlotHandleError(resp)
	}
	return client.getHostNameBindingSlotHandleResponse(resp)
}

// getHostNameBindingSlotCreateRequest creates the GetHostNameBindingSlot request.
func (client *WebAppsClient) getHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsGetHostNameBindingSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHostNameBindingSlotHandleResponse handles the GetHostNameBindingSlot response.
func (client *WebAppsClient) getHostNameBindingSlotHandleResponse(resp *azcore.Response) (HostNameBindingResponse, error) {
	var val *HostNameBinding
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostNameBindingResponse{}, err
	}
	return HostNameBindingResponse{RawResponse: resp.Response, HostNameBinding: val}, nil
}

// getHostNameBindingSlotHandleError handles the GetHostNameBindingSlot error response.
func (client *WebAppsClient) getHostNameBindingSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetHybridConnection - Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsGetHybridConnectionOptions) (HybridConnectionResponse, error) {
	req, err := client.getHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.getHybridConnectionHandleError(resp)
	}
	return client.getHybridConnectionHandleResponse(resp)
}

// getHybridConnectionCreateRequest creates the GetHybridConnection request.
func (client *WebAppsClient) getHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsGetHybridConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHybridConnectionHandleResponse handles the GetHybridConnection response.
func (client *WebAppsClient) getHybridConnectionHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// getHybridConnectionHandleError handles the GetHybridConnection error response.
func (client *WebAppsClient) getHybridConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetHybridConnectionSlot - Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsGetHybridConnectionSlotOptions) (HybridConnectionResponse, error) {
	req, err := client.getHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.getHybridConnectionSlotHandleError(resp)
	}
	return client.getHybridConnectionSlotHandleResponse(resp)
}

// getHybridConnectionSlotCreateRequest creates the GetHybridConnectionSlot request.
func (client *WebAppsClient) getHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsGetHybridConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHybridConnectionSlotHandleResponse handles the GetHybridConnectionSlot response.
func (client *WebAppsClient) getHybridConnectionSlotHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// getHybridConnectionSlotHandleError handles the GetHybridConnectionSlot error response.
func (client *WebAppsClient) getHybridConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetInstanceFunctionSlot - Description for Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsGetInstanceFunctionSlotOptions) (FunctionEnvelopeResponse, error) {
	req, err := client.getInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return FunctionEnvelopeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FunctionEnvelopeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FunctionEnvelopeResponse{}, client.getInstanceFunctionSlotHandleError(resp)
	}
	return client.getInstanceFunctionSlotHandleResponse(resp)
}

// getInstanceFunctionSlotCreateRequest creates the GetInstanceFunctionSlot request.
func (client *WebAppsClient) getInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsGetInstanceFunctionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceFunctionSlotHandleResponse handles the GetInstanceFunctionSlot response.
func (client *WebAppsClient) getInstanceFunctionSlotHandleResponse(resp *azcore.Response) (FunctionEnvelopeResponse, error) {
	var val *FunctionEnvelope
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionEnvelopeResponse{}, err
	}
	return FunctionEnvelopeResponse{RawResponse: resp.Response, FunctionEnvelope: val}, nil
}

// getInstanceFunctionSlotHandleError handles the GetInstanceFunctionSlot error response.
func (client *WebAppsClient) getInstanceFunctionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceInfo - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceInfo(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceInfoOptions) (WebSiteInstanceStatusResponse, error) {
	req, err := client.getInstanceInfoCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return WebSiteInstanceStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WebSiteInstanceStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WebSiteInstanceStatusResponse{}, client.getInstanceInfoHandleError(resp)
	}
	return client.getInstanceInfoHandleResponse(resp)
}

// getInstanceInfoCreateRequest creates the GetInstanceInfo request.
func (client *WebAppsClient) getInstanceInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceInfoOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceInfoHandleResponse handles the GetInstanceInfo response.
func (client *WebAppsClient) getInstanceInfoHandleResponse(resp *azcore.Response) (WebSiteInstanceStatusResponse, error) {
	var val *WebSiteInstanceStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebSiteInstanceStatusResponse{}, err
	}
	return WebSiteInstanceStatusResponse{RawResponse: resp.Response, WebSiteInstanceStatus: val}, nil
}

// getInstanceInfoHandleError handles the GetInstanceInfo error response.
func (client *WebAppsClient) getInstanceInfoHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetInstanceInfoSlot - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceInfoSlot(ctx context.Context, resourceGroupName string, name string, instanceID string, slot string, options *WebAppsGetInstanceInfoSlotOptions) (WebSiteInstanceStatusResponse, error) {
	req, err := client.getInstanceInfoSlotCreateRequest(ctx, resourceGroupName, name, instanceID, slot, options)
	if err != nil {
		return WebSiteInstanceStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WebSiteInstanceStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WebSiteInstanceStatusResponse{}, client.getInstanceInfoSlotHandleError(resp)
	}
	return client.getInstanceInfoSlotHandleResponse(resp)
}

// getInstanceInfoSlotCreateRequest creates the GetInstanceInfoSlot request.
func (client *WebAppsClient) getInstanceInfoSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, slot string, options *WebAppsGetInstanceInfoSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceInfoSlotHandleResponse handles the GetInstanceInfoSlot response.
func (client *WebAppsClient) getInstanceInfoSlotHandleResponse(resp *azcore.Response) (WebSiteInstanceStatusResponse, error) {
	var val *WebSiteInstanceStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebSiteInstanceStatusResponse{}, err
	}
	return WebSiteInstanceStatusResponse{RawResponse: resp.Response, WebSiteInstanceStatus: val}, nil
}

// getInstanceInfoSlotHandleError handles the GetInstanceInfoSlot error response.
func (client *WebAppsClient) getInstanceInfoSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetInstanceMSDeployLog - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMSDeployLog(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMSDeployLogOptions) (MSDeployLogResponse, error) {
	req, err := client.getInstanceMSDeployLogCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployLogResponse{}, client.getInstanceMSDeployLogHandleError(resp)
	}
	return client.getInstanceMSDeployLogHandleResponse(resp)
}

// getInstanceMSDeployLogCreateRequest creates the GetInstanceMSDeployLog request.
func (client *WebAppsClient) getInstanceMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMSDeployLogOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMSDeployLogHandleResponse handles the GetInstanceMSDeployLog response.
func (client *WebAppsClient) getInstanceMSDeployLogHandleResponse(resp *azcore.Response) (MSDeployLogResponse, error) {
	var val *MSDeployLog
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployLogResponse{}, err
	}
	return MSDeployLogResponse{RawResponse: resp.Response, MSDeployLog: val}, nil
}

// getInstanceMSDeployLogHandleError handles the GetInstanceMSDeployLog error response.
func (client *WebAppsClient) getInstanceMSDeployLogHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceMSDeployLogSlot - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMSDeployLogSlotOptions) (MSDeployLogResponse, error) {
	req, err := client.getInstanceMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployLogResponse{}, client.getInstanceMSDeployLogSlotHandleError(resp)
	}
	return client.getInstanceMSDeployLogSlotHandleResponse(resp)
}

// getInstanceMSDeployLogSlotCreateRequest creates the GetInstanceMSDeployLogSlot request.
func (client *WebAppsClient) getInstanceMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMSDeployLogSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMSDeployLogSlotHandleResponse handles the GetInstanceMSDeployLogSlot response.
func (client *WebAppsClient) getInstanceMSDeployLogSlotHandleResponse(resp *azcore.Response) (MSDeployLogResponse, error) {
	var val *MSDeployLog
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployLogResponse{}, err
	}
	return MSDeployLogResponse{RawResponse: resp.Response, MSDeployLog: val}, nil
}

// getInstanceMSDeployLogSlotHandleError handles the GetInstanceMSDeployLogSlot error response.
func (client *WebAppsClient) getInstanceMSDeployLogSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceMsDeployStatus - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMsDeployStatus(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMsDeployStatusOptions) (MSDeployStatusResponse, error) {
	req, err := client.getInstanceMsDeployStatusCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployStatusResponse{}, client.getInstanceMsDeployStatusHandleError(resp)
	}
	return client.getInstanceMsDeployStatusHandleResponse(resp)
}

// getInstanceMsDeployStatusCreateRequest creates the GetInstanceMsDeployStatus request.
func (client *WebAppsClient) getInstanceMsDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMsDeployStatusOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMsDeployStatusHandleResponse handles the GetInstanceMsDeployStatus response.
func (client *WebAppsClient) getInstanceMsDeployStatusHandleResponse(resp *azcore.Response) (MSDeployStatusResponse, error) {
	var val *MSDeployStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployStatusResponse{}, err
	}
	return MSDeployStatusResponse{RawResponse: resp.Response, MSDeployStatus: val}, nil
}

// getInstanceMsDeployStatusHandleError handles the GetInstanceMsDeployStatus error response.
func (client *WebAppsClient) getInstanceMsDeployStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetInstanceMsDeployStatusSlot - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMsDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMsDeployStatusSlotOptions) (MSDeployStatusResponse, error) {
	req, err := client.getInstanceMsDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployStatusResponse{}, client.getInstanceMsDeployStatusSlotHandleError(resp)
	}
	return client.getInstanceMsDeployStatusSlotHandleResponse(resp)
}

// getInstanceMsDeployStatusSlotCreateRequest creates the GetInstanceMsDeployStatusSlot request.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMsDeployStatusSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMsDeployStatusSlotHandleResponse handles the GetInstanceMsDeployStatusSlot response.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotHandleResponse(resp *azcore.Response) (MSDeployStatusResponse, error) {
	var val *MSDeployStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployStatusResponse{}, err
	}
	return MSDeployStatusResponse{RawResponse: resp.Response, MSDeployStatus: val}, nil
}

// getInstanceMsDeployStatusSlotHandleError handles the GetInstanceMsDeployStatusSlot error response.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetInstanceProcess - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessOptions) (ProcessInfoResponse, error) {
	req, err := client.getInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessInfoResponse{}, client.getInstanceProcessHandleError(resp)
	}
	return client.getInstanceProcessHandleResponse(resp)
}

// getInstanceProcessCreateRequest creates the GetInstanceProcess request.
func (client *WebAppsClient) getInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessHandleResponse handles the GetInstanceProcess response.
func (client *WebAppsClient) getInstanceProcessHandleResponse(resp *azcore.Response) (ProcessInfoResponse, error) {
	var val *ProcessInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoResponse{}, err
	}
	return ProcessInfoResponse{RawResponse: resp.Response, ProcessInfo: val}, nil
}

// getInstanceProcessHandleError handles the GetInstanceProcess error response.
func (client *WebAppsClient) getInstanceProcessHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceProcessDump - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessDumpOptions) (*http.Response, error) {
	req, err := client.getInstanceProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getInstanceProcessDumpHandleError(resp)
	}
	return resp.Response, nil
}

// getInstanceProcessDumpCreateRequest creates the GetInstanceProcessDump request.
func (client *WebAppsClient) getInstanceProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessDumpOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessDumpHandleError handles the GetInstanceProcessDump error response.
func (client *WebAppsClient) getInstanceProcessDumpHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceProcessDumpSlot - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessDumpSlotOptions) (*http.Response, error) {
	req, err := client.getInstanceProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getInstanceProcessDumpSlotHandleError(resp)
	}
	return resp.Response, nil
}

// getInstanceProcessDumpSlotCreateRequest creates the GetInstanceProcessDumpSlot request.
func (client *WebAppsClient) getInstanceProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessDumpSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessDumpSlotHandleError handles the GetInstanceProcessDumpSlot error response.
func (client *WebAppsClient) getInstanceProcessDumpSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceProcessModule - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *WebAppsGetInstanceProcessModuleOptions) (ProcessModuleInfoResponse, error) {
	req, err := client.getInstanceProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, instanceID, options)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessModuleInfoResponse{}, client.getInstanceProcessModuleHandleError(resp)
	}
	return client.getInstanceProcessModuleHandleResponse(resp)
}

// getInstanceProcessModuleCreateRequest creates the GetInstanceProcessModule request.
func (client *WebAppsClient) getInstanceProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *WebAppsGetInstanceProcessModuleOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessModuleHandleResponse handles the GetInstanceProcessModule response.
func (client *WebAppsClient) getInstanceProcessModuleHandleResponse(resp *azcore.Response) (ProcessModuleInfoResponse, error) {
	var val *ProcessModuleInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	return ProcessModuleInfoResponse{RawResponse: resp.Response, ProcessModuleInfo: val}, nil
}

// getInstanceProcessModuleHandleError handles the GetInstanceProcessModule error response.
func (client *WebAppsClient) getInstanceProcessModuleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceProcessModuleSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *WebAppsGetInstanceProcessModuleSlotOptions) (ProcessModuleInfoResponse, error) {
	req, err := client.getInstanceProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, instanceID, options)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessModuleInfoResponse{}, client.getInstanceProcessModuleSlotHandleError(resp)
	}
	return client.getInstanceProcessModuleSlotHandleResponse(resp)
}

// getInstanceProcessModuleSlotCreateRequest creates the GetInstanceProcessModuleSlot request.
func (client *WebAppsClient) getInstanceProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *WebAppsGetInstanceProcessModuleSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessModuleSlotHandleResponse handles the GetInstanceProcessModuleSlot response.
func (client *WebAppsClient) getInstanceProcessModuleSlotHandleResponse(resp *azcore.Response) (ProcessModuleInfoResponse, error) {
	var val *ProcessModuleInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	return ProcessModuleInfoResponse{RawResponse: resp.Response, ProcessModuleInfo: val}, nil
}

// getInstanceProcessModuleSlotHandleError handles the GetInstanceProcessModuleSlot error response.
func (client *WebAppsClient) getInstanceProcessModuleSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetInstanceProcessSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessSlotOptions) (ProcessInfoResponse, error) {
	req, err := client.getInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessInfoResponse{}, client.getInstanceProcessSlotHandleError(resp)
	}
	return client.getInstanceProcessSlotHandleResponse(resp)
}

// getInstanceProcessSlotCreateRequest creates the GetInstanceProcessSlot request.
func (client *WebAppsClient) getInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessSlotHandleResponse handles the GetInstanceProcessSlot response.
func (client *WebAppsClient) getInstanceProcessSlotHandleResponse(resp *azcore.Response) (ProcessInfoResponse, error) {
	var val *ProcessInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoResponse{}, err
	}
	return ProcessInfoResponse{RawResponse: resp.Response, ProcessInfo: val}, nil
}

// getInstanceProcessSlotHandleError handles the GetInstanceProcessSlot error response.
func (client *WebAppsClient) getInstanceProcessSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetMSDeployLog - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployLog(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployLogOptions) (MSDeployLogResponse, error) {
	req, err := client.getMSDeployLogCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployLogResponse{}, client.getMSDeployLogHandleError(resp)
	}
	return client.getMSDeployLogHandleResponse(resp)
}

// getMSDeployLogCreateRequest creates the GetMSDeployLog request.
func (client *WebAppsClient) getMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployLogOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployLogHandleResponse handles the GetMSDeployLog response.
func (client *WebAppsClient) getMSDeployLogHandleResponse(resp *azcore.Response) (MSDeployLogResponse, error) {
	var val *MSDeployLog
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployLogResponse{}, err
	}
	return MSDeployLogResponse{RawResponse: resp.Response, MSDeployLog: val}, nil
}

// getMSDeployLogHandleError handles the GetMSDeployLog error response.
func (client *WebAppsClient) getMSDeployLogHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetMSDeployLogSlot - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployLogSlotOptions) (MSDeployLogResponse, error) {
	req, err := client.getMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployLogResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployLogResponse{}, client.getMSDeployLogSlotHandleError(resp)
	}
	return client.getMSDeployLogSlotHandleResponse(resp)
}

// getMSDeployLogSlotCreateRequest creates the GetMSDeployLogSlot request.
func (client *WebAppsClient) getMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployLogSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployLogSlotHandleResponse handles the GetMSDeployLogSlot response.
func (client *WebAppsClient) getMSDeployLogSlotHandleResponse(resp *azcore.Response) (MSDeployLogResponse, error) {
	var val *MSDeployLog
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployLogResponse{}, err
	}
	return MSDeployLogResponse{RawResponse: resp.Response, MSDeployLog: val}, nil
}

// getMSDeployLogSlotHandleError handles the GetMSDeployLogSlot error response.
func (client *WebAppsClient) getMSDeployLogSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetMSDeployStatus - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployStatusOptions) (MSDeployStatusResponse, error) {
	req, err := client.getMSDeployStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployStatusResponse{}, client.getMSDeployStatusHandleError(resp)
	}
	return client.getMSDeployStatusHandleResponse(resp)
}

// getMSDeployStatusCreateRequest creates the GetMSDeployStatus request.
func (client *WebAppsClient) getMSDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployStatusOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployStatusHandleResponse handles the GetMSDeployStatus response.
func (client *WebAppsClient) getMSDeployStatusHandleResponse(resp *azcore.Response) (MSDeployStatusResponse, error) {
	var val *MSDeployStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployStatusResponse{}, err
	}
	return MSDeployStatusResponse{RawResponse: resp.Response, MSDeployStatus: val}, nil
}

// getMSDeployStatusHandleError handles the GetMSDeployStatus error response.
func (client *WebAppsClient) getMSDeployStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMSDeployStatusSlot - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployStatusSlotOptions) (MSDeployStatusResponse, error) {
	req, err := client.getMSDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MSDeployStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MSDeployStatusResponse{}, client.getMSDeployStatusSlotHandleError(resp)
	}
	return client.getMSDeployStatusSlotHandleResponse(resp)
}

// getMSDeployStatusSlotCreateRequest creates the GetMSDeployStatusSlot request.
func (client *WebAppsClient) getMSDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployStatusSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployStatusSlotHandleResponse handles the GetMSDeployStatusSlot response.
func (client *WebAppsClient) getMSDeployStatusSlotHandleResponse(resp *azcore.Response) (MSDeployStatusResponse, error) {
	var val *MSDeployStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MSDeployStatusResponse{}, err
	}
	return MSDeployStatusResponse{RawResponse: resp.Response, MSDeployStatus: val}, nil
}

// getMSDeployStatusSlotHandleError handles the GetMSDeployStatusSlot error response.
func (client *WebAppsClient) getMSDeployStatusSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMigrateMySQLStatus - Description for Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMigrateMySQLStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMigrateMySQLStatusOptions) (MigrateMySQLStatusResponse, error) {
	req, err := client.getMigrateMySQLStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return MigrateMySQLStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MigrateMySQLStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MigrateMySQLStatusResponse{}, client.getMigrateMySQLStatusHandleError(resp)
	}
	return client.getMigrateMySQLStatusHandleResponse(resp)
}

// getMigrateMySQLStatusCreateRequest creates the GetMigrateMySQLStatus request.
func (client *WebAppsClient) getMigrateMySQLStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMigrateMySQLStatusOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMigrateMySQLStatusHandleResponse handles the GetMigrateMySQLStatus response.
func (client *WebAppsClient) getMigrateMySQLStatusHandleResponse(resp *azcore.Response) (MigrateMySQLStatusResponse, error) {
	var val *MigrateMySQLStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MigrateMySQLStatusResponse{}, err
	}
	return MigrateMySQLStatusResponse{RawResponse: resp.Response, MigrateMySQLStatus: val}, nil
}

// getMigrateMySQLStatusHandleError handles the GetMigrateMySQLStatus error response.
func (client *WebAppsClient) getMigrateMySQLStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMigrateMySQLStatusSlot - Description for Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMigrateMySQLStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMigrateMySQLStatusSlotOptions) (MigrateMySQLStatusResponse, error) {
	req, err := client.getMigrateMySQLStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return MigrateMySQLStatusResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MigrateMySQLStatusResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MigrateMySQLStatusResponse{}, client.getMigrateMySQLStatusSlotHandleError(resp)
	}
	return client.getMigrateMySQLStatusSlotHandleResponse(resp)
}

// getMigrateMySQLStatusSlotCreateRequest creates the GetMigrateMySQLStatusSlot request.
func (client *WebAppsClient) getMigrateMySQLStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMigrateMySQLStatusSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMigrateMySQLStatusSlotHandleResponse handles the GetMigrateMySQLStatusSlot response.
func (client *WebAppsClient) getMigrateMySQLStatusSlotHandleResponse(resp *azcore.Response) (MigrateMySQLStatusResponse, error) {
	var val *MigrateMySQLStatus
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MigrateMySQLStatusResponse{}, err
	}
	return MigrateMySQLStatusResponse{RawResponse: resp.Response, MigrateMySQLStatus: val}, nil
}

// getMigrateMySQLStatusSlotHandleError handles the GetMigrateMySQLStatusSlot error response.
func (client *WebAppsClient) getMigrateMySQLStatusSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTraceOperation - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationOptions) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return NetworkTraceArrayResponse{}, client.getNetworkTraceOperationHandleError(resp)
	}
	return client.getNetworkTraceOperationHandleResponse(resp)
}

// getNetworkTraceOperationCreateRequest creates the GetNetworkTraceOperation request.
func (client *WebAppsClient) getNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationHandleResponse handles the GetNetworkTraceOperation response.
func (client *WebAppsClient) getNetworkTraceOperationHandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTraceOperationHandleError handles the GetNetworkTraceOperation error response.
func (client *WebAppsClient) getNetworkTraceOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTraceOperationSlot - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotOptions) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return NetworkTraceArrayResponse{}, client.getNetworkTraceOperationSlotHandleError(resp)
	}
	return client.getNetworkTraceOperationSlotHandleResponse(resp)
}

// getNetworkTraceOperationSlotCreateRequest creates the GetNetworkTraceOperationSlot request.
func (client *WebAppsClient) getNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationSlotHandleResponse handles the GetNetworkTraceOperationSlot response.
func (client *WebAppsClient) getNetworkTraceOperationSlotHandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTraceOperationSlotHandleError handles the GetNetworkTraceOperationSlot error response.
func (client *WebAppsClient) getNetworkTraceOperationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTraceOperationSlotV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperationSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotV2Options) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTraceOperationSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return NetworkTraceArrayResponse{}, client.getNetworkTraceOperationSlotV2HandleError(resp)
	}
	return client.getNetworkTraceOperationSlotV2HandleResponse(resp)
}

// getNetworkTraceOperationSlotV2CreateRequest creates the GetNetworkTraceOperationSlotV2 request.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotV2Options) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationSlotV2HandleResponse handles the GetNetworkTraceOperationSlotV2 response.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2HandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTraceOperationSlotV2HandleError handles the GetNetworkTraceOperationSlotV2 error response.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTraceOperationV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperationV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationV2Options) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTraceOperationV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return NetworkTraceArrayResponse{}, client.getNetworkTraceOperationV2HandleError(resp)
	}
	return client.getNetworkTraceOperationV2HandleResponse(resp)
}

// getNetworkTraceOperationV2CreateRequest creates the GetNetworkTraceOperationV2 request.
func (client *WebAppsClient) getNetworkTraceOperationV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationV2Options) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationV2HandleResponse handles the GetNetworkTraceOperationV2 response.
func (client *WebAppsClient) getNetworkTraceOperationV2HandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTraceOperationV2HandleError handles the GetNetworkTraceOperationV2 error response.
func (client *WebAppsClient) getNetworkTraceOperationV2HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTraces - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraces(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesOptions) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTracesCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return NetworkTraceArrayResponse{}, client.getNetworkTracesHandleError(resp)
	}
	return client.getNetworkTracesHandleResponse(resp)
}

// getNetworkTracesCreateRequest creates the GetNetworkTraces request.
func (client *WebAppsClient) getNetworkTracesCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesHandleResponse handles the GetNetworkTraces response.
func (client *WebAppsClient) getNetworkTracesHandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTracesHandleError handles the GetNetworkTraces error response.
func (client *WebAppsClient) getNetworkTracesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTracesSlot - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTracesSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotOptions) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTracesSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return NetworkTraceArrayResponse{}, client.getNetworkTracesSlotHandleError(resp)
	}
	return client.getNetworkTracesSlotHandleResponse(resp)
}

// getNetworkTracesSlotCreateRequest creates the GetNetworkTracesSlot request.
func (client *WebAppsClient) getNetworkTracesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesSlotHandleResponse handles the GetNetworkTracesSlot response.
func (client *WebAppsClient) getNetworkTracesSlotHandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTracesSlotHandleError handles the GetNetworkTracesSlot error response.
func (client *WebAppsClient) getNetworkTracesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTracesSlotV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTracesSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotV2Options) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTracesSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return NetworkTraceArrayResponse{}, client.getNetworkTracesSlotV2HandleError(resp)
	}
	return client.getNetworkTracesSlotV2HandleResponse(resp)
}

// getNetworkTracesSlotV2CreateRequest creates the GetNetworkTracesSlotV2 request.
func (client *WebAppsClient) getNetworkTracesSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotV2Options) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesSlotV2HandleResponse handles the GetNetworkTracesSlotV2 response.
func (client *WebAppsClient) getNetworkTracesSlotV2HandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTracesSlotV2HandleError handles the GetNetworkTracesSlotV2 error response.
func (client *WebAppsClient) getNetworkTracesSlotV2HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNetworkTracesV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTracesV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesV2Options) (NetworkTraceArrayResponse, error) {
	req, err := client.getNetworkTracesV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return NetworkTraceArrayResponse{}, client.getNetworkTracesV2HandleError(resp)
	}
	return client.getNetworkTracesV2HandleResponse(resp)
}

// getNetworkTracesV2CreateRequest creates the GetNetworkTracesV2 request.
func (client *WebAppsClient) getNetworkTracesV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesV2Options) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesV2HandleResponse handles the GetNetworkTracesV2 response.
func (client *WebAppsClient) getNetworkTracesV2HandleResponse(resp *azcore.Response) (NetworkTraceArrayResponse, error) {
	var val []*NetworkTrace
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkTraceArrayResponse{}, err
	}
	return NetworkTraceArrayResponse{RawResponse: resp.Response, NetworkTraceArray: val}, nil
}

// getNetworkTracesV2HandleError handles the GetNetworkTracesV2 error response.
func (client *WebAppsClient) getNetworkTracesV2HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPremierAddOn - Description for Gets a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsGetPremierAddOnOptions) (PremierAddOnResponse, error) {
	req, err := client.getPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.getPremierAddOnHandleError(resp)
	}
	return client.getPremierAddOnHandleResponse(resp)
}

// getPremierAddOnCreateRequest creates the GetPremierAddOn request.
func (client *WebAppsClient) getPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsGetPremierAddOnOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPremierAddOnHandleResponse handles the GetPremierAddOn response.
func (client *WebAppsClient) getPremierAddOnHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// getPremierAddOnHandleError handles the GetPremierAddOn error response.
func (client *WebAppsClient) getPremierAddOnHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPremierAddOnSlot - Description for Gets a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsGetPremierAddOnSlotOptions) (PremierAddOnResponse, error) {
	req, err := client.getPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.getPremierAddOnSlotHandleError(resp)
	}
	return client.getPremierAddOnSlotHandleResponse(resp)
}

// getPremierAddOnSlotCreateRequest creates the GetPremierAddOnSlot request.
func (client *WebAppsClient) getPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsGetPremierAddOnSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPremierAddOnSlotHandleResponse handles the GetPremierAddOnSlot response.
func (client *WebAppsClient) getPremierAddOnSlotHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// getPremierAddOnSlotHandleError handles the GetPremierAddOnSlot error response.
func (client *WebAppsClient) getPremierAddOnSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateAccess - Description for Gets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateAccess(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateAccessOptions) (PrivateAccessResponse, error) {
	req, err := client.getPrivateAccessCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PrivateAccessResponse{}, client.getPrivateAccessHandleError(resp)
	}
	return client.getPrivateAccessHandleResponse(resp)
}

// getPrivateAccessCreateRequest creates the GetPrivateAccess request.
func (client *WebAppsClient) getPrivateAccessCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateAccessOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateAccessHandleResponse handles the GetPrivateAccess response.
func (client *WebAppsClient) getPrivateAccessHandleResponse(resp *azcore.Response) (PrivateAccessResponse, error) {
	var val *PrivateAccess
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateAccessResponse{}, err
	}
	return PrivateAccessResponse{RawResponse: resp.Response, PrivateAccess: val}, nil
}

// getPrivateAccessHandleError handles the GetPrivateAccess error response.
func (client *WebAppsClient) getPrivateAccessHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateAccessSlot - Description for Gets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateAccessSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateAccessSlotOptions) (PrivateAccessResponse, error) {
	req, err := client.getPrivateAccessSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PrivateAccessResponse{}, client.getPrivateAccessSlotHandleError(resp)
	}
	return client.getPrivateAccessSlotHandleResponse(resp)
}

// getPrivateAccessSlotCreateRequest creates the GetPrivateAccessSlot request.
func (client *WebAppsClient) getPrivateAccessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateAccessSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateAccessSlotHandleResponse handles the GetPrivateAccessSlot response.
func (client *WebAppsClient) getPrivateAccessSlotHandleResponse(resp *azcore.Response) (PrivateAccessResponse, error) {
	var val *PrivateAccess
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateAccessResponse{}, err
	}
	return PrivateAccessResponse{RawResponse: resp.Response, PrivateAccess: val}, nil
}

// getPrivateAccessSlotHandleError handles the GetPrivateAccessSlot error response.
func (client *WebAppsClient) getPrivateAccessSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateEndpointConnection - Description for Gets a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsGetPrivateEndpointConnectionOptions) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
	req, err := client.getPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, client.getPrivateEndpointConnectionHandleError(resp)
	}
	return client.getPrivateEndpointConnectionHandleResponse(resp)
}

// getPrivateEndpointConnectionCreateRequest creates the GetPrivateEndpointConnection request.
func (client *WebAppsClient) getPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsGetPrivateEndpointConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionHandleResponse handles the GetPrivateEndpointConnection response.
func (client *WebAppsClient) getPrivateEndpointConnectionHandleResponse(resp *azcore.Response) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
	var val *RemotePrivateEndpointConnectionARMResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, err
	}
	return RemotePrivateEndpointConnectionARMResourceResponse{RawResponse: resp.Response, RemotePrivateEndpointConnectionARMResource: val}, nil
}

// getPrivateEndpointConnectionHandleError handles the GetPrivateEndpointConnection error response.
func (client *WebAppsClient) getPrivateEndpointConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateEndpointConnectionList - Description for Gets the list of private endpoint connections associated with a site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnectionList(resourceGroupName string, name string, options *WebAppsGetPrivateEndpointConnectionListOptions) PrivateEndpointConnectionCollectionPager {
	return &privateEndpointConnectionCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getPrivateEndpointConnectionListCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.getPrivateEndpointConnectionListHandleResponse,
		errorer:   client.getPrivateEndpointConnectionListHandleError,
		advancer: func(ctx context.Context, resp PrivateEndpointConnectionCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PrivateEndpointConnectionCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getPrivateEndpointConnectionListCreateRequest creates the GetPrivateEndpointConnectionList request.
func (client *WebAppsClient) getPrivateEndpointConnectionListCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateEndpointConnectionListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionListHandleResponse handles the GetPrivateEndpointConnectionList response.
func (client *WebAppsClient) getPrivateEndpointConnectionListHandleResponse(resp *azcore.Response) (PrivateEndpointConnectionCollectionResponse, error) {
	var val *PrivateEndpointConnectionCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateEndpointConnectionCollectionResponse{}, err
	}
	return PrivateEndpointConnectionCollectionResponse{RawResponse: resp.Response, PrivateEndpointConnectionCollection: val}, nil
}

// getPrivateEndpointConnectionListHandleError handles the GetPrivateEndpointConnectionList error response.
func (client *WebAppsClient) getPrivateEndpointConnectionListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateEndpointConnectionListSlot - Description for Gets the list of private endpoint connections associated with a site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnectionListSlot(resourceGroupName string, name string, slot string, options *WebAppsGetPrivateEndpointConnectionListSlotOptions) PrivateEndpointConnectionCollectionPager {
	return &privateEndpointConnectionCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getPrivateEndpointConnectionListSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.getPrivateEndpointConnectionListSlotHandleResponse,
		errorer:   client.getPrivateEndpointConnectionListSlotHandleError,
		advancer: func(ctx context.Context, resp PrivateEndpointConnectionCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PrivateEndpointConnectionCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getPrivateEndpointConnectionListSlotCreateRequest creates the GetPrivateEndpointConnectionListSlot request.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateEndpointConnectionListSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionListSlotHandleResponse handles the GetPrivateEndpointConnectionListSlot response.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotHandleResponse(resp *azcore.Response) (PrivateEndpointConnectionCollectionResponse, error) {
	var val *PrivateEndpointConnectionCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateEndpointConnectionCollectionResponse{}, err
	}
	return PrivateEndpointConnectionCollectionResponse{RawResponse: resp.Response, PrivateEndpointConnectionCollection: val}, nil
}

// getPrivateEndpointConnectionListSlotHandleError handles the GetPrivateEndpointConnectionListSlot error response.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateEndpointConnectionSlot - Description for Gets a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsGetPrivateEndpointConnectionSlotOptions) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
	req, err := client.getPrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, client.getPrivateEndpointConnectionSlotHandleError(resp)
	}
	return client.getPrivateEndpointConnectionSlotHandleResponse(resp)
}

// getPrivateEndpointConnectionSlotCreateRequest creates the GetPrivateEndpointConnectionSlot request.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsGetPrivateEndpointConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionSlotHandleResponse handles the GetPrivateEndpointConnectionSlot response.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotHandleResponse(resp *azcore.Response) (RemotePrivateEndpointConnectionARMResourceResponse, error) {
	var val *RemotePrivateEndpointConnectionARMResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RemotePrivateEndpointConnectionARMResourceResponse{}, err
	}
	return RemotePrivateEndpointConnectionARMResourceResponse{RawResponse: resp.Response, RemotePrivateEndpointConnectionARMResource: val}, nil
}

// getPrivateEndpointConnectionSlotHandleError handles the GetPrivateEndpointConnectionSlot error response.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateLinkResources - Description for Gets the private link resources
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateLinkResources(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateLinkResourcesOptions) (PrivateLinkResourcesWrapperResponse, error) {
	req, err := client.getPrivateLinkResourcesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return PrivateLinkResourcesWrapperResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PrivateLinkResourcesWrapperResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PrivateLinkResourcesWrapperResponse{}, client.getPrivateLinkResourcesHandleError(resp)
	}
	return client.getPrivateLinkResourcesHandleResponse(resp)
}

// getPrivateLinkResourcesCreateRequest creates the GetPrivateLinkResources request.
func (client *WebAppsClient) getPrivateLinkResourcesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateLinkResourcesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateLinkResourcesHandleResponse handles the GetPrivateLinkResources response.
func (client *WebAppsClient) getPrivateLinkResourcesHandleResponse(resp *azcore.Response) (PrivateLinkResourcesWrapperResponse, error) {
	var val *PrivateLinkResourcesWrapper
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateLinkResourcesWrapperResponse{}, err
	}
	return PrivateLinkResourcesWrapperResponse{RawResponse: resp.Response, PrivateLinkResourcesWrapper: val}, nil
}

// getPrivateLinkResourcesHandleError handles the GetPrivateLinkResources error response.
func (client *WebAppsClient) getPrivateLinkResourcesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPrivateLinkResourcesSlot - Description for Gets the private link resources
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateLinkResourcesSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateLinkResourcesSlotOptions) (PrivateLinkResourcesWrapperResponse, error) {
	req, err := client.getPrivateLinkResourcesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return PrivateLinkResourcesWrapperResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PrivateLinkResourcesWrapperResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PrivateLinkResourcesWrapperResponse{}, client.getPrivateLinkResourcesSlotHandleError(resp)
	}
	return client.getPrivateLinkResourcesSlotHandleResponse(resp)
}

// getPrivateLinkResourcesSlotCreateRequest creates the GetPrivateLinkResourcesSlot request.
func (client *WebAppsClient) getPrivateLinkResourcesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateLinkResourcesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateLinkResourcesSlotHandleResponse handles the GetPrivateLinkResourcesSlot response.
func (client *WebAppsClient) getPrivateLinkResourcesSlotHandleResponse(resp *azcore.Response) (PrivateLinkResourcesWrapperResponse, error) {
	var val *PrivateLinkResourcesWrapper
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateLinkResourcesWrapperResponse{}, err
	}
	return PrivateLinkResourcesWrapperResponse{RawResponse: resp.Response, PrivateLinkResourcesWrapper: val}, nil
}

// getPrivateLinkResourcesSlotHandleError handles the GetPrivateLinkResourcesSlot error response.
func (client *WebAppsClient) getPrivateLinkResourcesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetProcess - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessOptions) (ProcessInfoResponse, error) {
	req, err := client.getProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessInfoResponse{}, client.getProcessHandleError(resp)
	}
	return client.getProcessHandleResponse(resp)
}

// getProcessCreateRequest creates the GetProcess request.
func (client *WebAppsClient) getProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessHandleResponse handles the GetProcess response.
func (client *WebAppsClient) getProcessHandleResponse(resp *azcore.Response) (ProcessInfoResponse, error) {
	var val *ProcessInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoResponse{}, err
	}
	return ProcessInfoResponse{RawResponse: resp.Response, ProcessInfo: val}, nil
}

// getProcessHandleError handles the GetProcess error response.
func (client *WebAppsClient) getProcessHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetProcessDump - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessDumpOptions) (*http.Response, error) {
	req, err := client.getProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getProcessDumpHandleError(resp)
	}
	return resp.Response, nil
}

// getProcessDumpCreateRequest creates the GetProcessDump request.
func (client *WebAppsClient) getProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessDumpOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessDumpHandleError handles the GetProcessDump error response.
func (client *WebAppsClient) getProcessDumpHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetProcessDumpSlot - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessDumpSlotOptions) (*http.Response, error) {
	req, err := client.getProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getProcessDumpSlotHandleError(resp)
	}
	return resp.Response, nil
}

// getProcessDumpSlotCreateRequest creates the GetProcessDumpSlot request.
func (client *WebAppsClient) getProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessDumpSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessDumpSlotHandleError handles the GetProcessDumpSlot error response.
func (client *WebAppsClient) getProcessDumpSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetProcessModule - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *WebAppsGetProcessModuleOptions) (ProcessModuleInfoResponse, error) {
	req, err := client.getProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, options)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessModuleInfoResponse{}, client.getProcessModuleHandleError(resp)
	}
	return client.getProcessModuleHandleResponse(resp)
}

// getProcessModuleCreateRequest creates the GetProcessModule request.
func (client *WebAppsClient) getProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *WebAppsGetProcessModuleOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessModuleHandleResponse handles the GetProcessModule response.
func (client *WebAppsClient) getProcessModuleHandleResponse(resp *azcore.Response) (ProcessModuleInfoResponse, error) {
	var val *ProcessModuleInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	return ProcessModuleInfoResponse{RawResponse: resp.Response, ProcessModuleInfo: val}, nil
}

// getProcessModuleHandleError handles the GetProcessModule error response.
func (client *WebAppsClient) getProcessModuleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetProcessModuleSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *WebAppsGetProcessModuleSlotOptions) (ProcessModuleInfoResponse, error) {
	req, err := client.getProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, options)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessModuleInfoResponse{}, client.getProcessModuleSlotHandleError(resp)
	}
	return client.getProcessModuleSlotHandleResponse(resp)
}

// getProcessModuleSlotCreateRequest creates the GetProcessModuleSlot request.
func (client *WebAppsClient) getProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *WebAppsGetProcessModuleSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessModuleSlotHandleResponse handles the GetProcessModuleSlot response.
func (client *WebAppsClient) getProcessModuleSlotHandleResponse(resp *azcore.Response) (ProcessModuleInfoResponse, error) {
	var val *ProcessModuleInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoResponse{}, err
	}
	return ProcessModuleInfoResponse{RawResponse: resp.Response, ProcessModuleInfo: val}, nil
}

// getProcessModuleSlotHandleError handles the GetProcessModuleSlot error response.
func (client *WebAppsClient) getProcessModuleSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetProcessSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessSlotOptions) (ProcessInfoResponse, error) {
	req, err := client.getProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ProcessInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProcessInfoResponse{}, client.getProcessSlotHandleError(resp)
	}
	return client.getProcessSlotHandleResponse(resp)
}

// getProcessSlotCreateRequest creates the GetProcessSlot request.
func (client *WebAppsClient) getProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessSlotHandleResponse handles the GetProcessSlot response.
func (client *WebAppsClient) getProcessSlotHandleResponse(resp *azcore.Response) (ProcessInfoResponse, error) {
	var val *ProcessInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoResponse{}, err
	}
	return ProcessInfoResponse{RawResponse: resp.Response, ProcessInfo: val}, nil
}

// getProcessSlotHandleError handles the GetProcessSlot error response.
func (client *WebAppsClient) getProcessSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetPublicCertificate - Description for Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsGetPublicCertificateOptions) (PublicCertificateResponse, error) {
	req, err := client.getPublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PublicCertificateResponse{}, client.getPublicCertificateHandleError(resp)
	}
	return client.getPublicCertificateHandleResponse(resp)
}

// getPublicCertificateCreateRequest creates the GetPublicCertificate request.
func (client *WebAppsClient) getPublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsGetPublicCertificateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPublicCertificateHandleResponse handles the GetPublicCertificate response.
func (client *WebAppsClient) getPublicCertificateHandleResponse(resp *azcore.Response) (PublicCertificateResponse, error) {
	var val *PublicCertificate
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublicCertificateResponse{}, err
	}
	return PublicCertificateResponse{RawResponse: resp.Response, PublicCertificate: val}, nil
}

// getPublicCertificateHandleError handles the GetPublicCertificate error response.
func (client *WebAppsClient) getPublicCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPublicCertificateSlot - Description for Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsGetPublicCertificateSlotOptions) (PublicCertificateResponse, error) {
	req, err := client.getPublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PublicCertificateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PublicCertificateResponse{}, client.getPublicCertificateSlotHandleError(resp)
	}
	return client.getPublicCertificateSlotHandleResponse(resp)
}

// getPublicCertificateSlotCreateRequest creates the GetPublicCertificateSlot request.
func (client *WebAppsClient) getPublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsGetPublicCertificateSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPublicCertificateSlotHandleResponse handles the GetPublicCertificateSlot response.
func (client *WebAppsClient) getPublicCertificateSlotHandleResponse(resp *azcore.Response) (PublicCertificateResponse, error) {
	var val *PublicCertificate
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublicCertificateResponse{}, err
	}
	return PublicCertificateResponse{RawResponse: resp.Response, PublicCertificate: val}, nil
}

// getPublicCertificateSlotHandleError handles the GetPublicCertificateSlot error response.
func (client *WebAppsClient) getPublicCertificateSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetRelayServiceConnection - Description for Gets a hybrid connection configuration by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsGetRelayServiceConnectionOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.getRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.getRelayServiceConnectionHandleError(resp)
	}
	return client.getRelayServiceConnectionHandleResponse(resp)
}

// getRelayServiceConnectionCreateRequest creates the GetRelayServiceConnection request.
func (client *WebAppsClient) getRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsGetRelayServiceConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getRelayServiceConnectionHandleResponse handles the GetRelayServiceConnection response.
func (client *WebAppsClient) getRelayServiceConnectionHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// getRelayServiceConnectionHandleError handles the GetRelayServiceConnection error response.
func (client *WebAppsClient) getRelayServiceConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetRelayServiceConnectionSlot - Description for Gets a hybrid connection configuration by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsGetRelayServiceConnectionSlotOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.getRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.getRelayServiceConnectionSlotHandleError(resp)
	}
	return client.getRelayServiceConnectionSlotHandleResponse(resp)
}

// getRelayServiceConnectionSlotCreateRequest creates the GetRelayServiceConnectionSlot request.
func (client *WebAppsClient) getRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsGetRelayServiceConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getRelayServiceConnectionSlotHandleResponse handles the GetRelayServiceConnectionSlot response.
func (client *WebAppsClient) getRelayServiceConnectionSlotHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// getRelayServiceConnectionSlotHandleError handles the GetRelayServiceConnectionSlot error response.
func (client *WebAppsClient) getRelayServiceConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetScmAllowed - Description for Returns whether Scm basic auth is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetScmAllowed(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetScmAllowedOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.getScmAllowedCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.getScmAllowedHandleError(resp)
	}
	return client.getScmAllowedHandleResponse(resp)
}

// getScmAllowedCreateRequest creates the GetScmAllowed request.
func (client *WebAppsClient) getScmAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetScmAllowedOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getScmAllowedHandleResponse handles the GetScmAllowed response.
func (client *WebAppsClient) getScmAllowedHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// getScmAllowedHandleError handles the GetScmAllowed error response.
func (client *WebAppsClient) getScmAllowedHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetScmAllowedSlot - Description for Returns whether Scm basic auth is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetScmAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetScmAllowedSlotOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.getScmAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.getScmAllowedSlotHandleError(resp)
	}
	return client.getScmAllowedSlotHandleResponse(resp)
}

// getScmAllowedSlotCreateRequest creates the GetScmAllowedSlot request.
func (client *WebAppsClient) getScmAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetScmAllowedSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getScmAllowedSlotHandleResponse handles the GetScmAllowedSlot response.
func (client *WebAppsClient) getScmAllowedSlotHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// getScmAllowedSlotHandleError handles the GetScmAllowedSlot error response.
func (client *WebAppsClient) getScmAllowedSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSiteConnectionStringKeyVaultReference - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReference(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceOptions) (APIKVReferenceResponse, error) {
	req, err := client.getSiteConnectionStringKeyVaultReferenceCreateRequest(ctx, resourceGroupName, name, connectionStringKey, options)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return APIKVReferenceResponse{}, client.getSiteConnectionStringKeyVaultReferenceHandleError(resp)
	}
	return client.getSiteConnectionStringKeyVaultReferenceHandleResponse(resp)
}

// getSiteConnectionStringKeyVaultReferenceCreateRequest creates the GetSiteConnectionStringKeyVaultReference request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings/{connectionStringKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if connectionStringKey == "" {
		return nil, errors.New("parameter connectionStringKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionStringKey}", url.PathEscape(connectionStringKey))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferenceHandleResponse handles the GetSiteConnectionStringKeyVaultReference response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceHandleResponse(resp *azcore.Response) (APIKVReferenceResponse, error) {
	var val *APIKVReference
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceResponse{}, err
	}
	return APIKVReferenceResponse{RawResponse: resp.Response, APIKVReference: val}, nil
}

// getSiteConnectionStringKeyVaultReferenceHandleError handles the GetSiteConnectionStringKeyVaultReference error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSiteConnectionStringKeyVaultReferenceSlot - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReferenceSlot(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceSlotOptions) (APIKVReferenceResponse, error) {
	req, err := client.getSiteConnectionStringKeyVaultReferenceSlotCreateRequest(ctx, resourceGroupName, name, connectionStringKey, slot, options)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return APIKVReferenceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return APIKVReferenceResponse{}, client.getSiteConnectionStringKeyVaultReferenceSlotHandleError(resp)
	}
	return client.getSiteConnectionStringKeyVaultReferenceSlotHandleResponse(resp)
}

// getSiteConnectionStringKeyVaultReferenceSlotCreateRequest creates the GetSiteConnectionStringKeyVaultReferenceSlot request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings/{connectionStringKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if connectionStringKey == "" {
		return nil, errors.New("parameter connectionStringKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionStringKey}", url.PathEscape(connectionStringKey))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferenceSlotHandleResponse handles the GetSiteConnectionStringKeyVaultReferenceSlot response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotHandleResponse(resp *azcore.Response) (APIKVReferenceResponse, error) {
	var val *APIKVReference
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceResponse{}, err
	}
	return APIKVReferenceResponse{RawResponse: resp.Response, APIKVReference: val}, nil
}

// getSiteConnectionStringKeyVaultReferenceSlotHandleError handles the GetSiteConnectionStringKeyVaultReferenceSlot error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSiteConnectionStringKeyVaultReferences - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReferences(resourceGroupName string, name string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesOptions) APIKVReferenceCollectionPager {
	return &apikvReferenceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getSiteConnectionStringKeyVaultReferencesCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.getSiteConnectionStringKeyVaultReferencesHandleResponse,
		errorer:   client.getSiteConnectionStringKeyVaultReferencesHandleError,
		advancer: func(ctx context.Context, resp APIKVReferenceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getSiteConnectionStringKeyVaultReferencesCreateRequest creates the GetSiteConnectionStringKeyVaultReferences request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferencesHandleResponse handles the GetSiteConnectionStringKeyVaultReferences response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesHandleResponse(resp *azcore.Response) (APIKVReferenceCollectionResponse, error) {
	var val *APIKVReferenceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceCollectionResponse{}, err
	}
	return APIKVReferenceCollectionResponse{RawResponse: resp.Response, APIKVReferenceCollection: val}, nil
}

// getSiteConnectionStringKeyVaultReferencesHandleError handles the GetSiteConnectionStringKeyVaultReferences error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSiteConnectionStringKeyVaultReferencesSlot - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName string, name string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesSlotOptions) APIKVReferenceCollectionPager {
	return &apikvReferenceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getSiteConnectionStringKeyVaultReferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.getSiteConnectionStringKeyVaultReferencesSlotHandleResponse,
		errorer:   client.getSiteConnectionStringKeyVaultReferencesSlotHandleError,
		advancer: func(ctx context.Context, resp APIKVReferenceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getSiteConnectionStringKeyVaultReferencesSlotCreateRequest creates the GetSiteConnectionStringKeyVaultReferencesSlot request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferencesSlotHandleResponse handles the GetSiteConnectionStringKeyVaultReferencesSlot response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotHandleResponse(resp *azcore.Response) (APIKVReferenceCollectionResponse, error) {
	var val *APIKVReferenceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return APIKVReferenceCollectionResponse{}, err
	}
	return APIKVReferenceCollectionResponse{RawResponse: resp.Response, APIKVReferenceCollection: val}, nil
}

// getSiteConnectionStringKeyVaultReferencesSlotHandleError handles the GetSiteConnectionStringKeyVaultReferencesSlot error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSiteExtension - Description for Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsGetSiteExtensionOptions) (SiteExtensionInfoResponse, error) {
	req, err := client.getSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return SiteExtensionInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteExtensionInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteExtensionInfoResponse{}, client.getSiteExtensionHandleError(resp)
	}
	return client.getSiteExtensionHandleResponse(resp)
}

// getSiteExtensionCreateRequest creates the GetSiteExtension request.
func (client *WebAppsClient) getSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsGetSiteExtensionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteExtensionHandleResponse handles the GetSiteExtension response.
func (client *WebAppsClient) getSiteExtensionHandleResponse(resp *azcore.Response) (SiteExtensionInfoResponse, error) {
	var val *SiteExtensionInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteExtensionInfoResponse{}, err
	}
	return SiteExtensionInfoResponse{RawResponse: resp.Response, SiteExtensionInfo: val}, nil
}

// getSiteExtensionHandleError handles the GetSiteExtension error response.
func (client *WebAppsClient) getSiteExtensionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetSiteExtensionSlot - Description for Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsGetSiteExtensionSlotOptions) (SiteExtensionInfoResponse, error) {
	req, err := client.getSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return SiteExtensionInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteExtensionInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteExtensionInfoResponse{}, client.getSiteExtensionSlotHandleError(resp)
	}
	return client.getSiteExtensionSlotHandleResponse(resp)
}

// getSiteExtensionSlotCreateRequest creates the GetSiteExtensionSlot request.
func (client *WebAppsClient) getSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsGetSiteExtensionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteExtensionSlotHandleResponse handles the GetSiteExtensionSlot response.
func (client *WebAppsClient) getSiteExtensionSlotHandleResponse(resp *azcore.Response) (SiteExtensionInfoResponse, error) {
	var val *SiteExtensionInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteExtensionInfoResponse{}, err
	}
	return SiteExtensionInfoResponse{RawResponse: resp.Response, SiteExtensionInfo: val}, nil
}

// getSiteExtensionSlotHandleError handles the GetSiteExtensionSlot error response.
func (client *WebAppsClient) getSiteExtensionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetSitePhpErrorLogFlag - Description for Gets web app's event logs.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSitePhpErrorLogFlag(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSitePhpErrorLogFlagOptions) (SitePhpErrorLogFlagResponse, error) {
	req, err := client.getSitePhpErrorLogFlagCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SitePhpErrorLogFlagResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SitePhpErrorLogFlagResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SitePhpErrorLogFlagResponse{}, client.getSitePhpErrorLogFlagHandleError(resp)
	}
	return client.getSitePhpErrorLogFlagHandleResponse(resp)
}

// getSitePhpErrorLogFlagCreateRequest creates the GetSitePhpErrorLogFlag request.
func (client *WebAppsClient) getSitePhpErrorLogFlagCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSitePhpErrorLogFlagOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSitePhpErrorLogFlagHandleResponse handles the GetSitePhpErrorLogFlag response.
func (client *WebAppsClient) getSitePhpErrorLogFlagHandleResponse(resp *azcore.Response) (SitePhpErrorLogFlagResponse, error) {
	var val *SitePhpErrorLogFlag
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SitePhpErrorLogFlagResponse{}, err
	}
	return SitePhpErrorLogFlagResponse{RawResponse: resp.Response, SitePhpErrorLogFlag: val}, nil
}

// getSitePhpErrorLogFlagHandleError handles the GetSitePhpErrorLogFlag error response.
func (client *WebAppsClient) getSitePhpErrorLogFlagHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSitePhpErrorLogFlagSlot - Description for Gets web app's event logs.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSitePhpErrorLogFlagSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSitePhpErrorLogFlagSlotOptions) (SitePhpErrorLogFlagResponse, error) {
	req, err := client.getSitePhpErrorLogFlagSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SitePhpErrorLogFlagResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SitePhpErrorLogFlagResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SitePhpErrorLogFlagResponse{}, client.getSitePhpErrorLogFlagSlotHandleError(resp)
	}
	return client.getSitePhpErrorLogFlagSlotHandleResponse(resp)
}

// getSitePhpErrorLogFlagSlotCreateRequest creates the GetSitePhpErrorLogFlagSlot request.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSitePhpErrorLogFlagSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSitePhpErrorLogFlagSlotHandleResponse handles the GetSitePhpErrorLogFlagSlot response.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotHandleResponse(resp *azcore.Response) (SitePhpErrorLogFlagResponse, error) {
	var val *SitePhpErrorLogFlag
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SitePhpErrorLogFlagResponse{}, err
	}
	return SitePhpErrorLogFlagResponse{RawResponse: resp.Response, SitePhpErrorLogFlag: val}, nil
}

// getSitePhpErrorLogFlagSlotHandleError handles the GetSitePhpErrorLogFlagSlot error response.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSlot - Description for Gets the details of a web, mobile, or API app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSlotOptions) (SiteResponse, error) {
	req, err := client.getSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SiteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteResponse{}, client.getSlotHandleError(resp)
	}
	return client.getSlotHandleResponse(resp)
}

// getSlotCreateRequest creates the GetSlot request.
func (client *WebAppsClient) getSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSlotHandleResponse handles the GetSlot response.
func (client *WebAppsClient) getSlotHandleResponse(resp *azcore.Response) (SiteResponse, error) {
	var val *Site
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteResponse{}, err
	}
	return SiteResponse{RawResponse: resp.Response, Site: val}, nil
}

// getSlotHandleError handles the GetSlot error response.
func (client *WebAppsClient) getSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetSourceControl - Description for Gets the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSourceControl(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSourceControlOptions) (SiteSourceControlResponse, error) {
	req, err := client.getSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return SiteSourceControlResponse{}, client.getSourceControlHandleError(resp)
	}
	return client.getSourceControlHandleResponse(resp)
}

// getSourceControlCreateRequest creates the GetSourceControl request.
func (client *WebAppsClient) getSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSourceControlOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSourceControlHandleResponse handles the GetSourceControl response.
func (client *WebAppsClient) getSourceControlHandleResponse(resp *azcore.Response) (SiteSourceControlResponse, error) {
	var val *SiteSourceControl
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteSourceControlResponse{}, err
	}
	return SiteSourceControlResponse{RawResponse: resp.Response, SiteSourceControl: val}, nil
}

// getSourceControlHandleError handles the GetSourceControl error response.
func (client *WebAppsClient) getSourceControlHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSourceControlSlot - Description for Gets the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSourceControlSlotOptions) (SiteSourceControlResponse, error) {
	req, err := client.getSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return SiteSourceControlResponse{}, client.getSourceControlSlotHandleError(resp)
	}
	return client.getSourceControlSlotHandleResponse(resp)
}

// getSourceControlSlotCreateRequest creates the GetSourceControlSlot request.
func (client *WebAppsClient) getSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSourceControlSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSourceControlSlotHandleResponse handles the GetSourceControlSlot response.
func (client *WebAppsClient) getSourceControlSlotHandleResponse(resp *azcore.Response) (SiteSourceControlResponse, error) {
	var val *SiteSourceControl
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteSourceControlResponse{}, err
	}
	return SiteSourceControlResponse{RawResponse: resp.Response, SiteSourceControl: val}, nil
}

// getSourceControlSlotHandleError handles the GetSourceControlSlot error response.
func (client *WebAppsClient) getSourceControlSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSwiftVirtualNetworkConnection - Description for Gets a Swift Virtual Network connection.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSwiftVirtualNetworkConnectionOptions) (SwiftVirtualNetworkResponse, error) {
	req, err := client.getSwiftVirtualNetworkConnectionCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SwiftVirtualNetworkResponse{}, client.getSwiftVirtualNetworkConnectionHandleError(resp)
	}
	return client.getSwiftVirtualNetworkConnectionHandleResponse(resp)
}

// getSwiftVirtualNetworkConnectionCreateRequest creates the GetSwiftVirtualNetworkConnection request.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSwiftVirtualNetworkConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSwiftVirtualNetworkConnectionHandleResponse handles the GetSwiftVirtualNetworkConnection response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionHandleResponse(resp *azcore.Response) (SwiftVirtualNetworkResponse, error) {
	var val *SwiftVirtualNetwork
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	return SwiftVirtualNetworkResponse{RawResponse: resp.Response, SwiftVirtualNetwork: val}, nil
}

// getSwiftVirtualNetworkConnectionHandleError handles the GetSwiftVirtualNetworkConnection error response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSwiftVirtualNetworkConnectionSlot - Description for Gets a Swift Virtual Network connection.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSwiftVirtualNetworkConnectionSlotOptions) (SwiftVirtualNetworkResponse, error) {
	req, err := client.getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SwiftVirtualNetworkResponse{}, client.getSwiftVirtualNetworkConnectionSlotHandleError(resp)
	}
	return client.getSwiftVirtualNetworkConnectionSlotHandleResponse(resp)
}

// getSwiftVirtualNetworkConnectionSlotCreateRequest creates the GetSwiftVirtualNetworkConnectionSlot request.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSwiftVirtualNetworkConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSwiftVirtualNetworkConnectionSlotHandleResponse handles the GetSwiftVirtualNetworkConnectionSlot response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotHandleResponse(resp *azcore.Response) (SwiftVirtualNetworkResponse, error) {
	var val *SwiftVirtualNetwork
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	return SwiftVirtualNetworkResponse{RawResponse: resp.Response, SwiftVirtualNetwork: val}, nil
}

// getSwiftVirtualNetworkConnectionSlotHandleError handles the GetSwiftVirtualNetworkConnectionSlot error response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetTriggeredWebJob - Description for Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetTriggeredWebJobOptions) (TriggeredWebJobResponse, error) {
	req, err := client.getTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return TriggeredWebJobResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TriggeredWebJobResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return TriggeredWebJobResponse{}, client.getTriggeredWebJobHandleError(resp)
	}
	return client.getTriggeredWebJobHandleResponse(resp)
}

// getTriggeredWebJobCreateRequest creates the GetTriggeredWebJob request.
func (client *WebAppsClient) getTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetTriggeredWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobHandleResponse handles the GetTriggeredWebJob response.
func (client *WebAppsClient) getTriggeredWebJobHandleResponse(resp *azcore.Response) (TriggeredWebJobResponse, error) {
	var val *TriggeredWebJob
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredWebJobResponse{}, err
	}
	return TriggeredWebJobResponse{RawResponse: resp.Response, TriggeredWebJob: val}, nil
}

// getTriggeredWebJobHandleError handles the GetTriggeredWebJob error response.
func (client *WebAppsClient) getTriggeredWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetTriggeredWebJobHistory - Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJobHistory(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *WebAppsGetTriggeredWebJobHistoryOptions) (TriggeredJobHistoryResponse, error) {
	req, err := client.getTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, id, options)
	if err != nil {
		return TriggeredJobHistoryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TriggeredJobHistoryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return TriggeredJobHistoryResponse{}, client.getTriggeredWebJobHistoryHandleError(resp)
	}
	return client.getTriggeredWebJobHistoryHandleResponse(resp)
}

// getTriggeredWebJobHistoryCreateRequest creates the GetTriggeredWebJobHistory request.
func (client *WebAppsClient) getTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *WebAppsGetTriggeredWebJobHistoryOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobHistoryHandleResponse handles the GetTriggeredWebJobHistory response.
func (client *WebAppsClient) getTriggeredWebJobHistoryHandleResponse(resp *azcore.Response) (TriggeredJobHistoryResponse, error) {
	var val *TriggeredJobHistory
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredJobHistoryResponse{}, err
	}
	return TriggeredJobHistoryResponse{RawResponse: resp.Response, TriggeredJobHistory: val}, nil
}

// getTriggeredWebJobHistoryHandleError handles the GetTriggeredWebJobHistory error response.
func (client *WebAppsClient) getTriggeredWebJobHistoryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetTriggeredWebJobHistorySlot - Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJobHistorySlot(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *WebAppsGetTriggeredWebJobHistorySlotOptions) (TriggeredJobHistoryResponse, error) {
	req, err := client.getTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, id, slot, options)
	if err != nil {
		return TriggeredJobHistoryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TriggeredJobHistoryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return TriggeredJobHistoryResponse{}, client.getTriggeredWebJobHistorySlotHandleError(resp)
	}
	return client.getTriggeredWebJobHistorySlotHandleResponse(resp)
}

// getTriggeredWebJobHistorySlotCreateRequest creates the GetTriggeredWebJobHistorySlot request.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *WebAppsGetTriggeredWebJobHistorySlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobHistorySlotHandleResponse handles the GetTriggeredWebJobHistorySlot response.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotHandleResponse(resp *azcore.Response) (TriggeredJobHistoryResponse, error) {
	var val *TriggeredJobHistory
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredJobHistoryResponse{}, err
	}
	return TriggeredJobHistoryResponse{RawResponse: resp.Response, TriggeredJobHistory: val}, nil
}

// getTriggeredWebJobHistorySlotHandleError handles the GetTriggeredWebJobHistorySlot error response.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetTriggeredWebJobSlot - Description for Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetTriggeredWebJobSlotOptions) (TriggeredWebJobResponse, error) {
	req, err := client.getTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return TriggeredWebJobResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TriggeredWebJobResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return TriggeredWebJobResponse{}, client.getTriggeredWebJobSlotHandleError(resp)
	}
	return client.getTriggeredWebJobSlotHandleResponse(resp)
}

// getTriggeredWebJobSlotCreateRequest creates the GetTriggeredWebJobSlot request.
func (client *WebAppsClient) getTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetTriggeredWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobSlotHandleResponse handles the GetTriggeredWebJobSlot response.
func (client *WebAppsClient) getTriggeredWebJobSlotHandleResponse(resp *azcore.Response) (TriggeredWebJobResponse, error) {
	var val *TriggeredWebJob
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredWebJobResponse{}, err
	}
	return TriggeredWebJobResponse{RawResponse: resp.Response, TriggeredWebJob: val}, nil
}

// getTriggeredWebJobSlotHandleError handles the GetTriggeredWebJobSlot error response.
func (client *WebAppsClient) getTriggeredWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetVnetConnection - Description for Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsGetVnetConnectionOptions) (VnetInfoResponse, error) {
	req, err := client.getVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoResponse{}, client.getVnetConnectionHandleError(resp)
	}
	return client.getVnetConnectionHandleResponse(resp)
}

// getVnetConnectionCreateRequest creates the GetVnetConnection request.
func (client *WebAppsClient) getVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsGetVnetConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionHandleResponse handles the GetVnetConnection response.
func (client *WebAppsClient) getVnetConnectionHandleResponse(resp *azcore.Response) (VnetInfoResponse, error) {
	var val *VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoResponse{}, err
	}
	return VnetInfoResponse{RawResponse: resp.Response, VnetInfo: val}, nil
}

// getVnetConnectionHandleError handles the GetVnetConnection error response.
func (client *WebAppsClient) getVnetConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetVnetConnectionGateway - Description for Gets an app's Virtual Network gateway.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *WebAppsGetVnetConnectionGatewayOptions) (VnetGatewayResponse, error) {
	req, err := client.getVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, options)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetGatewayResponse{}, client.getVnetConnectionGatewayHandleError(resp)
	}
	return client.getVnetConnectionGatewayHandleResponse(resp)
}

// getVnetConnectionGatewayCreateRequest creates the GetVnetConnectionGateway request.
func (client *WebAppsClient) getVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *WebAppsGetVnetConnectionGatewayOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionGatewayHandleResponse handles the GetVnetConnectionGateway response.
func (client *WebAppsClient) getVnetConnectionGatewayHandleResponse(resp *azcore.Response) (VnetGatewayResponse, error) {
	var val *VnetGateway
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetGatewayResponse{}, err
	}
	return VnetGatewayResponse{RawResponse: resp.Response, VnetGateway: val}, nil
}

// getVnetConnectionGatewayHandleError handles the GetVnetConnectionGateway error response.
func (client *WebAppsClient) getVnetConnectionGatewayHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetVnetConnectionGatewaySlot - Description for Gets an app's Virtual Network gateway.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *WebAppsGetVnetConnectionGatewaySlotOptions) (VnetGatewayResponse, error) {
	req, err := client.getVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, options)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetGatewayResponse{}, client.getVnetConnectionGatewaySlotHandleError(resp)
	}
	return client.getVnetConnectionGatewaySlotHandleResponse(resp)
}

// getVnetConnectionGatewaySlotCreateRequest creates the GetVnetConnectionGatewaySlot request.
func (client *WebAppsClient) getVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *WebAppsGetVnetConnectionGatewaySlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionGatewaySlotHandleResponse handles the GetVnetConnectionGatewaySlot response.
func (client *WebAppsClient) getVnetConnectionGatewaySlotHandleResponse(resp *azcore.Response) (VnetGatewayResponse, error) {
	var val *VnetGateway
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetGatewayResponse{}, err
	}
	return VnetGatewayResponse{RawResponse: resp.Response, VnetGateway: val}, nil
}

// getVnetConnectionGatewaySlotHandleError handles the GetVnetConnectionGatewaySlot error response.
func (client *WebAppsClient) getVnetConnectionGatewaySlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// GetVnetConnectionSlot - Description for Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsGetVnetConnectionSlotOptions) (VnetInfoResponse, error) {
	req, err := client.getVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoResponse{}, client.getVnetConnectionSlotHandleError(resp)
	}
	return client.getVnetConnectionSlotHandleResponse(resp)
}

// getVnetConnectionSlotCreateRequest creates the GetVnetConnectionSlot request.
func (client *WebAppsClient) getVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsGetVnetConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionSlotHandleResponse handles the GetVnetConnectionSlot response.
func (client *WebAppsClient) getVnetConnectionSlotHandleResponse(resp *azcore.Response) (VnetInfoResponse, error) {
	var val *VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoResponse{}, err
	}
	return VnetInfoResponse{RawResponse: resp.Response, VnetInfo: val}, nil
}

// getVnetConnectionSlotHandleError handles the GetVnetConnectionSlot error response.
func (client *WebAppsClient) getVnetConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetWebJob - Description for Get webjob information for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetWebJobOptions) (WebJobResponse, error) {
	req, err := client.getWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebJobResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WebJobResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WebJobResponse{}, client.getWebJobHandleError(resp)
	}
	return client.getWebJobHandleResponse(resp)
}

// getWebJobCreateRequest creates the GetWebJob request.
func (client *WebAppsClient) getWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getWebJobHandleResponse handles the GetWebJob response.
func (client *WebAppsClient) getWebJobHandleResponse(resp *azcore.Response) (WebJobResponse, error) {
	var val *WebJob
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebJobResponse{}, err
	}
	return WebJobResponse{RawResponse: resp.Response, WebJob: val}, nil
}

// getWebJobHandleError handles the GetWebJob error response.
func (client *WebAppsClient) getWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetWebJobSlot - Description for Get webjob information for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetWebJobSlotOptions) (WebJobResponse, error) {
	req, err := client.getWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebJobResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WebJobResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WebJobResponse{}, client.getWebJobSlotHandleError(resp)
	}
	return client.getWebJobSlotHandleResponse(resp)
}

// getWebJobSlotCreateRequest creates the GetWebJobSlot request.
func (client *WebAppsClient) getWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getWebJobSlotHandleResponse handles the GetWebJobSlot response.
func (client *WebAppsClient) getWebJobSlotHandleResponse(resp *azcore.Response) (WebJobResponse, error) {
	var val *WebJob
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebJobResponse{}, err
	}
	return WebJobResponse{RawResponse: resp.Response, WebJob: val}, nil
}

// getWebJobSlotHandleError handles the GetWebJobSlot error response.
func (client *WebAppsClient) getWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetWebSiteContainerLogs - Description for Gets the last lines of docker logs for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetWebSiteContainerLogs(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetWebSiteContainerLogsOptions) (*http.Response, error) {
	req, err := client.getWebSiteContainerLogsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.getWebSiteContainerLogsHandleError(resp)
	}
	return resp.Response, nil
}

// getWebSiteContainerLogsCreateRequest creates the GetWebSiteContainerLogs request.
func (client *WebAppsClient) getWebSiteContainerLogsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetWebSiteContainerLogsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/octet-stream")
	return req, nil
}

// getWebSiteContainerLogsHandleError handles the GetWebSiteContainerLogs error response.
func (client *WebAppsClient) getWebSiteContainerLogsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetWebSiteContainerLogsSlot - Description for Gets the last lines of docker logs for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetWebSiteContainerLogsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetWebSiteContainerLogsSlotOptions) (*http.Response, error) {
	req, err := client.getWebSiteContainerLogsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.getWebSiteContainerLogsSlotHandleError(resp)
	}
	return resp.Response, nil
}

// getWebSiteContainerLogsSlotCreateRequest creates the GetWebSiteContainerLogsSlot request.
func (client *WebAppsClient) getWebSiteContainerLogsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetWebSiteContainerLogsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/octet-stream")
	return req, nil
}

// getWebSiteContainerLogsSlotHandleError handles the GetWebSiteContainerLogsSlot error response.
func (client *WebAppsClient) getWebSiteContainerLogsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// BeginInstallSiteExtension - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginInstallSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsBeginInstallSiteExtensionOptions) (SiteExtensionInfoPollerResponse, error) {
	resp, err := client.installSiteExtension(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	result := SiteExtensionInfoPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.InstallSiteExtension", "", resp, client.con.Pipeline(), client.installSiteExtensionHandleError)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	poller := &siteExtensionInfoPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteExtensionInfoResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeInstallSiteExtension creates a new SiteExtensionInfoPoller from the specified resume token.
// token - The value must come from a previous call to SiteExtensionInfoPoller.ResumeToken().
func (client *WebAppsClient) ResumeInstallSiteExtension(ctx context.Context, token string) (SiteExtensionInfoPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.InstallSiteExtension", token, client.con.Pipeline(), client.installSiteExtensionHandleError)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	poller := &siteExtensionInfoPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	result := SiteExtensionInfoPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteExtensionInfoResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// InstallSiteExtension - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) installSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsBeginInstallSiteExtensionOptions) (*azcore.Response, error) {
	req, err := client.installSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.installSiteExtensionHandleError(resp)
	}
	return resp, nil
}

// installSiteExtensionCreateRequest creates the InstallSiteExtension request.
func (client *WebAppsClient) installSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsBeginInstallSiteExtensionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// installSiteExtensionHandleError handles the InstallSiteExtension error response.
func (client *WebAppsClient) installSiteExtensionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusTooManyRequests:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// BeginInstallSiteExtensionSlot - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginInstallSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsBeginInstallSiteExtensionSlotOptions) (SiteExtensionInfoPollerResponse, error) {
	resp, err := client.installSiteExtensionSlot(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	result := SiteExtensionInfoPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.InstallSiteExtensionSlot", "", resp, client.con.Pipeline(), client.installSiteExtensionSlotHandleError)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	poller := &siteExtensionInfoPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteExtensionInfoResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeInstallSiteExtensionSlot creates a new SiteExtensionInfoPoller from the specified resume token.
// token - The value must come from a previous call to SiteExtensionInfoPoller.ResumeToken().
func (client *WebAppsClient) ResumeInstallSiteExtensionSlot(ctx context.Context, token string) (SiteExtensionInfoPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.InstallSiteExtensionSlot", token, client.con.Pipeline(), client.installSiteExtensionSlotHandleError)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	poller := &siteExtensionInfoPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SiteExtensionInfoPollerResponse{}, err
	}
	result := SiteExtensionInfoPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SiteExtensionInfoResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// InstallSiteExtensionSlot - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) installSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsBeginInstallSiteExtensionSlotOptions) (*azcore.Response, error) {
	req, err := client.installSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.installSiteExtensionSlotHandleError(resp)
	}
	return resp, nil
}

// installSiteExtensionSlotCreateRequest creates the InstallSiteExtensionSlot request.
func (client *WebAppsClient) installSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsBeginInstallSiteExtensionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// installSiteExtensionSlotHandleError handles the InstallSiteExtensionSlot error response.
func (client *WebAppsClient) installSiteExtensionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusTooManyRequests:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// IsCloneable - Description for Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) IsCloneable(ctx context.Context, resourceGroupName string, name string, options *WebAppsIsCloneableOptions) (SiteCloneabilityResponse, error) {
	req, err := client.isCloneableCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SiteCloneabilityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteCloneabilityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteCloneabilityResponse{}, client.isCloneableHandleError(resp)
	}
	return client.isCloneableHandleResponse(resp)
}

// isCloneableCreateRequest creates the IsCloneable request.
func (client *WebAppsClient) isCloneableCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsIsCloneableOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// isCloneableHandleResponse handles the IsCloneable response.
func (client *WebAppsClient) isCloneableHandleResponse(resp *azcore.Response) (SiteCloneabilityResponse, error) {
	var val *SiteCloneability
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteCloneabilityResponse{}, err
	}
	return SiteCloneabilityResponse{RawResponse: resp.Response, SiteCloneability: val}, nil
}

// isCloneableHandleError handles the IsCloneable error response.
func (client *WebAppsClient) isCloneableHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// IsCloneableSlot - Description for Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) IsCloneableSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsIsCloneableSlotOptions) (SiteCloneabilityResponse, error) {
	req, err := client.isCloneableSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return SiteCloneabilityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteCloneabilityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteCloneabilityResponse{}, client.isCloneableSlotHandleError(resp)
	}
	return client.isCloneableSlotHandleResponse(resp)
}

// isCloneableSlotCreateRequest creates the IsCloneableSlot request.
func (client *WebAppsClient) isCloneableSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsIsCloneableSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// isCloneableSlotHandleResponse handles the IsCloneableSlot response.
func (client *WebAppsClient) isCloneableSlotHandleResponse(resp *azcore.Response) (SiteCloneabilityResponse, error) {
	var val *SiteCloneability
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteCloneabilityResponse{}, err
	}
	return SiteCloneabilityResponse{RawResponse: resp.Response, SiteCloneability: val}, nil
}

// isCloneableSlotHandleError handles the IsCloneableSlot error response.
func (client *WebAppsClient) isCloneableSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// List - Description for Get all apps for a subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) List(options *WebAppsListOptions) WebAppCollectionPager {
	return &webAppCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listCreateRequest(ctx, options)
		},
		responder: client.listHandleResponse,
		errorer:   client.listHandleError,
		advancer: func(ctx context.Context, resp WebAppCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listCreateRequest creates the List request.
func (client *WebAppsClient) listCreateRequest(ctx context.Context, options *WebAppsListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/sites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *WebAppsClient) listHandleResponse(resp *azcore.Response) (WebAppCollectionResponse, error) {
	var val *WebAppCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebAppCollectionResponse{}, err
	}
	return WebAppCollectionResponse{RawResponse: resp.Response, WebAppCollection: val}, nil
}

// listHandleError handles the List error response.
func (client *WebAppsClient) listHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListApplicationSettings - Description for Gets the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListApplicationSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsListApplicationSettingsOptions) (StringDictionaryResponse, error) {
	req, err := client.listApplicationSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.listApplicationSettingsHandleError(resp)
	}
	return client.listApplicationSettingsHandleResponse(resp)
}

// listApplicationSettingsCreateRequest creates the ListApplicationSettings request.
func (client *WebAppsClient) listApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListApplicationSettingsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listApplicationSettingsHandleResponse handles the ListApplicationSettings response.
func (client *WebAppsClient) listApplicationSettingsHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// listApplicationSettingsHandleError handles the ListApplicationSettings error response.
func (client *WebAppsClient) listApplicationSettingsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListApplicationSettingsSlot - Description for Gets the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListApplicationSettingsSlotOptions) (StringDictionaryResponse, error) {
	req, err := client.listApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.listApplicationSettingsSlotHandleError(resp)
	}
	return client.listApplicationSettingsSlotHandleResponse(resp)
}

// listApplicationSettingsSlotCreateRequest creates the ListApplicationSettingsSlot request.
func (client *WebAppsClient) listApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListApplicationSettingsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listApplicationSettingsSlotHandleResponse handles the ListApplicationSettingsSlot response.
func (client *WebAppsClient) listApplicationSettingsSlotHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// listApplicationSettingsSlotHandleError handles the ListApplicationSettingsSlot error response.
func (client *WebAppsClient) listApplicationSettingsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListAzureStorageAccounts - Description for Gets the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, options *WebAppsListAzureStorageAccountsOptions) (AzureStoragePropertyDictionaryResourceResponse, error) {
	req, err := client.listAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return AzureStoragePropertyDictionaryResourceResponse{}, client.listAzureStorageAccountsHandleError(resp)
	}
	return client.listAzureStorageAccountsHandleResponse(resp)
}

// listAzureStorageAccountsCreateRequest creates the ListAzureStorageAccounts request.
func (client *WebAppsClient) listAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListAzureStorageAccountsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAzureStorageAccountsHandleResponse handles the ListAzureStorageAccounts response.
func (client *WebAppsClient) listAzureStorageAccountsHandleResponse(resp *azcore.Response) (AzureStoragePropertyDictionaryResourceResponse, error) {
	var val *AzureStoragePropertyDictionaryResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	return AzureStoragePropertyDictionaryResourceResponse{RawResponse: resp.Response, AzureStoragePropertyDictionaryResource: val}, nil
}

// listAzureStorageAccountsHandleError handles the ListAzureStorageAccounts error response.
func (client *WebAppsClient) listAzureStorageAccountsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListAzureStorageAccountsSlot - Description for Gets the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListAzureStorageAccountsSlotOptions) (AzureStoragePropertyDictionaryResourceResponse, error) {
	req, err := client.listAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return AzureStoragePropertyDictionaryResourceResponse{}, client.listAzureStorageAccountsSlotHandleError(resp)
	}
	return client.listAzureStorageAccountsSlotHandleResponse(resp)
}

// listAzureStorageAccountsSlotCreateRequest creates the ListAzureStorageAccountsSlot request.
func (client *WebAppsClient) listAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListAzureStorageAccountsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAzureStorageAccountsSlotHandleResponse handles the ListAzureStorageAccountsSlot response.
func (client *WebAppsClient) listAzureStorageAccountsSlotHandleResponse(resp *azcore.Response) (AzureStoragePropertyDictionaryResourceResponse, error) {
	var val *AzureStoragePropertyDictionaryResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	return AzureStoragePropertyDictionaryResourceResponse{RawResponse: resp.Response, AzureStoragePropertyDictionaryResource: val}, nil
}

// listAzureStorageAccountsSlotHandleError handles the ListAzureStorageAccountsSlot error response.
func (client *WebAppsClient) listAzureStorageAccountsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListBackupStatusSecrets - Description for Gets status of a web app backup that may be in progress, including secrets associated with the backup, such
// as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
// backup if a new URL is passed in the request body.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackupStatusSecrets(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *WebAppsListBackupStatusSecretsOptions) (BackupItemResponse, error) {
	req, err := client.listBackupStatusSecretsCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return BackupItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupItemResponse{}, client.listBackupStatusSecretsHandleError(resp)
	}
	return client.listBackupStatusSecretsHandleResponse(resp)
}

// listBackupStatusSecretsCreateRequest creates the ListBackupStatusSecrets request.
func (client *WebAppsClient) listBackupStatusSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *WebAppsListBackupStatusSecretsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// listBackupStatusSecretsHandleResponse handles the ListBackupStatusSecrets response.
func (client *WebAppsClient) listBackupStatusSecretsHandleResponse(resp *azcore.Response) (BackupItemResponse, error) {
	var val *BackupItem
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemResponse{}, err
	}
	return BackupItemResponse{RawResponse: resp.Response, BackupItem: val}, nil
}

// listBackupStatusSecretsHandleError handles the ListBackupStatusSecrets error response.
func (client *WebAppsClient) listBackupStatusSecretsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListBackupStatusSecretsSlot - Description for Gets status of a web app backup that may be in progress, including secrets associated with the backup,
// such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
// backup if a new URL is passed in the request body.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackupStatusSecretsSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *WebAppsListBackupStatusSecretsSlotOptions) (BackupItemResponse, error) {
	req, err := client.listBackupStatusSecretsSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return BackupItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupItemResponse{}, client.listBackupStatusSecretsSlotHandleError(resp)
	}
	return client.listBackupStatusSecretsSlotHandleResponse(resp)
}

// listBackupStatusSecretsSlotCreateRequest creates the ListBackupStatusSecretsSlot request.
func (client *WebAppsClient) listBackupStatusSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *WebAppsListBackupStatusSecretsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// listBackupStatusSecretsSlotHandleResponse handles the ListBackupStatusSecretsSlot response.
func (client *WebAppsClient) listBackupStatusSecretsSlotHandleResponse(resp *azcore.Response) (BackupItemResponse, error) {
	var val *BackupItem
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemResponse{}, err
	}
	return BackupItemResponse{RawResponse: resp.Response, BackupItem: val}, nil
}

// listBackupStatusSecretsSlotHandleError handles the ListBackupStatusSecretsSlot error response.
func (client *WebAppsClient) listBackupStatusSecretsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListBackups - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackups(resourceGroupName string, name string, options *WebAppsListBackupsOptions) BackupItemCollectionPager {
	return &backupItemCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listBackupsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listBackupsHandleResponse,
		errorer:   client.listBackupsHandleError,
		advancer: func(ctx context.Context, resp BackupItemCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listBackupsCreateRequest creates the ListBackups request.
func (client *WebAppsClient) listBackupsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListBackupsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listBackupsHandleResponse handles the ListBackups response.
func (client *WebAppsClient) listBackupsHandleResponse(resp *azcore.Response) (BackupItemCollectionResponse, error) {
	var val *BackupItemCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemCollectionResponse{}, err
	}
	return BackupItemCollectionResponse{RawResponse: resp.Response, BackupItemCollection: val}, nil
}

// listBackupsHandleError handles the ListBackups error response.
func (client *WebAppsClient) listBackupsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListBackupsSlot - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackupsSlot(resourceGroupName string, name string, slot string, options *WebAppsListBackupsSlotOptions) BackupItemCollectionPager {
	return &backupItemCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listBackupsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listBackupsSlotHandleResponse,
		errorer:   client.listBackupsSlotHandleError,
		advancer: func(ctx context.Context, resp BackupItemCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listBackupsSlotCreateRequest creates the ListBackupsSlot request.
func (client *WebAppsClient) listBackupsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListBackupsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listBackupsSlotHandleResponse handles the ListBackupsSlot response.
func (client *WebAppsClient) listBackupsSlotHandleResponse(resp *azcore.Response) (BackupItemCollectionResponse, error) {
	var val *BackupItemCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemCollectionResponse{}, err
	}
	return BackupItemCollectionResponse{RawResponse: resp.Response, BackupItemCollection: val}, nil
}

// listBackupsSlotHandleError handles the ListBackupsSlot error response.
func (client *WebAppsClient) listBackupsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListBasicPublishingCredentialsPolicies - Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBasicPublishingCredentialsPolicies(resourceGroupName string, name string, options *WebAppsListBasicPublishingCredentialsPoliciesOptions) PublishingCredentialsPoliciesCollectionPager {
	return &publishingCredentialsPoliciesCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listBasicPublishingCredentialsPoliciesCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listBasicPublishingCredentialsPoliciesHandleResponse,
		errorer:   client.listBasicPublishingCredentialsPoliciesHandleError,
		advancer: func(ctx context.Context, resp PublishingCredentialsPoliciesCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PublishingCredentialsPoliciesCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listBasicPublishingCredentialsPoliciesCreateRequest creates the ListBasicPublishingCredentialsPolicies request.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListBasicPublishingCredentialsPoliciesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listBasicPublishingCredentialsPoliciesHandleResponse handles the ListBasicPublishingCredentialsPolicies response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesHandleResponse(resp *azcore.Response) (PublishingCredentialsPoliciesCollectionResponse, error) {
	var val *PublishingCredentialsPoliciesCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublishingCredentialsPoliciesCollectionResponse{}, err
	}
	return PublishingCredentialsPoliciesCollectionResponse{RawResponse: resp.Response, PublishingCredentialsPoliciesCollection: val}, nil
}

// listBasicPublishingCredentialsPoliciesHandleError handles the ListBasicPublishingCredentialsPolicies error response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListBasicPublishingCredentialsPoliciesSlot - Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBasicPublishingCredentialsPoliciesSlot(resourceGroupName string, name string, slot string, options *WebAppsListBasicPublishingCredentialsPoliciesSlotOptions) PublishingCredentialsPoliciesCollectionPager {
	return &publishingCredentialsPoliciesCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listBasicPublishingCredentialsPoliciesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listBasicPublishingCredentialsPoliciesSlotHandleResponse,
		errorer:   client.listBasicPublishingCredentialsPoliciesSlotHandleError,
		advancer: func(ctx context.Context, resp PublishingCredentialsPoliciesCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PublishingCredentialsPoliciesCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listBasicPublishingCredentialsPoliciesSlotCreateRequest creates the ListBasicPublishingCredentialsPoliciesSlot request.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListBasicPublishingCredentialsPoliciesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listBasicPublishingCredentialsPoliciesSlotHandleResponse handles the ListBasicPublishingCredentialsPoliciesSlot response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotHandleResponse(resp *azcore.Response) (PublishingCredentialsPoliciesCollectionResponse, error) {
	var val *PublishingCredentialsPoliciesCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublishingCredentialsPoliciesCollectionResponse{}, err
	}
	return PublishingCredentialsPoliciesCollectionResponse{RawResponse: resp.Response, PublishingCredentialsPoliciesCollection: val}, nil
}

// listBasicPublishingCredentialsPoliciesSlotHandleError handles the ListBasicPublishingCredentialsPoliciesSlot error response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListByResourceGroup - Description for Gets all web, mobile, and API apps in the specified resource group.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListByResourceGroup(resourceGroupName string, options *WebAppsListByResourceGroupOptions) WebAppCollectionPager {
	return &webAppCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		responder: client.listByResourceGroupHandleResponse,
		errorer:   client.listByResourceGroupHandleError,
		advancer: func(ctx context.Context, resp WebAppCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *WebAppsClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *WebAppsListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.IncludeSlots != nil {
		reqQP.Set("includeSlots", strconv.FormatBool(*options.IncludeSlots))
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *WebAppsClient) listByResourceGroupHandleResponse(resp *azcore.Response) (WebAppCollectionResponse, error) {
	var val *WebAppCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebAppCollectionResponse{}, err
	}
	return WebAppCollectionResponse{RawResponse: resp.Response, WebAppCollection: val}, nil
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *WebAppsClient) listByResourceGroupHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListConfigurationSnapshotInfo - Description for Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp
// and the ID of the snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurationSnapshotInfo(resourceGroupName string, name string, options *WebAppsListConfigurationSnapshotInfoOptions) SiteConfigurationSnapshotInfoCollectionPager {
	return &siteConfigurationSnapshotInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listConfigurationSnapshotInfoCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listConfigurationSnapshotInfoHandleResponse,
		errorer:   client.listConfigurationSnapshotInfoHandleError,
		advancer: func(ctx context.Context, resp SiteConfigurationSnapshotInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SiteConfigurationSnapshotInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listConfigurationSnapshotInfoCreateRequest creates the ListConfigurationSnapshotInfo request.
func (client *WebAppsClient) listConfigurationSnapshotInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConfigurationSnapshotInfoOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationSnapshotInfoHandleResponse handles the ListConfigurationSnapshotInfo response.
func (client *WebAppsClient) listConfigurationSnapshotInfoHandleResponse(resp *azcore.Response) (SiteConfigurationSnapshotInfoCollectionResponse, error) {
	var val *SiteConfigurationSnapshotInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigurationSnapshotInfoCollectionResponse{}, err
	}
	return SiteConfigurationSnapshotInfoCollectionResponse{RawResponse: resp.Response, SiteConfigurationSnapshotInfoCollection: val}, nil
}

// listConfigurationSnapshotInfoHandleError handles the ListConfigurationSnapshotInfo error response.
func (client *WebAppsClient) listConfigurationSnapshotInfoHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListConfigurationSnapshotInfoSlot - Description for Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp
// and the ID of the snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurationSnapshotInfoSlot(resourceGroupName string, name string, slot string, options *WebAppsListConfigurationSnapshotInfoSlotOptions) SiteConfigurationSnapshotInfoCollectionPager {
	return &siteConfigurationSnapshotInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listConfigurationSnapshotInfoSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listConfigurationSnapshotInfoSlotHandleResponse,
		errorer:   client.listConfigurationSnapshotInfoSlotHandleError,
		advancer: func(ctx context.Context, resp SiteConfigurationSnapshotInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SiteConfigurationSnapshotInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listConfigurationSnapshotInfoSlotCreateRequest creates the ListConfigurationSnapshotInfoSlot request.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConfigurationSnapshotInfoSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationSnapshotInfoSlotHandleResponse handles the ListConfigurationSnapshotInfoSlot response.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotHandleResponse(resp *azcore.Response) (SiteConfigurationSnapshotInfoCollectionResponse, error) {
	var val *SiteConfigurationSnapshotInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigurationSnapshotInfoCollectionResponse{}, err
	}
	return SiteConfigurationSnapshotInfoCollectionResponse{RawResponse: resp.Response, SiteConfigurationSnapshotInfoCollection: val}, nil
}

// listConfigurationSnapshotInfoSlotHandleError handles the ListConfigurationSnapshotInfoSlot error response.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListConfigurations - Description for List the configurations of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurations(resourceGroupName string, name string, options *WebAppsListConfigurationsOptions) SiteConfigResourceCollectionPager {
	return &siteConfigResourceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listConfigurationsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listConfigurationsHandleResponse,
		errorer:   client.listConfigurationsHandleError,
		advancer: func(ctx context.Context, resp SiteConfigResourceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SiteConfigResourceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listConfigurationsCreateRequest creates the ListConfigurations request.
func (client *WebAppsClient) listConfigurationsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConfigurationsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationsHandleResponse handles the ListConfigurations response.
func (client *WebAppsClient) listConfigurationsHandleResponse(resp *azcore.Response) (SiteConfigResourceCollectionResponse, error) {
	var val *SiteConfigResourceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceCollectionResponse{}, err
	}
	return SiteConfigResourceCollectionResponse{RawResponse: resp.Response, SiteConfigResourceCollection: val}, nil
}

// listConfigurationsHandleError handles the ListConfigurations error response.
func (client *WebAppsClient) listConfigurationsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListConfigurationsSlot - Description for List the configurations of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurationsSlot(resourceGroupName string, name string, slot string, options *WebAppsListConfigurationsSlotOptions) SiteConfigResourceCollectionPager {
	return &siteConfigResourceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listConfigurationsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listConfigurationsSlotHandleResponse,
		errorer:   client.listConfigurationsSlotHandleError,
		advancer: func(ctx context.Context, resp SiteConfigResourceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SiteConfigResourceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listConfigurationsSlotCreateRequest creates the ListConfigurationsSlot request.
func (client *WebAppsClient) listConfigurationsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConfigurationsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationsSlotHandleResponse handles the ListConfigurationsSlot response.
func (client *WebAppsClient) listConfigurationsSlotHandleResponse(resp *azcore.Response) (SiteConfigResourceCollectionResponse, error) {
	var val *SiteConfigResourceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceCollectionResponse{}, err
	}
	return SiteConfigResourceCollectionResponse{RawResponse: resp.Response, SiteConfigResourceCollection: val}, nil
}

// listConfigurationsSlotHandleError handles the ListConfigurationsSlot error response.
func (client *WebAppsClient) listConfigurationsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListConnectionStrings - Description for Gets the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConnectionStrings(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConnectionStringsOptions) (ConnectionStringDictionaryResponse, error) {
	req, err := client.listConnectionStringsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ConnectionStringDictionaryResponse{}, client.listConnectionStringsHandleError(resp)
	}
	return client.listConnectionStringsHandleResponse(resp)
}

// listConnectionStringsCreateRequest creates the ListConnectionStrings request.
func (client *WebAppsClient) listConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConnectionStringsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listConnectionStringsHandleResponse handles the ListConnectionStrings response.
func (client *WebAppsClient) listConnectionStringsHandleResponse(resp *azcore.Response) (ConnectionStringDictionaryResponse, error) {
	var val *ConnectionStringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	return ConnectionStringDictionaryResponse{RawResponse: resp.Response, ConnectionStringDictionary: val}, nil
}

// listConnectionStringsHandleError handles the ListConnectionStrings error response.
func (client *WebAppsClient) listConnectionStringsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListConnectionStringsSlot - Description for Gets the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConnectionStringsSlotOptions) (ConnectionStringDictionaryResponse, error) {
	req, err := client.listConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ConnectionStringDictionaryResponse{}, client.listConnectionStringsSlotHandleError(resp)
	}
	return client.listConnectionStringsSlotHandleResponse(resp)
}

// listConnectionStringsSlotCreateRequest creates the ListConnectionStringsSlot request.
func (client *WebAppsClient) listConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConnectionStringsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listConnectionStringsSlotHandleResponse handles the ListConnectionStringsSlot response.
func (client *WebAppsClient) listConnectionStringsSlotHandleResponse(resp *azcore.Response) (ConnectionStringDictionaryResponse, error) {
	var val *ConnectionStringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	return ConnectionStringDictionaryResponse{RawResponse: resp.Response, ConnectionStringDictionary: val}, nil
}

// listConnectionStringsSlotHandleError handles the ListConnectionStringsSlot error response.
func (client *WebAppsClient) listConnectionStringsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListContinuousWebJobs - Description for List continuous web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListContinuousWebJobs(resourceGroupName string, name string, options *WebAppsListContinuousWebJobsOptions) ContinuousWebJobCollectionPager {
	return &continuousWebJobCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listContinuousWebJobsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listContinuousWebJobsHandleResponse,
		errorer:   client.listContinuousWebJobsHandleError,
		advancer: func(ctx context.Context, resp ContinuousWebJobCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ContinuousWebJobCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listContinuousWebJobsCreateRequest creates the ListContinuousWebJobs request.
func (client *WebAppsClient) listContinuousWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListContinuousWebJobsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listContinuousWebJobsHandleResponse handles the ListContinuousWebJobs response.
func (client *WebAppsClient) listContinuousWebJobsHandleResponse(resp *azcore.Response) (ContinuousWebJobCollectionResponse, error) {
	var val *ContinuousWebJobCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ContinuousWebJobCollectionResponse{}, err
	}
	return ContinuousWebJobCollectionResponse{RawResponse: resp.Response, ContinuousWebJobCollection: val}, nil
}

// listContinuousWebJobsHandleError handles the ListContinuousWebJobs error response.
func (client *WebAppsClient) listContinuousWebJobsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListContinuousWebJobsSlot - Description for List continuous web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListContinuousWebJobsSlot(resourceGroupName string, name string, slot string, options *WebAppsListContinuousWebJobsSlotOptions) ContinuousWebJobCollectionPager {
	return &continuousWebJobCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listContinuousWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listContinuousWebJobsSlotHandleResponse,
		errorer:   client.listContinuousWebJobsSlotHandleError,
		advancer: func(ctx context.Context, resp ContinuousWebJobCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ContinuousWebJobCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listContinuousWebJobsSlotCreateRequest creates the ListContinuousWebJobsSlot request.
func (client *WebAppsClient) listContinuousWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListContinuousWebJobsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listContinuousWebJobsSlotHandleResponse handles the ListContinuousWebJobsSlot response.
func (client *WebAppsClient) listContinuousWebJobsSlotHandleResponse(resp *azcore.Response) (ContinuousWebJobCollectionResponse, error) {
	var val *ContinuousWebJobCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ContinuousWebJobCollectionResponse{}, err
	}
	return ContinuousWebJobCollectionResponse{RawResponse: resp.Response, ContinuousWebJobCollection: val}, nil
}

// listContinuousWebJobsSlotHandleError handles the ListContinuousWebJobsSlot error response.
func (client *WebAppsClient) listContinuousWebJobsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListDeploymentLog - Description for List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeploymentLog(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsListDeploymentLogOptions) (DeploymentResponse, error) {
	req, err := client.listDeploymentLogCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return DeploymentResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentResponse{}, client.listDeploymentLogHandleError(resp)
	}
	return client.listDeploymentLogHandleResponse(resp)
}

// listDeploymentLogCreateRequest creates the ListDeploymentLog request.
func (client *WebAppsClient) listDeploymentLogCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsListDeploymentLogOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentLogHandleResponse handles the ListDeploymentLog response.
func (client *WebAppsClient) listDeploymentLogHandleResponse(resp *azcore.Response) (DeploymentResponse, error) {
	var val *Deployment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentResponse{}, err
	}
	return DeploymentResponse{RawResponse: resp.Response, Deployment: val}, nil
}

// listDeploymentLogHandleError handles the ListDeploymentLog error response.
func (client *WebAppsClient) listDeploymentLogHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListDeploymentLogSlot - Description for List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeploymentLogSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsListDeploymentLogSlotOptions) (DeploymentResponse, error) {
	req, err := client.listDeploymentLogSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return DeploymentResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentResponse{}, client.listDeploymentLogSlotHandleError(resp)
	}
	return client.listDeploymentLogSlotHandleResponse(resp)
}

// listDeploymentLogSlotCreateRequest creates the ListDeploymentLogSlot request.
func (client *WebAppsClient) listDeploymentLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsListDeploymentLogSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentLogSlotHandleResponse handles the ListDeploymentLogSlot response.
func (client *WebAppsClient) listDeploymentLogSlotHandleResponse(resp *azcore.Response) (DeploymentResponse, error) {
	var val *Deployment
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentResponse{}, err
	}
	return DeploymentResponse{RawResponse: resp.Response, Deployment: val}, nil
}

// listDeploymentLogSlotHandleError handles the ListDeploymentLogSlot error response.
func (client *WebAppsClient) listDeploymentLogSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListDeployments - Description for List deployments for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeployments(resourceGroupName string, name string, options *WebAppsListDeploymentsOptions) DeploymentCollectionPager {
	return &deploymentCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listDeploymentsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listDeploymentsHandleResponse,
		errorer:   client.listDeploymentsHandleError,
		advancer: func(ctx context.Context, resp DeploymentCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listDeploymentsCreateRequest creates the ListDeployments request.
func (client *WebAppsClient) listDeploymentsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListDeploymentsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsHandleResponse handles the ListDeployments response.
func (client *WebAppsClient) listDeploymentsHandleResponse(resp *azcore.Response) (DeploymentCollectionResponse, error) {
	var val *DeploymentCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentCollectionResponse{}, err
	}
	return DeploymentCollectionResponse{RawResponse: resp.Response, DeploymentCollection: val}, nil
}

// listDeploymentsHandleError handles the ListDeployments error response.
func (client *WebAppsClient) listDeploymentsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListDeploymentsSlot - Description for List deployments for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeploymentsSlot(resourceGroupName string, name string, slot string, options *WebAppsListDeploymentsSlotOptions) DeploymentCollectionPager {
	return &deploymentCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listDeploymentsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listDeploymentsSlotHandleResponse,
		errorer:   client.listDeploymentsSlotHandleError,
		advancer: func(ctx context.Context, resp DeploymentCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listDeploymentsSlotCreateRequest creates the ListDeploymentsSlot request.
func (client *WebAppsClient) listDeploymentsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListDeploymentsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsSlotHandleResponse handles the ListDeploymentsSlot response.
func (client *WebAppsClient) listDeploymentsSlotHandleResponse(resp *azcore.Response) (DeploymentCollectionResponse, error) {
	var val *DeploymentCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentCollectionResponse{}, err
	}
	return DeploymentCollectionResponse{RawResponse: resp.Response, DeploymentCollection: val}, nil
}

// listDeploymentsSlotHandleError handles the ListDeploymentsSlot error response.
func (client *WebAppsClient) listDeploymentsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListDomainOwnershipIdentifiers - Description for Lists ownership identifiers for domain associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDomainOwnershipIdentifiers(resourceGroupName string, name string, options *WebAppsListDomainOwnershipIdentifiersOptions) IdentifierCollectionPager {
	return &identifierCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listDomainOwnershipIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listDomainOwnershipIdentifiersHandleResponse,
		errorer:   client.listDomainOwnershipIdentifiersHandleError,
		advancer: func(ctx context.Context, resp IdentifierCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.IdentifierCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listDomainOwnershipIdentifiersCreateRequest creates the ListDomainOwnershipIdentifiers request.
func (client *WebAppsClient) listDomainOwnershipIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListDomainOwnershipIdentifiersOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listDomainOwnershipIdentifiersHandleResponse handles the ListDomainOwnershipIdentifiers response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersHandleResponse(resp *azcore.Response) (IdentifierCollectionResponse, error) {
	var val *IdentifierCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierCollectionResponse{}, err
	}
	return IdentifierCollectionResponse{RawResponse: resp.Response, IdentifierCollection: val}, nil
}

// listDomainOwnershipIdentifiersHandleError handles the ListDomainOwnershipIdentifiers error response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListDomainOwnershipIdentifiersSlot - Description for Lists ownership identifiers for domain associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDomainOwnershipIdentifiersSlot(resourceGroupName string, name string, slot string, options *WebAppsListDomainOwnershipIdentifiersSlotOptions) IdentifierCollectionPager {
	return &identifierCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listDomainOwnershipIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listDomainOwnershipIdentifiersSlotHandleResponse,
		errorer:   client.listDomainOwnershipIdentifiersSlotHandleError,
		advancer: func(ctx context.Context, resp IdentifierCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.IdentifierCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listDomainOwnershipIdentifiersSlotCreateRequest creates the ListDomainOwnershipIdentifiersSlot request.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListDomainOwnershipIdentifiersSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listDomainOwnershipIdentifiersSlotHandleResponse handles the ListDomainOwnershipIdentifiersSlot response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotHandleResponse(resp *azcore.Response) (IdentifierCollectionResponse, error) {
	var val *IdentifierCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierCollectionResponse{}, err
	}
	return IdentifierCollectionResponse{RawResponse: resp.Response, IdentifierCollection: val}, nil
}

// listDomainOwnershipIdentifiersSlotHandleError handles the ListDomainOwnershipIdentifiersSlot error response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListFunctionKeys - Description for Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionKeys(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionKeysOptions) (StringDictionaryResponse, error) {
	req, err := client.listFunctionKeysCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.listFunctionKeysHandleError(resp)
	}
	return client.listFunctionKeysHandleResponse(resp)
}

// listFunctionKeysCreateRequest creates the ListFunctionKeys request.
func (client *WebAppsClient) listFunctionKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionKeysHandleResponse handles the ListFunctionKeys response.
func (client *WebAppsClient) listFunctionKeysHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// listFunctionKeysHandleError handles the ListFunctionKeys error response.
func (client *WebAppsClient) listFunctionKeysHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListFunctionKeysSlot - Description for Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionKeysSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionKeysSlotOptions) (StringDictionaryResponse, error) {
	req, err := client.listFunctionKeysSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.listFunctionKeysSlotHandleError(resp)
	}
	return client.listFunctionKeysSlotHandleResponse(resp)
}

// listFunctionKeysSlotCreateRequest creates the ListFunctionKeysSlot request.
func (client *WebAppsClient) listFunctionKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionKeysSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionKeysSlotHandleResponse handles the ListFunctionKeysSlot response.
func (client *WebAppsClient) listFunctionKeysSlotHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// listFunctionKeysSlotHandleError handles the ListFunctionKeysSlot error response.
func (client *WebAppsClient) listFunctionKeysSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListFunctionSecrets - Description for Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionSecrets(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionSecretsOptions) (FunctionSecretsResponse, error) {
	req, err := client.listFunctionSecretsCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FunctionSecretsResponse{}, client.listFunctionSecretsHandleError(resp)
	}
	return client.listFunctionSecretsHandleResponse(resp)
}

// listFunctionSecretsCreateRequest creates the ListFunctionSecrets request.
func (client *WebAppsClient) listFunctionSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionSecretsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionSecretsHandleResponse handles the ListFunctionSecrets response.
func (client *WebAppsClient) listFunctionSecretsHandleResponse(resp *azcore.Response) (FunctionSecretsResponse, error) {
	var val *FunctionSecrets
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionSecretsResponse{}, err
	}
	return FunctionSecretsResponse{RawResponse: resp.Response, FunctionSecrets: val}, nil
}

// listFunctionSecretsHandleError handles the ListFunctionSecrets error response.
func (client *WebAppsClient) listFunctionSecretsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListFunctionSecretsSlot - Description for Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionSecretsSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionSecretsSlotOptions) (FunctionSecretsResponse, error) {
	req, err := client.listFunctionSecretsSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FunctionSecretsResponse{}, client.listFunctionSecretsSlotHandleError(resp)
	}
	return client.listFunctionSecretsSlotHandleResponse(resp)
}

// listFunctionSecretsSlotCreateRequest creates the ListFunctionSecretsSlot request.
func (client *WebAppsClient) listFunctionSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionSecretsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionSecretsSlotHandleResponse handles the ListFunctionSecretsSlot response.
func (client *WebAppsClient) listFunctionSecretsSlotHandleResponse(resp *azcore.Response) (FunctionSecretsResponse, error) {
	var val *FunctionSecrets
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionSecretsResponse{}, err
	}
	return FunctionSecretsResponse{RawResponse: resp.Response, FunctionSecrets: val}, nil
}

// listFunctionSecretsSlotHandleError handles the ListFunctionSecretsSlot error response.
func (client *WebAppsClient) listFunctionSecretsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListFunctions - Description for List the functions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctions(resourceGroupName string, name string, options *WebAppsListFunctionsOptions) FunctionEnvelopeCollectionPager {
	return &functionEnvelopeCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listFunctionsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listFunctionsHandleResponse,
		errorer:   client.listFunctionsHandleError,
		advancer: func(ctx context.Context, resp FunctionEnvelopeCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.FunctionEnvelopeCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listFunctionsCreateRequest creates the ListFunctions request.
func (client *WebAppsClient) listFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListFunctionsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionsHandleResponse handles the ListFunctions response.
func (client *WebAppsClient) listFunctionsHandleResponse(resp *azcore.Response) (FunctionEnvelopeCollectionResponse, error) {
	var val *FunctionEnvelopeCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionEnvelopeCollectionResponse{}, err
	}
	return FunctionEnvelopeCollectionResponse{RawResponse: resp.Response, FunctionEnvelopeCollection: val}, nil
}

// listFunctionsHandleError handles the ListFunctions error response.
func (client *WebAppsClient) listFunctionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListHostKeys - Description for Get host secrets for a function app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostKeys(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHostKeysOptions) (HostKeysResponse, error) {
	req, err := client.listHostKeysCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return HostKeysResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HostKeysResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HostKeysResponse{}, client.listHostKeysHandleError(resp)
	}
	return client.listHostKeysHandleResponse(resp)
}

// listHostKeysCreateRequest creates the ListHostKeys request.
func (client *WebAppsClient) listHostKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHostKeysOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listHostKeysHandleResponse handles the ListHostKeys response.
func (client *WebAppsClient) listHostKeysHandleResponse(resp *azcore.Response) (HostKeysResponse, error) {
	var val *HostKeys
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostKeysResponse{}, err
	}
	return HostKeysResponse{RawResponse: resp.Response, HostKeys: val}, nil
}

// listHostKeysHandleError handles the ListHostKeys error response.
func (client *WebAppsClient) listHostKeysHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListHostKeysSlot - Description for Get host secrets for a function app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostKeysSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHostKeysSlotOptions) (HostKeysResponse, error) {
	req, err := client.listHostKeysSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return HostKeysResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HostKeysResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HostKeysResponse{}, client.listHostKeysSlotHandleError(resp)
	}
	return client.listHostKeysSlotHandleResponse(resp)
}

// listHostKeysSlotCreateRequest creates the ListHostKeysSlot request.
func (client *WebAppsClient) listHostKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHostKeysSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listHostKeysSlotHandleResponse handles the ListHostKeysSlot response.
func (client *WebAppsClient) listHostKeysSlotHandleResponse(resp *azcore.Response) (HostKeysResponse, error) {
	var val *HostKeys
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostKeysResponse{}, err
	}
	return HostKeysResponse{RawResponse: resp.Response, HostKeys: val}, nil
}

// listHostKeysSlotHandleError handles the ListHostKeysSlot error response.
func (client *WebAppsClient) listHostKeysSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListHostNameBindings - Description for Get hostname bindings for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostNameBindings(resourceGroupName string, name string, options *WebAppsListHostNameBindingsOptions) HostNameBindingCollectionPager {
	return &hostNameBindingCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listHostNameBindingsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listHostNameBindingsHandleResponse,
		errorer:   client.listHostNameBindingsHandleError,
		advancer: func(ctx context.Context, resp HostNameBindingCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.HostNameBindingCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listHostNameBindingsCreateRequest creates the ListHostNameBindings request.
func (client *WebAppsClient) listHostNameBindingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHostNameBindingsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listHostNameBindingsHandleResponse handles the ListHostNameBindings response.
func (client *WebAppsClient) listHostNameBindingsHandleResponse(resp *azcore.Response) (HostNameBindingCollectionResponse, error) {
	var val *HostNameBindingCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostNameBindingCollectionResponse{}, err
	}
	return HostNameBindingCollectionResponse{RawResponse: resp.Response, HostNameBindingCollection: val}, nil
}

// listHostNameBindingsHandleError handles the ListHostNameBindings error response.
func (client *WebAppsClient) listHostNameBindingsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListHostNameBindingsSlot - Description for Get hostname bindings for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostNameBindingsSlot(resourceGroupName string, name string, slot string, options *WebAppsListHostNameBindingsSlotOptions) HostNameBindingCollectionPager {
	return &hostNameBindingCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listHostNameBindingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listHostNameBindingsSlotHandleResponse,
		errorer:   client.listHostNameBindingsSlotHandleError,
		advancer: func(ctx context.Context, resp HostNameBindingCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.HostNameBindingCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listHostNameBindingsSlotCreateRequest creates the ListHostNameBindingsSlot request.
func (client *WebAppsClient) listHostNameBindingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHostNameBindingsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listHostNameBindingsSlotHandleResponse handles the ListHostNameBindingsSlot response.
func (client *WebAppsClient) listHostNameBindingsSlotHandleResponse(resp *azcore.Response) (HostNameBindingCollectionResponse, error) {
	var val *HostNameBindingCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HostNameBindingCollectionResponse{}, err
	}
	return HostNameBindingCollectionResponse{RawResponse: resp.Response, HostNameBindingCollection: val}, nil
}

// listHostNameBindingsSlotHandleError handles the ListHostNameBindingsSlot error response.
func (client *WebAppsClient) listHostNameBindingsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListHybridConnections - Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHybridConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHybridConnectionsOptions) (HybridConnectionResponse, error) {
	req, err := client.listHybridConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.listHybridConnectionsHandleError(resp)
	}
	return client.listHybridConnectionsHandleResponse(resp)
}

// listHybridConnectionsCreateRequest creates the ListHybridConnections request.
func (client *WebAppsClient) listHybridConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHybridConnectionsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listHybridConnectionsHandleResponse handles the ListHybridConnections response.
func (client *WebAppsClient) listHybridConnectionsHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// listHybridConnectionsHandleError handles the ListHybridConnections error response.
func (client *WebAppsClient) listHybridConnectionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListHybridConnectionsSlot - Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHybridConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHybridConnectionsSlotOptions) (HybridConnectionResponse, error) {
	req, err := client.listHybridConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.listHybridConnectionsSlotHandleError(resp)
	}
	return client.listHybridConnectionsSlotHandleResponse(resp)
}

// listHybridConnectionsSlotCreateRequest creates the ListHybridConnectionsSlot request.
func (client *WebAppsClient) listHybridConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHybridConnectionsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listHybridConnectionsSlotHandleResponse handles the ListHybridConnectionsSlot response.
func (client *WebAppsClient) listHybridConnectionsSlotHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// listHybridConnectionsSlotHandleError handles the ListHybridConnectionsSlot error response.
func (client *WebAppsClient) listHybridConnectionsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListInstanceFunctionsSlot - Description for List the functions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceFunctionsSlot(resourceGroupName string, name string, slot string, options *WebAppsListInstanceFunctionsSlotOptions) FunctionEnvelopeCollectionPager {
	return &functionEnvelopeCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listInstanceFunctionsSlotHandleResponse,
		errorer:   client.listInstanceFunctionsSlotHandleError,
		advancer: func(ctx context.Context, resp FunctionEnvelopeCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.FunctionEnvelopeCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceFunctionsSlotCreateRequest creates the ListInstanceFunctionsSlot request.
func (client *WebAppsClient) listInstanceFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListInstanceFunctionsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceFunctionsSlotHandleResponse handles the ListInstanceFunctionsSlot response.
func (client *WebAppsClient) listInstanceFunctionsSlotHandleResponse(resp *azcore.Response) (FunctionEnvelopeCollectionResponse, error) {
	var val *FunctionEnvelopeCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionEnvelopeCollectionResponse{}, err
	}
	return FunctionEnvelopeCollectionResponse{RawResponse: resp.Response, FunctionEnvelopeCollection: val}, nil
}

// listInstanceFunctionsSlotHandleError handles the ListInstanceFunctionsSlot error response.
func (client *WebAppsClient) listInstanceFunctionsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListInstanceIdentifiers - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceIdentifiers(resourceGroupName string, name string, options *WebAppsListInstanceIdentifiersOptions) WebAppInstanceStatusCollectionPager {
	return &webAppInstanceStatusCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listInstanceIdentifiersHandleResponse,
		errorer:   client.listInstanceIdentifiersHandleError,
		advancer: func(ctx context.Context, resp WebAppInstanceStatusCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WebAppInstanceStatusCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceIdentifiersCreateRequest creates the ListInstanceIdentifiers request.
func (client *WebAppsClient) listInstanceIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListInstanceIdentifiersOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceIdentifiersHandleResponse handles the ListInstanceIdentifiers response.
func (client *WebAppsClient) listInstanceIdentifiersHandleResponse(resp *azcore.Response) (WebAppInstanceStatusCollectionResponse, error) {
	var val *WebAppInstanceStatusCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebAppInstanceStatusCollectionResponse{}, err
	}
	return WebAppInstanceStatusCollectionResponse{RawResponse: resp.Response, WebAppInstanceStatusCollection: val}, nil
}

// listInstanceIdentifiersHandleError handles the ListInstanceIdentifiers error response.
func (client *WebAppsClient) listInstanceIdentifiersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListInstanceIdentifiersSlot - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceIdentifiersSlot(resourceGroupName string, name string, slot string, options *WebAppsListInstanceIdentifiersSlotOptions) WebAppInstanceStatusCollectionPager {
	return &webAppInstanceStatusCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listInstanceIdentifiersSlotHandleResponse,
		errorer:   client.listInstanceIdentifiersSlotHandleError,
		advancer: func(ctx context.Context, resp WebAppInstanceStatusCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WebAppInstanceStatusCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceIdentifiersSlotCreateRequest creates the ListInstanceIdentifiersSlot request.
func (client *WebAppsClient) listInstanceIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListInstanceIdentifiersSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceIdentifiersSlotHandleResponse handles the ListInstanceIdentifiersSlot response.
func (client *WebAppsClient) listInstanceIdentifiersSlotHandleResponse(resp *azcore.Response) (WebAppInstanceStatusCollectionResponse, error) {
	var val *WebAppInstanceStatusCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebAppInstanceStatusCollectionResponse{}, err
	}
	return WebAppInstanceStatusCollectionResponse{RawResponse: resp.Response, WebAppInstanceStatusCollection: val}, nil
}

// listInstanceIdentifiersSlotHandleError handles the ListInstanceIdentifiersSlot error response.
func (client *WebAppsClient) listInstanceIdentifiersSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListInstanceProcessModules - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessModules(resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessModulesOptions) ProcessModuleInfoCollectionPager {
	return &processModuleInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
		},
		responder: client.listInstanceProcessModulesHandleResponse,
		errorer:   client.listInstanceProcessModulesHandleError,
		advancer: func(ctx context.Context, resp ProcessModuleInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceProcessModulesCreateRequest creates the ListInstanceProcessModules request.
func (client *WebAppsClient) listInstanceProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessModulesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessModulesHandleResponse handles the ListInstanceProcessModules response.
func (client *WebAppsClient) listInstanceProcessModulesHandleResponse(resp *azcore.Response) (ProcessModuleInfoCollectionResponse, error) {
	var val *ProcessModuleInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoCollectionResponse{}, err
	}
	return ProcessModuleInfoCollectionResponse{RawResponse: resp.Response, ProcessModuleInfoCollection: val}, nil
}

// listInstanceProcessModulesHandleError handles the ListInstanceProcessModules error response.
func (client *WebAppsClient) listInstanceProcessModulesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListInstanceProcessModulesSlot - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessModulesSlot(resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessModulesSlotOptions) ProcessModuleInfoCollectionPager {
	return &processModuleInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
		},
		responder: client.listInstanceProcessModulesSlotHandleResponse,
		errorer:   client.listInstanceProcessModulesSlotHandleError,
		advancer: func(ctx context.Context, resp ProcessModuleInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceProcessModulesSlotCreateRequest creates the ListInstanceProcessModulesSlot request.
func (client *WebAppsClient) listInstanceProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessModulesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessModulesSlotHandleResponse handles the ListInstanceProcessModulesSlot response.
func (client *WebAppsClient) listInstanceProcessModulesSlotHandleResponse(resp *azcore.Response) (ProcessModuleInfoCollectionResponse, error) {
	var val *ProcessModuleInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoCollectionResponse{}, err
	}
	return ProcessModuleInfoCollectionResponse{RawResponse: resp.Response, ProcessModuleInfoCollection: val}, nil
}

// listInstanceProcessModulesSlotHandleError handles the ListInstanceProcessModulesSlot error response.
func (client *WebAppsClient) listInstanceProcessModulesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListInstanceProcessThreads - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessThreads(resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessThreadsOptions) ProcessThreadInfoCollectionPager {
	return &processThreadInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
		},
		responder: client.listInstanceProcessThreadsHandleResponse,
		errorer:   client.listInstanceProcessThreadsHandleError,
		advancer: func(ctx context.Context, resp ProcessThreadInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceProcessThreadsCreateRequest creates the ListInstanceProcessThreads request.
func (client *WebAppsClient) listInstanceProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessThreadsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessThreadsHandleResponse handles the ListInstanceProcessThreads response.
func (client *WebAppsClient) listInstanceProcessThreadsHandleResponse(resp *azcore.Response) (ProcessThreadInfoCollectionResponse, error) {
	var val *ProcessThreadInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessThreadInfoCollectionResponse{}, err
	}
	return ProcessThreadInfoCollectionResponse{RawResponse: resp.Response, ProcessThreadInfoCollection: val}, nil
}

// listInstanceProcessThreadsHandleError handles the ListInstanceProcessThreads error response.
func (client *WebAppsClient) listInstanceProcessThreadsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListInstanceProcessThreadsSlot - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessThreadsSlot(resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessThreadsSlotOptions) ProcessThreadInfoCollectionPager {
	return &processThreadInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
		},
		responder: client.listInstanceProcessThreadsSlotHandleResponse,
		errorer:   client.listInstanceProcessThreadsSlotHandleError,
		advancer: func(ctx context.Context, resp ProcessThreadInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceProcessThreadsSlotCreateRequest creates the ListInstanceProcessThreadsSlot request.
func (client *WebAppsClient) listInstanceProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessThreadsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessThreadsSlotHandleResponse handles the ListInstanceProcessThreadsSlot response.
func (client *WebAppsClient) listInstanceProcessThreadsSlotHandleResponse(resp *azcore.Response) (ProcessThreadInfoCollectionResponse, error) {
	var val *ProcessThreadInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessThreadInfoCollectionResponse{}, err
	}
	return ProcessThreadInfoCollectionResponse{RawResponse: resp.Response, ProcessThreadInfoCollection: val}, nil
}

// listInstanceProcessThreadsSlotHandleError handles the ListInstanceProcessThreadsSlot error response.
func (client *WebAppsClient) listInstanceProcessThreadsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListInstanceProcesses - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcesses(resourceGroupName string, name string, instanceID string, options *WebAppsListInstanceProcessesOptions) ProcessInfoCollectionPager {
	return &processInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceProcessesCreateRequest(ctx, resourceGroupName, name, instanceID, options)
		},
		responder: client.listInstanceProcessesHandleResponse,
		errorer:   client.listInstanceProcessesHandleError,
		advancer: func(ctx context.Context, resp ProcessInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceProcessesCreateRequest creates the ListInstanceProcesses request.
func (client *WebAppsClient) listInstanceProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsListInstanceProcessesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessesHandleResponse handles the ListInstanceProcesses response.
func (client *WebAppsClient) listInstanceProcessesHandleResponse(resp *azcore.Response) (ProcessInfoCollectionResponse, error) {
	var val *ProcessInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoCollectionResponse{}, err
	}
	return ProcessInfoCollectionResponse{RawResponse: resp.Response, ProcessInfoCollection: val}, nil
}

// listInstanceProcessesHandleError handles the ListInstanceProcesses error response.
func (client *WebAppsClient) listInstanceProcessesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListInstanceProcessesSlot - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web
// site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessesSlot(resourceGroupName string, name string, slot string, instanceID string, options *WebAppsListInstanceProcessesSlotOptions) ProcessInfoCollectionPager {
	return &processInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listInstanceProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
		},
		responder: client.listInstanceProcessesSlotHandleResponse,
		errorer:   client.listInstanceProcessesSlotHandleError,
		advancer: func(ctx context.Context, resp ProcessInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listInstanceProcessesSlotCreateRequest creates the ListInstanceProcessesSlot request.
func (client *WebAppsClient) listInstanceProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsListInstanceProcessesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessesSlotHandleResponse handles the ListInstanceProcessesSlot response.
func (client *WebAppsClient) listInstanceProcessesSlotHandleResponse(resp *azcore.Response) (ProcessInfoCollectionResponse, error) {
	var val *ProcessInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoCollectionResponse{}, err
	}
	return ProcessInfoCollectionResponse{RawResponse: resp.Response, ProcessInfoCollection: val}, nil
}

// listInstanceProcessesSlotHandleError handles the ListInstanceProcessesSlot error response.
func (client *WebAppsClient) listInstanceProcessesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListMetadata - Description for Gets the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListMetadata(ctx context.Context, resourceGroupName string, name string, options *WebAppsListMetadataOptions) (StringDictionaryResponse, error) {
	req, err := client.listMetadataCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.listMetadataHandleError(resp)
	}
	return client.listMetadataHandleResponse(resp)
}

// listMetadataCreateRequest creates the ListMetadata request.
func (client *WebAppsClient) listMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListMetadataOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listMetadataHandleResponse handles the ListMetadata response.
func (client *WebAppsClient) listMetadataHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// listMetadataHandleError handles the ListMetadata error response.
func (client *WebAppsClient) listMetadataHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListMetadataSlot - Description for Gets the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListMetadataSlotOptions) (StringDictionaryResponse, error) {
	req, err := client.listMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.listMetadataSlotHandleError(resp)
	}
	return client.listMetadataSlotHandleResponse(resp)
}

// listMetadataSlotCreateRequest creates the ListMetadataSlot request.
func (client *WebAppsClient) listMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListMetadataSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listMetadataSlotHandleResponse handles the ListMetadataSlot response.
func (client *WebAppsClient) listMetadataSlotHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// listMetadataSlotHandleError handles the ListMetadataSlot error response.
func (client *WebAppsClient) listMetadataSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListNetworkFeatures - Description for Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListNetworkFeatures(ctx context.Context, resourceGroupName string, name string, view string, options *WebAppsListNetworkFeaturesOptions) (NetworkFeaturesResponse, error) {
	req, err := client.listNetworkFeaturesCreateRequest(ctx, resourceGroupName, name, view, options)
	if err != nil {
		return NetworkFeaturesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkFeaturesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return NetworkFeaturesResponse{}, client.listNetworkFeaturesHandleError(resp)
	}
	return client.listNetworkFeaturesHandleResponse(resp)
}

// listNetworkFeaturesCreateRequest creates the ListNetworkFeatures request.
func (client *WebAppsClient) listNetworkFeaturesCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, options *WebAppsListNetworkFeaturesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listNetworkFeaturesHandleResponse handles the ListNetworkFeatures response.
func (client *WebAppsClient) listNetworkFeaturesHandleResponse(resp *azcore.Response) (NetworkFeaturesResponse, error) {
	var val *NetworkFeatures
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkFeaturesResponse{}, err
	}
	return NetworkFeaturesResponse{RawResponse: resp.Response, NetworkFeatures: val}, nil
}

// listNetworkFeaturesHandleError handles the ListNetworkFeatures error response.
func (client *WebAppsClient) listNetworkFeaturesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListNetworkFeaturesSlot - Description for Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListNetworkFeaturesSlot(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *WebAppsListNetworkFeaturesSlotOptions) (NetworkFeaturesResponse, error) {
	req, err := client.listNetworkFeaturesSlotCreateRequest(ctx, resourceGroupName, name, view, slot, options)
	if err != nil {
		return NetworkFeaturesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return NetworkFeaturesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return NetworkFeaturesResponse{}, client.listNetworkFeaturesSlotHandleError(resp)
	}
	return client.listNetworkFeaturesSlotHandleResponse(resp)
}

// listNetworkFeaturesSlotCreateRequest creates the ListNetworkFeaturesSlot request.
func (client *WebAppsClient) listNetworkFeaturesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *WebAppsListNetworkFeaturesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listNetworkFeaturesSlotHandleResponse handles the ListNetworkFeaturesSlot response.
func (client *WebAppsClient) listNetworkFeaturesSlotHandleResponse(resp *azcore.Response) (NetworkFeaturesResponse, error) {
	var val *NetworkFeatures
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return NetworkFeaturesResponse{}, err
	}
	return NetworkFeaturesResponse{RawResponse: resp.Response, NetworkFeatures: val}, nil
}

// listNetworkFeaturesSlotHandleError handles the ListNetworkFeaturesSlot error response.
func (client *WebAppsClient) listNetworkFeaturesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListPerfMonCounters - Description for Gets perfmon counters for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPerfMonCounters(resourceGroupName string, name string, options *WebAppsListPerfMonCountersOptions) PerfMonCounterCollectionPager {
	return &perfMonCounterCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listPerfMonCountersCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listPerfMonCountersHandleResponse,
		errorer:   client.listPerfMonCountersHandleError,
		advancer: func(ctx context.Context, resp PerfMonCounterCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PerfMonCounterCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listPerfMonCountersCreateRequest creates the ListPerfMonCounters request.
func (client *WebAppsClient) listPerfMonCountersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPerfMonCountersOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPerfMonCountersHandleResponse handles the ListPerfMonCounters response.
func (client *WebAppsClient) listPerfMonCountersHandleResponse(resp *azcore.Response) (PerfMonCounterCollectionResponse, error) {
	var val *PerfMonCounterCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PerfMonCounterCollectionResponse{}, err
	}
	return PerfMonCounterCollectionResponse{RawResponse: resp.Response, PerfMonCounterCollection: val}, nil
}

// listPerfMonCountersHandleError handles the ListPerfMonCounters error response.
func (client *WebAppsClient) listPerfMonCountersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPerfMonCountersSlot - Description for Gets perfmon counters for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPerfMonCountersSlot(resourceGroupName string, name string, slot string, options *WebAppsListPerfMonCountersSlotOptions) PerfMonCounterCollectionPager {
	return &perfMonCounterCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listPerfMonCountersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listPerfMonCountersSlotHandleResponse,
		errorer:   client.listPerfMonCountersSlotHandleError,
		advancer: func(ctx context.Context, resp PerfMonCounterCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PerfMonCounterCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listPerfMonCountersSlotCreateRequest creates the ListPerfMonCountersSlot request.
func (client *WebAppsClient) listPerfMonCountersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPerfMonCountersSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPerfMonCountersSlotHandleResponse handles the ListPerfMonCountersSlot response.
func (client *WebAppsClient) listPerfMonCountersSlotHandleResponse(resp *azcore.Response) (PerfMonCounterCollectionResponse, error) {
	var val *PerfMonCounterCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PerfMonCounterCollectionResponse{}, err
	}
	return PerfMonCounterCollectionResponse{RawResponse: resp.Response, PerfMonCounterCollection: val}, nil
}

// listPerfMonCountersSlotHandleError handles the ListPerfMonCountersSlot error response.
func (client *WebAppsClient) listPerfMonCountersSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPremierAddOns - Description for Gets the premier add-ons of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPremierAddOns(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPremierAddOnsOptions) (PremierAddOnResponse, error) {
	req, err := client.listPremierAddOnsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.listPremierAddOnsHandleError(resp)
	}
	return client.listPremierAddOnsHandleResponse(resp)
}

// listPremierAddOnsCreateRequest creates the ListPremierAddOns request.
func (client *WebAppsClient) listPremierAddOnsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPremierAddOnsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPremierAddOnsHandleResponse handles the ListPremierAddOns response.
func (client *WebAppsClient) listPremierAddOnsHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// listPremierAddOnsHandleError handles the ListPremierAddOns error response.
func (client *WebAppsClient) listPremierAddOnsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPremierAddOnsSlot - Description for Gets the premier add-ons of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPremierAddOnsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPremierAddOnsSlotOptions) (PremierAddOnResponse, error) {
	req, err := client.listPremierAddOnsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.listPremierAddOnsSlotHandleError(resp)
	}
	return client.listPremierAddOnsSlotHandleResponse(resp)
}

// listPremierAddOnsSlotCreateRequest creates the ListPremierAddOnsSlot request.
func (client *WebAppsClient) listPremierAddOnsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPremierAddOnsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPremierAddOnsSlotHandleResponse handles the ListPremierAddOnsSlot response.
func (client *WebAppsClient) listPremierAddOnsSlotHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// listPremierAddOnsSlotHandleError handles the ListPremierAddOnsSlot error response.
func (client *WebAppsClient) listPremierAddOnsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListProcessModules - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessModules(resourceGroupName string, name string, processID string, options *WebAppsListProcessModulesOptions) ProcessModuleInfoCollectionPager {
	return &processModuleInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, options)
		},
		responder: client.listProcessModulesHandleResponse,
		errorer:   client.listProcessModulesHandleError,
		advancer: func(ctx context.Context, resp ProcessModuleInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listProcessModulesCreateRequest creates the ListProcessModules request.
func (client *WebAppsClient) listProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsListProcessModulesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessModulesHandleResponse handles the ListProcessModules response.
func (client *WebAppsClient) listProcessModulesHandleResponse(resp *azcore.Response) (ProcessModuleInfoCollectionResponse, error) {
	var val *ProcessModuleInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoCollectionResponse{}, err
	}
	return ProcessModuleInfoCollectionResponse{RawResponse: resp.Response, ProcessModuleInfoCollection: val}, nil
}

// listProcessModulesHandleError handles the ListProcessModules error response.
func (client *WebAppsClient) listProcessModulesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListProcessModulesSlot - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessModulesSlot(resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessModulesSlotOptions) ProcessModuleInfoCollectionPager {
	return &processModuleInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
		},
		responder: client.listProcessModulesSlotHandleResponse,
		errorer:   client.listProcessModulesSlotHandleError,
		advancer: func(ctx context.Context, resp ProcessModuleInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listProcessModulesSlotCreateRequest creates the ListProcessModulesSlot request.
func (client *WebAppsClient) listProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessModulesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessModulesSlotHandleResponse handles the ListProcessModulesSlot response.
func (client *WebAppsClient) listProcessModulesSlotHandleResponse(resp *azcore.Response) (ProcessModuleInfoCollectionResponse, error) {
	var val *ProcessModuleInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessModuleInfoCollectionResponse{}, err
	}
	return ProcessModuleInfoCollectionResponse{RawResponse: resp.Response, ProcessModuleInfoCollection: val}, nil
}

// listProcessModulesSlotHandleError handles the ListProcessModulesSlot error response.
func (client *WebAppsClient) listProcessModulesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListProcessThreads - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessThreads(resourceGroupName string, name string, processID string, options *WebAppsListProcessThreadsOptions) ProcessThreadInfoCollectionPager {
	return &processThreadInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, options)
		},
		responder: client.listProcessThreadsHandleResponse,
		errorer:   client.listProcessThreadsHandleError,
		advancer: func(ctx context.Context, resp ProcessThreadInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listProcessThreadsCreateRequest creates the ListProcessThreads request.
func (client *WebAppsClient) listProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsListProcessThreadsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessThreadsHandleResponse handles the ListProcessThreads response.
func (client *WebAppsClient) listProcessThreadsHandleResponse(resp *azcore.Response) (ProcessThreadInfoCollectionResponse, error) {
	var val *ProcessThreadInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessThreadInfoCollectionResponse{}, err
	}
	return ProcessThreadInfoCollectionResponse{RawResponse: resp.Response, ProcessThreadInfoCollection: val}, nil
}

// listProcessThreadsHandleError handles the ListProcessThreads error response.
func (client *WebAppsClient) listProcessThreadsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListProcessThreadsSlot - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessThreadsSlot(resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessThreadsSlotOptions) ProcessThreadInfoCollectionPager {
	return &processThreadInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
		},
		responder: client.listProcessThreadsSlotHandleResponse,
		errorer:   client.listProcessThreadsSlotHandleError,
		advancer: func(ctx context.Context, resp ProcessThreadInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listProcessThreadsSlotCreateRequest creates the ListProcessThreadsSlot request.
func (client *WebAppsClient) listProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessThreadsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessThreadsSlotHandleResponse handles the ListProcessThreadsSlot response.
func (client *WebAppsClient) listProcessThreadsSlotHandleResponse(resp *azcore.Response) (ProcessThreadInfoCollectionResponse, error) {
	var val *ProcessThreadInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessThreadInfoCollectionResponse{}, err
	}
	return ProcessThreadInfoCollectionResponse{RawResponse: resp.Response, ProcessThreadInfoCollection: val}, nil
}

// listProcessThreadsSlotHandleError handles the ListProcessThreadsSlot error response.
func (client *WebAppsClient) listProcessThreadsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListProcesses - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcesses(resourceGroupName string, name string, options *WebAppsListProcessesOptions) ProcessInfoCollectionPager {
	return &processInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listProcessesCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listProcessesHandleResponse,
		errorer:   client.listProcessesHandleError,
		advancer: func(ctx context.Context, resp ProcessInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listProcessesCreateRequest creates the ListProcesses request.
func (client *WebAppsClient) listProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListProcessesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessesHandleResponse handles the ListProcesses response.
func (client *WebAppsClient) listProcessesHandleResponse(resp *azcore.Response) (ProcessInfoCollectionResponse, error) {
	var val *ProcessInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoCollectionResponse{}, err
	}
	return ProcessInfoCollectionResponse{RawResponse: resp.Response, ProcessInfoCollection: val}, nil
}

// listProcessesHandleError handles the ListProcesses error response.
func (client *WebAppsClient) listProcessesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListProcessesSlot - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessesSlot(resourceGroupName string, name string, slot string, options *WebAppsListProcessesSlotOptions) ProcessInfoCollectionPager {
	return &processInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listProcessesSlotHandleResponse,
		errorer:   client.listProcessesSlotHandleError,
		advancer: func(ctx context.Context, resp ProcessInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listProcessesSlotCreateRequest creates the ListProcessesSlot request.
func (client *WebAppsClient) listProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListProcessesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessesSlotHandleResponse handles the ListProcessesSlot response.
func (client *WebAppsClient) listProcessesSlotHandleResponse(resp *azcore.Response) (ProcessInfoCollectionResponse, error) {
	var val *ProcessInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProcessInfoCollectionResponse{}, err
	}
	return ProcessInfoCollectionResponse{RawResponse: resp.Response, ProcessInfoCollection: val}, nil
}

// listProcessesSlotHandleError handles the ListProcessesSlot error response.
func (client *WebAppsClient) listProcessesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListPublicCertificates - Description for Get public certificates for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublicCertificates(resourceGroupName string, name string, options *WebAppsListPublicCertificatesOptions) PublicCertificateCollectionPager {
	return &publicCertificateCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listPublicCertificatesCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listPublicCertificatesHandleResponse,
		errorer:   client.listPublicCertificatesHandleError,
		advancer: func(ctx context.Context, resp PublicCertificateCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PublicCertificateCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listPublicCertificatesCreateRequest creates the ListPublicCertificates request.
func (client *WebAppsClient) listPublicCertificatesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPublicCertificatesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPublicCertificatesHandleResponse handles the ListPublicCertificates response.
func (client *WebAppsClient) listPublicCertificatesHandleResponse(resp *azcore.Response) (PublicCertificateCollectionResponse, error) {
	var val *PublicCertificateCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublicCertificateCollectionResponse{}, err
	}
	return PublicCertificateCollectionResponse{RawResponse: resp.Response, PublicCertificateCollection: val}, nil
}

// listPublicCertificatesHandleError handles the ListPublicCertificates error response.
func (client *WebAppsClient) listPublicCertificatesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPublicCertificatesSlot - Description for Get public certificates for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublicCertificatesSlot(resourceGroupName string, name string, slot string, options *WebAppsListPublicCertificatesSlotOptions) PublicCertificateCollectionPager {
	return &publicCertificateCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listPublicCertificatesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listPublicCertificatesSlotHandleResponse,
		errorer:   client.listPublicCertificatesSlotHandleError,
		advancer: func(ctx context.Context, resp PublicCertificateCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PublicCertificateCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listPublicCertificatesSlotCreateRequest creates the ListPublicCertificatesSlot request.
func (client *WebAppsClient) listPublicCertificatesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPublicCertificatesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPublicCertificatesSlotHandleResponse handles the ListPublicCertificatesSlot response.
func (client *WebAppsClient) listPublicCertificatesSlotHandleResponse(resp *azcore.Response) (PublicCertificateCollectionResponse, error) {
	var val *PublicCertificateCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PublicCertificateCollectionResponse{}, err
	}
	return PublicCertificateCollectionResponse{RawResponse: resp.Response, PublicCertificateCollection: val}, nil
}

// listPublicCertificatesSlotHandleError handles the ListPublicCertificatesSlot error response.
func (client *WebAppsClient) listPublicCertificatesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginListPublishingCredentials - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginListPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginListPublishingCredentialsOptions) (UserPollerResponse, error) {
	resp, err := client.listPublishingCredentials(ctx, resourceGroupName, name, options)
	if err != nil {
		return UserPollerResponse{}, err
	}
	result := UserPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.ListPublishingCredentials", "", resp, client.con.Pipeline(), client.listPublishingCredentialsHandleError)
	if err != nil {
		return UserPollerResponse{}, err
	}
	poller := &userPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (UserResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeListPublishingCredentials creates a new UserPoller from the specified resume token.
// token - The value must come from a previous call to UserPoller.ResumeToken().
func (client *WebAppsClient) ResumeListPublishingCredentials(ctx context.Context, token string) (UserPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.ListPublishingCredentials", token, client.con.Pipeline(), client.listPublishingCredentialsHandleError)
	if err != nil {
		return UserPollerResponse{}, err
	}
	poller := &userPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return UserPollerResponse{}, err
	}
	result := UserPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (UserResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ListPublishingCredentials - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) listPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginListPublishingCredentialsOptions) (*azcore.Response, error) {
	req, err := client.listPublishingCredentialsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listPublishingCredentialsHandleError(resp)
	}
	return resp, nil
}

// listPublishingCredentialsCreateRequest creates the ListPublishingCredentials request.
func (client *WebAppsClient) listPublishingCredentialsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginListPublishingCredentialsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPublishingCredentialsHandleError handles the ListPublishingCredentials error response.
func (client *WebAppsClient) listPublishingCredentialsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginListPublishingCredentialsSlot - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginListPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginListPublishingCredentialsSlotOptions) (UserPollerResponse, error) {
	resp, err := client.listPublishingCredentialsSlot(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return UserPollerResponse{}, err
	}
	result := UserPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.ListPublishingCredentialsSlot", "", resp, client.con.Pipeline(), client.listPublishingCredentialsSlotHandleError)
	if err != nil {
		return UserPollerResponse{}, err
	}
	poller := &userPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (UserResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeListPublishingCredentialsSlot creates a new UserPoller from the specified resume token.
// token - The value must come from a previous call to UserPoller.ResumeToken().
func (client *WebAppsClient) ResumeListPublishingCredentialsSlot(ctx context.Context, token string) (UserPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.ListPublishingCredentialsSlot", token, client.con.Pipeline(), client.listPublishingCredentialsSlotHandleError)
	if err != nil {
		return UserPollerResponse{}, err
	}
	poller := &userPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return UserPollerResponse{}, err
	}
	result := UserPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (UserResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ListPublishingCredentialsSlot - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) listPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginListPublishingCredentialsSlotOptions) (*azcore.Response, error) {
	req, err := client.listPublishingCredentialsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listPublishingCredentialsSlotHandleError(resp)
	}
	return resp, nil
}

// listPublishingCredentialsSlotCreateRequest creates the ListPublishingCredentialsSlot request.
func (client *WebAppsClient) listPublishingCredentialsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginListPublishingCredentialsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPublishingCredentialsSlotHandleError handles the ListPublishingCredentialsSlot error response.
func (client *WebAppsClient) listPublishingCredentialsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPublishingProfileXMLWithSecrets - Description for Gets the publishing profile for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublishingProfileXMLWithSecrets(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsOptions) (*http.Response, error) {
	req, err := client.listPublishingProfileXMLWithSecretsCreateRequest(ctx, resourceGroupName, name, publishingProfileOptions, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listPublishingProfileXMLWithSecretsHandleError(resp)
	}
	return resp.Response, nil
}

// listPublishingProfileXMLWithSecretsCreateRequest creates the ListPublishingProfileXMLWithSecrets request.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsJSON(publishingProfileOptions)
}

// listPublishingProfileXMLWithSecretsHandleError handles the ListPublishingProfileXMLWithSecrets error response.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPublishingProfileXMLWithSecretsSlot - Description for Gets the publishing profile for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublishingProfileXMLWithSecretsSlot(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsSlotOptions) (*http.Response, error) {
	req, err := client.listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx, resourceGroupName, name, slot, publishingProfileOptions, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listPublishingProfileXMLWithSecretsSlotHandleError(resp)
	}
	return resp.Response, nil
}

// listPublishingProfileXMLWithSecretsSlotCreateRequest creates the ListPublishingProfileXMLWithSecretsSlot request.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsJSON(publishingProfileOptions)
}

// listPublishingProfileXMLWithSecretsSlotHandleError handles the ListPublishingProfileXMLWithSecretsSlot error response.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListRelayServiceConnections - Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListRelayServiceConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsListRelayServiceConnectionsOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.listRelayServiceConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.listRelayServiceConnectionsHandleError(resp)
	}
	return client.listRelayServiceConnectionsHandleResponse(resp)
}

// listRelayServiceConnectionsCreateRequest creates the ListRelayServiceConnections request.
func (client *WebAppsClient) listRelayServiceConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListRelayServiceConnectionsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listRelayServiceConnectionsHandleResponse handles the ListRelayServiceConnections response.
func (client *WebAppsClient) listRelayServiceConnectionsHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// listRelayServiceConnectionsHandleError handles the ListRelayServiceConnections error response.
func (client *WebAppsClient) listRelayServiceConnectionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListRelayServiceConnectionsSlot - Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListRelayServiceConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListRelayServiceConnectionsSlotOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.listRelayServiceConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.listRelayServiceConnectionsSlotHandleError(resp)
	}
	return client.listRelayServiceConnectionsSlotHandleResponse(resp)
}

// listRelayServiceConnectionsSlotCreateRequest creates the ListRelayServiceConnectionsSlot request.
func (client *WebAppsClient) listRelayServiceConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListRelayServiceConnectionsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listRelayServiceConnectionsSlotHandleResponse handles the ListRelayServiceConnectionsSlot response.
func (client *WebAppsClient) listRelayServiceConnectionsSlotHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// listRelayServiceConnectionsSlotHandleError handles the ListRelayServiceConnectionsSlot error response.
func (client *WebAppsClient) listRelayServiceConnectionsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSiteBackups - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteBackups(resourceGroupName string, name string, options *WebAppsListSiteBackupsOptions) BackupItemCollectionPager {
	return &backupItemCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSiteBackupsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listSiteBackupsHandleResponse,
		errorer:   client.listSiteBackupsHandleError,
		advancer: func(ctx context.Context, resp BackupItemCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSiteBackupsCreateRequest creates the ListSiteBackups request.
func (client *WebAppsClient) listSiteBackupsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSiteBackupsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listbackups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteBackupsHandleResponse handles the ListSiteBackups response.
func (client *WebAppsClient) listSiteBackupsHandleResponse(resp *azcore.Response) (BackupItemCollectionResponse, error) {
	var val *BackupItemCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemCollectionResponse{}, err
	}
	return BackupItemCollectionResponse{RawResponse: resp.Response, BackupItemCollection: val}, nil
}

// listSiteBackupsHandleError handles the ListSiteBackups error response.
func (client *WebAppsClient) listSiteBackupsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSiteBackupsSlot - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteBackupsSlot(resourceGroupName string, name string, slot string, options *WebAppsListSiteBackupsSlotOptions) BackupItemCollectionPager {
	return &backupItemCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSiteBackupsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listSiteBackupsSlotHandleResponse,
		errorer:   client.listSiteBackupsSlotHandleError,
		advancer: func(ctx context.Context, resp BackupItemCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSiteBackupsSlotCreateRequest creates the ListSiteBackupsSlot request.
func (client *WebAppsClient) listSiteBackupsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSiteBackupsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listbackups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteBackupsSlotHandleResponse handles the ListSiteBackupsSlot response.
func (client *WebAppsClient) listSiteBackupsSlotHandleResponse(resp *azcore.Response) (BackupItemCollectionResponse, error) {
	var val *BackupItemCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupItemCollectionResponse{}, err
	}
	return BackupItemCollectionResponse{RawResponse: resp.Response, BackupItemCollection: val}, nil
}

// listSiteBackupsSlotHandleError handles the ListSiteBackupsSlot error response.
func (client *WebAppsClient) listSiteBackupsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSiteExtensions - Description for Get list of siteextensions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteExtensions(resourceGroupName string, name string, options *WebAppsListSiteExtensionsOptions) SiteExtensionInfoCollectionPager {
	return &siteExtensionInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSiteExtensionsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listSiteExtensionsHandleResponse,
		errorer:   client.listSiteExtensionsHandleError,
		advancer: func(ctx context.Context, resp SiteExtensionInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SiteExtensionInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSiteExtensionsCreateRequest creates the ListSiteExtensions request.
func (client *WebAppsClient) listSiteExtensionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSiteExtensionsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteExtensionsHandleResponse handles the ListSiteExtensions response.
func (client *WebAppsClient) listSiteExtensionsHandleResponse(resp *azcore.Response) (SiteExtensionInfoCollectionResponse, error) {
	var val *SiteExtensionInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteExtensionInfoCollectionResponse{}, err
	}
	return SiteExtensionInfoCollectionResponse{RawResponse: resp.Response, SiteExtensionInfoCollection: val}, nil
}

// listSiteExtensionsHandleError handles the ListSiteExtensions error response.
func (client *WebAppsClient) listSiteExtensionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListSiteExtensionsSlot - Description for Get list of siteextensions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteExtensionsSlot(resourceGroupName string, name string, slot string, options *WebAppsListSiteExtensionsSlotOptions) SiteExtensionInfoCollectionPager {
	return &siteExtensionInfoCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSiteExtensionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listSiteExtensionsSlotHandleResponse,
		errorer:   client.listSiteExtensionsSlotHandleError,
		advancer: func(ctx context.Context, resp SiteExtensionInfoCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SiteExtensionInfoCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSiteExtensionsSlotCreateRequest creates the ListSiteExtensionsSlot request.
func (client *WebAppsClient) listSiteExtensionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSiteExtensionsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteExtensionsSlotHandleResponse handles the ListSiteExtensionsSlot response.
func (client *WebAppsClient) listSiteExtensionsSlotHandleResponse(resp *azcore.Response) (SiteExtensionInfoCollectionResponse, error) {
	var val *SiteExtensionInfoCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteExtensionInfoCollectionResponse{}, err
	}
	return SiteExtensionInfoCollectionResponse{RawResponse: resp.Response, SiteExtensionInfoCollection: val}, nil
}

// listSiteExtensionsSlotHandleError handles the ListSiteExtensionsSlot error response.
func (client *WebAppsClient) listSiteExtensionsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListSitePushSettings - Description for Gets the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSitePushSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSitePushSettingsOptions) (PushSettingsResponse, error) {
	req, err := client.listSitePushSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PushSettingsResponse{}, client.listSitePushSettingsHandleError(resp)
	}
	return client.listSitePushSettingsHandleResponse(resp)
}

// listSitePushSettingsCreateRequest creates the ListSitePushSettings request.
func (client *WebAppsClient) listSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSitePushSettingsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSitePushSettingsHandleResponse handles the ListSitePushSettings response.
func (client *WebAppsClient) listSitePushSettingsHandleResponse(resp *azcore.Response) (PushSettingsResponse, error) {
	var val *PushSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PushSettingsResponse{}, err
	}
	return PushSettingsResponse{RawResponse: resp.Response, PushSettings: val}, nil
}

// listSitePushSettingsHandleError handles the ListSitePushSettings error response.
func (client *WebAppsClient) listSitePushSettingsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSitePushSettingsSlot - Description for Gets the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSitePushSettingsSlotOptions) (PushSettingsResponse, error) {
	req, err := client.listSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PushSettingsResponse{}, client.listSitePushSettingsSlotHandleError(resp)
	}
	return client.listSitePushSettingsSlotHandleResponse(resp)
}

// listSitePushSettingsSlotCreateRequest creates the ListSitePushSettingsSlot request.
func (client *WebAppsClient) listSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSitePushSettingsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSitePushSettingsSlotHandleResponse handles the ListSitePushSettingsSlot response.
func (client *WebAppsClient) listSitePushSettingsSlotHandleResponse(resp *azcore.Response) (PushSettingsResponse, error) {
	var val *PushSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PushSettingsResponse{}, err
	}
	return PushSettingsResponse{RawResponse: resp.Response, PushSettings: val}, nil
}

// listSitePushSettingsSlotHandleError handles the ListSitePushSettingsSlot error response.
func (client *WebAppsClient) listSitePushSettingsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSlotConfigurationNames - Description for Gets the names of app settings and connection strings that stick to the slot (not swapped).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSlotConfigurationNamesOptions) (SlotConfigNamesResourceResponse, error) {
	req, err := client.listSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return SlotConfigNamesResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SlotConfigNamesResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SlotConfigNamesResourceResponse{}, client.listSlotConfigurationNamesHandleError(resp)
	}
	return client.listSlotConfigurationNamesHandleResponse(resp)
}

// listSlotConfigurationNamesCreateRequest creates the ListSlotConfigurationNames request.
func (client *WebAppsClient) listSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSlotConfigurationNamesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSlotConfigurationNamesHandleResponse handles the ListSlotConfigurationNames response.
func (client *WebAppsClient) listSlotConfigurationNamesHandleResponse(resp *azcore.Response) (SlotConfigNamesResourceResponse, error) {
	var val *SlotConfigNamesResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SlotConfigNamesResourceResponse{}, err
	}
	return SlotConfigNamesResourceResponse{RawResponse: resp.Response, SlotConfigNamesResource: val}, nil
}

// listSlotConfigurationNamesHandleError handles the ListSlotConfigurationNames error response.
func (client *WebAppsClient) listSlotConfigurationNamesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSlotDifferencesFromProduction - Description for Get the difference in configuration settings between two web app slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlotDifferencesFromProduction(resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesFromProductionOptions) SlotDifferenceCollectionPager {
	return &slotDifferenceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSlotDifferencesFromProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
		},
		responder: client.listSlotDifferencesFromProductionHandleResponse,
		errorer:   client.listSlotDifferencesFromProductionHandleError,
		advancer: func(ctx context.Context, resp SlotDifferenceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SlotDifferenceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSlotDifferencesFromProductionCreateRequest creates the ListSlotDifferencesFromProduction request.
func (client *WebAppsClient) listSlotDifferencesFromProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesFromProductionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(slotSwapEntity)
}

// listSlotDifferencesFromProductionHandleResponse handles the ListSlotDifferencesFromProduction response.
func (client *WebAppsClient) listSlotDifferencesFromProductionHandleResponse(resp *azcore.Response) (SlotDifferenceCollectionResponse, error) {
	var val *SlotDifferenceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SlotDifferenceCollectionResponse{}, err
	}
	return SlotDifferenceCollectionResponse{RawResponse: resp.Response, SlotDifferenceCollection: val}, nil
}

// listSlotDifferencesFromProductionHandleError handles the ListSlotDifferencesFromProduction error response.
func (client *WebAppsClient) listSlotDifferencesFromProductionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSlotDifferencesSlot - Description for Get the difference in configuration settings between two web app slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlotDifferencesSlot(resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesSlotOptions) SlotDifferenceCollectionPager {
	return &slotDifferenceCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSlotDifferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
		},
		responder: client.listSlotDifferencesSlotHandleResponse,
		errorer:   client.listSlotDifferencesSlotHandleError,
		advancer: func(ctx context.Context, resp SlotDifferenceCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SlotDifferenceCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSlotDifferencesSlotCreateRequest creates the ListSlotDifferencesSlot request.
func (client *WebAppsClient) listSlotDifferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(slotSwapEntity)
}

// listSlotDifferencesSlotHandleResponse handles the ListSlotDifferencesSlot response.
func (client *WebAppsClient) listSlotDifferencesSlotHandleResponse(resp *azcore.Response) (SlotDifferenceCollectionResponse, error) {
	var val *SlotDifferenceCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SlotDifferenceCollectionResponse{}, err
	}
	return SlotDifferenceCollectionResponse{RawResponse: resp.Response, SlotDifferenceCollection: val}, nil
}

// listSlotDifferencesSlotHandleError handles the ListSlotDifferencesSlot error response.
func (client *WebAppsClient) listSlotDifferencesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSlots - Description for Gets an app's deployment slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlots(resourceGroupName string, name string, options *WebAppsListSlotsOptions) WebAppCollectionPager {
	return &webAppCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSlotsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listSlotsHandleResponse,
		errorer:   client.listSlotsHandleError,
		advancer: func(ctx context.Context, resp WebAppCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSlotsCreateRequest creates the ListSlots request.
func (client *WebAppsClient) listSlotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSlotsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSlotsHandleResponse handles the ListSlots response.
func (client *WebAppsClient) listSlotsHandleResponse(resp *azcore.Response) (WebAppCollectionResponse, error) {
	var val *WebAppCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebAppCollectionResponse{}, err
	}
	return WebAppCollectionResponse{RawResponse: resp.Response, WebAppCollection: val}, nil
}

// listSlotsHandleError handles the ListSlots error response.
func (client *WebAppsClient) listSlotsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSnapshots - Description for Returns all Snapshots to the user.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshots(resourceGroupName string, name string, options *WebAppsListSnapshotsOptions) SnapshotCollectionPager {
	return &snapshotCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSnapshotsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listSnapshotsHandleResponse,
		errorer:   client.listSnapshotsHandleError,
		advancer: func(ctx context.Context, resp SnapshotCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSnapshotsCreateRequest creates the ListSnapshots request.
func (client *WebAppsClient) listSnapshotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSnapshotsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsHandleResponse handles the ListSnapshots response.
func (client *WebAppsClient) listSnapshotsHandleResponse(resp *azcore.Response) (SnapshotCollectionResponse, error) {
	var val *SnapshotCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SnapshotCollectionResponse{}, err
	}
	return SnapshotCollectionResponse{RawResponse: resp.Response, SnapshotCollection: val}, nil
}

// listSnapshotsHandleError handles the ListSnapshots error response.
func (client *WebAppsClient) listSnapshotsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSnapshotsFromDRSecondary - Description for Returns all Snapshots to the user from DRSecondary endpoint.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshotsFromDRSecondary(resourceGroupName string, name string, options *WebAppsListSnapshotsFromDRSecondaryOptions) SnapshotCollectionPager {
	return &snapshotCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSnapshotsFromDRSecondaryCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listSnapshotsFromDRSecondaryHandleResponse,
		errorer:   client.listSnapshotsFromDRSecondaryHandleError,
		advancer: func(ctx context.Context, resp SnapshotCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSnapshotsFromDRSecondaryCreateRequest creates the ListSnapshotsFromDRSecondary request.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSnapshotsFromDRSecondaryOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsFromDRSecondaryHandleResponse handles the ListSnapshotsFromDRSecondary response.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryHandleResponse(resp *azcore.Response) (SnapshotCollectionResponse, error) {
	var val *SnapshotCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SnapshotCollectionResponse{}, err
	}
	return SnapshotCollectionResponse{RawResponse: resp.Response, SnapshotCollection: val}, nil
}

// listSnapshotsFromDRSecondaryHandleError handles the ListSnapshotsFromDRSecondary error response.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSnapshotsFromDRSecondarySlot - Description for Returns all Snapshots to the user from DRSecondary endpoint.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshotsFromDRSecondarySlot(resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsFromDRSecondarySlotOptions) SnapshotCollectionPager {
	return &snapshotCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSnapshotsFromDRSecondarySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listSnapshotsFromDRSecondarySlotHandleResponse,
		errorer:   client.listSnapshotsFromDRSecondarySlotHandleError,
		advancer: func(ctx context.Context, resp SnapshotCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSnapshotsFromDRSecondarySlotCreateRequest creates the ListSnapshotsFromDRSecondarySlot request.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsFromDRSecondarySlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsFromDRSecondarySlotHandleResponse handles the ListSnapshotsFromDRSecondarySlot response.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotHandleResponse(resp *azcore.Response) (SnapshotCollectionResponse, error) {
	var val *SnapshotCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SnapshotCollectionResponse{}, err
	}
	return SnapshotCollectionResponse{RawResponse: resp.Response, SnapshotCollection: val}, nil
}

// listSnapshotsFromDRSecondarySlotHandleError handles the ListSnapshotsFromDRSecondarySlot error response.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSnapshotsSlot - Description for Returns all Snapshots to the user.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshotsSlot(resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsSlotOptions) SnapshotCollectionPager {
	return &snapshotCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSnapshotsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listSnapshotsSlotHandleResponse,
		errorer:   client.listSnapshotsSlotHandleError,
		advancer: func(ctx context.Context, resp SnapshotCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSnapshotsSlotCreateRequest creates the ListSnapshotsSlot request.
func (client *WebAppsClient) listSnapshotsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsSlotHandleResponse handles the ListSnapshotsSlot response.
func (client *WebAppsClient) listSnapshotsSlotHandleResponse(resp *azcore.Response) (SnapshotCollectionResponse, error) {
	var val *SnapshotCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SnapshotCollectionResponse{}, err
	}
	return SnapshotCollectionResponse{RawResponse: resp.Response, SnapshotCollection: val}, nil
}

// listSnapshotsSlotHandleError handles the ListSnapshotsSlot error response.
func (client *WebAppsClient) listSnapshotsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSyncFunctionTriggers - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncFunctionTriggersOptions) (FunctionSecretsResponse, error) {
	req, err := client.listSyncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FunctionSecretsResponse{}, client.listSyncFunctionTriggersHandleError(resp)
	}
	return client.listSyncFunctionTriggersHandleResponse(resp)
}

// listSyncFunctionTriggersCreateRequest creates the ListSyncFunctionTriggers request.
func (client *WebAppsClient) listSyncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncFunctionTriggersOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncFunctionTriggersHandleResponse handles the ListSyncFunctionTriggers response.
func (client *WebAppsClient) listSyncFunctionTriggersHandleResponse(resp *azcore.Response) (FunctionSecretsResponse, error) {
	var val *FunctionSecrets
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionSecretsResponse{}, err
	}
	return FunctionSecretsResponse{RawResponse: resp.Response, FunctionSecrets: val}, nil
}

// listSyncFunctionTriggersHandleError handles the ListSyncFunctionTriggers error response.
func (client *WebAppsClient) listSyncFunctionTriggersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSyncFunctionTriggersSlot - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncFunctionTriggersSlotOptions) (FunctionSecretsResponse, error) {
	req, err := client.listSyncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FunctionSecretsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FunctionSecretsResponse{}, client.listSyncFunctionTriggersSlotHandleError(resp)
	}
	return client.listSyncFunctionTriggersSlotHandleResponse(resp)
}

// listSyncFunctionTriggersSlotCreateRequest creates the ListSyncFunctionTriggersSlot request.
func (client *WebAppsClient) listSyncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncFunctionTriggersSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncFunctionTriggersSlotHandleResponse handles the ListSyncFunctionTriggersSlot response.
func (client *WebAppsClient) listSyncFunctionTriggersSlotHandleResponse(resp *azcore.Response) (FunctionSecretsResponse, error) {
	var val *FunctionSecrets
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FunctionSecretsResponse{}, err
	}
	return FunctionSecretsResponse{RawResponse: resp.Response, FunctionSecrets: val}, nil
}

// listSyncFunctionTriggersSlotHandleError handles the ListSyncFunctionTriggersSlot error response.
func (client *WebAppsClient) listSyncFunctionTriggersSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSyncStatus - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncStatusOptions) (*http.Response, error) {
	req, err := client.listSyncStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.listSyncStatusHandleError(resp)
	}
	return resp.Response, nil
}

// listSyncStatusCreateRequest creates the ListSyncStatus request.
func (client *WebAppsClient) listSyncStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncStatusOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncStatusHandleError handles the ListSyncStatus error response.
func (client *WebAppsClient) listSyncStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSyncStatusSlot - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncStatusSlotOptions) (*http.Response, error) {
	req, err := client.listSyncStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.listSyncStatusSlotHandleError(resp)
	}
	return resp.Response, nil
}

// listSyncStatusSlotCreateRequest creates the ListSyncStatusSlot request.
func (client *WebAppsClient) listSyncStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncStatusSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncStatusSlotHandleError handles the ListSyncStatusSlot error response.
func (client *WebAppsClient) listSyncStatusSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListTriggeredWebJobHistory - Description for List a triggered web job's history for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobHistory(resourceGroupName string, name string, webJobName string, options *WebAppsListTriggeredWebJobHistoryOptions) TriggeredJobHistoryCollectionPager {
	return &triggeredJobHistoryCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, options)
		},
		responder: client.listTriggeredWebJobHistoryHandleResponse,
		errorer:   client.listTriggeredWebJobHistoryHandleError,
		advancer: func(ctx context.Context, resp TriggeredJobHistoryCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.TriggeredJobHistoryCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listTriggeredWebJobHistoryCreateRequest creates the ListTriggeredWebJobHistory request.
func (client *WebAppsClient) listTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsListTriggeredWebJobHistoryOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobHistoryHandleResponse handles the ListTriggeredWebJobHistory response.
func (client *WebAppsClient) listTriggeredWebJobHistoryHandleResponse(resp *azcore.Response) (TriggeredJobHistoryCollectionResponse, error) {
	var val *TriggeredJobHistoryCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredJobHistoryCollectionResponse{}, err
	}
	return TriggeredJobHistoryCollectionResponse{RawResponse: resp.Response, TriggeredJobHistoryCollection: val}, nil
}

// listTriggeredWebJobHistoryHandleError handles the ListTriggeredWebJobHistory error response.
func (client *WebAppsClient) listTriggeredWebJobHistoryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListTriggeredWebJobHistorySlot - Description for List a triggered web job's history for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobHistorySlot(resourceGroupName string, name string, webJobName string, slot string, options *WebAppsListTriggeredWebJobHistorySlotOptions) TriggeredJobHistoryCollectionPager {
	return &triggeredJobHistoryCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
		},
		responder: client.listTriggeredWebJobHistorySlotHandleResponse,
		errorer:   client.listTriggeredWebJobHistorySlotHandleError,
		advancer: func(ctx context.Context, resp TriggeredJobHistoryCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.TriggeredJobHistoryCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listTriggeredWebJobHistorySlotCreateRequest creates the ListTriggeredWebJobHistorySlot request.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsListTriggeredWebJobHistorySlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobHistorySlotHandleResponse handles the ListTriggeredWebJobHistorySlot response.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotHandleResponse(resp *azcore.Response) (TriggeredJobHistoryCollectionResponse, error) {
	var val *TriggeredJobHistoryCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredJobHistoryCollectionResponse{}, err
	}
	return TriggeredJobHistoryCollectionResponse{RawResponse: resp.Response, TriggeredJobHistoryCollection: val}, nil
}

// listTriggeredWebJobHistorySlotHandleError handles the ListTriggeredWebJobHistorySlot error response.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// ListTriggeredWebJobs - Description for List triggered web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobs(resourceGroupName string, name string, options *WebAppsListTriggeredWebJobsOptions) TriggeredWebJobCollectionPager {
	return &triggeredWebJobCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listTriggeredWebJobsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listTriggeredWebJobsHandleResponse,
		errorer:   client.listTriggeredWebJobsHandleError,
		advancer: func(ctx context.Context, resp TriggeredWebJobCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.TriggeredWebJobCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listTriggeredWebJobsCreateRequest creates the ListTriggeredWebJobs request.
func (client *WebAppsClient) listTriggeredWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListTriggeredWebJobsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobsHandleResponse handles the ListTriggeredWebJobs response.
func (client *WebAppsClient) listTriggeredWebJobsHandleResponse(resp *azcore.Response) (TriggeredWebJobCollectionResponse, error) {
	var val *TriggeredWebJobCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredWebJobCollectionResponse{}, err
	}
	return TriggeredWebJobCollectionResponse{RawResponse: resp.Response, TriggeredWebJobCollection: val}, nil
}

// listTriggeredWebJobsHandleError handles the ListTriggeredWebJobs error response.
func (client *WebAppsClient) listTriggeredWebJobsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListTriggeredWebJobsSlot - Description for List triggered web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobsSlot(resourceGroupName string, name string, slot string, options *WebAppsListTriggeredWebJobsSlotOptions) TriggeredWebJobCollectionPager {
	return &triggeredWebJobCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listTriggeredWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listTriggeredWebJobsSlotHandleResponse,
		errorer:   client.listTriggeredWebJobsSlotHandleError,
		advancer: func(ctx context.Context, resp TriggeredWebJobCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.TriggeredWebJobCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listTriggeredWebJobsSlotCreateRequest creates the ListTriggeredWebJobsSlot request.
func (client *WebAppsClient) listTriggeredWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListTriggeredWebJobsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobsSlotHandleResponse handles the ListTriggeredWebJobsSlot response.
func (client *WebAppsClient) listTriggeredWebJobsSlotHandleResponse(resp *azcore.Response) (TriggeredWebJobCollectionResponse, error) {
	var val *TriggeredWebJobCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TriggeredWebJobCollectionResponse{}, err
	}
	return TriggeredWebJobCollectionResponse{RawResponse: resp.Response, TriggeredWebJobCollection: val}, nil
}

// listTriggeredWebJobsSlotHandleError handles the ListTriggeredWebJobsSlot error response.
func (client *WebAppsClient) listTriggeredWebJobsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListUsages - Description for Gets the quota usage information of an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListUsages(resourceGroupName string, name string, options *WebAppsListUsagesOptions) CsmUsageQuotaCollectionPager {
	return &csmUsageQuotaCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listUsagesCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listUsagesHandleResponse,
		errorer:   client.listUsagesHandleError,
		advancer: func(ctx context.Context, resp CsmUsageQuotaCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.CsmUsageQuotaCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listUsagesCreateRequest creates the ListUsages request.
func (client *WebAppsClient) listUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListUsagesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listUsagesHandleResponse handles the ListUsages response.
func (client *WebAppsClient) listUsagesHandleResponse(resp *azcore.Response) (CsmUsageQuotaCollectionResponse, error) {
	var val *CsmUsageQuotaCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmUsageQuotaCollectionResponse{}, err
	}
	return CsmUsageQuotaCollectionResponse{RawResponse: resp.Response, CsmUsageQuotaCollection: val}, nil
}

// listUsagesHandleError handles the ListUsages error response.
func (client *WebAppsClient) listUsagesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListUsagesSlot - Description for Gets the quota usage information of an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListUsagesSlot(resourceGroupName string, name string, slot string, options *WebAppsListUsagesSlotOptions) CsmUsageQuotaCollectionPager {
	return &csmUsageQuotaCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listUsagesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listUsagesSlotHandleResponse,
		errorer:   client.listUsagesSlotHandleError,
		advancer: func(ctx context.Context, resp CsmUsageQuotaCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.CsmUsageQuotaCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listUsagesSlotCreateRequest creates the ListUsagesSlot request.
func (client *WebAppsClient) listUsagesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListUsagesSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listUsagesSlotHandleResponse handles the ListUsagesSlot response.
func (client *WebAppsClient) listUsagesSlotHandleResponse(resp *azcore.Response) (CsmUsageQuotaCollectionResponse, error) {
	var val *CsmUsageQuotaCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmUsageQuotaCollectionResponse{}, err
	}
	return CsmUsageQuotaCollectionResponse{RawResponse: resp.Response, CsmUsageQuotaCollection: val}, nil
}

// listUsagesSlotHandleError handles the ListUsagesSlot error response.
func (client *WebAppsClient) listUsagesSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListVnetConnections - Description for Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListVnetConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsListVnetConnectionsOptions) (VnetInfoArrayResponse, error) {
	req, err := client.listVnetConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return VnetInfoArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoArrayResponse{}, client.listVnetConnectionsHandleError(resp)
	}
	return client.listVnetConnectionsHandleResponse(resp)
}

// listVnetConnectionsCreateRequest creates the ListVnetConnections request.
func (client *WebAppsClient) listVnetConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListVnetConnectionsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listVnetConnectionsHandleResponse handles the ListVnetConnections response.
func (client *WebAppsClient) listVnetConnectionsHandleResponse(resp *azcore.Response) (VnetInfoArrayResponse, error) {
	var val []*VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoArrayResponse{}, err
	}
	return VnetInfoArrayResponse{RawResponse: resp.Response, VnetInfoArray: val}, nil
}

// listVnetConnectionsHandleError handles the ListVnetConnections error response.
func (client *WebAppsClient) listVnetConnectionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListVnetConnectionsSlot - Description for Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListVnetConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListVnetConnectionsSlotOptions) (VnetInfoArrayResponse, error) {
	req, err := client.listVnetConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return VnetInfoArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoArrayResponse{}, client.listVnetConnectionsSlotHandleError(resp)
	}
	return client.listVnetConnectionsSlotHandleResponse(resp)
}

// listVnetConnectionsSlotCreateRequest creates the ListVnetConnectionsSlot request.
func (client *WebAppsClient) listVnetConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListVnetConnectionsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listVnetConnectionsSlotHandleResponse handles the ListVnetConnectionsSlot response.
func (client *WebAppsClient) listVnetConnectionsSlotHandleResponse(resp *azcore.Response) (VnetInfoArrayResponse, error) {
	var val []*VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoArrayResponse{}, err
	}
	return VnetInfoArrayResponse{RawResponse: resp.Response, VnetInfoArray: val}, nil
}

// listVnetConnectionsSlotHandleError handles the ListVnetConnectionsSlot error response.
func (client *WebAppsClient) listVnetConnectionsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListWebJobs - Description for List webjobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListWebJobs(resourceGroupName string, name string, options *WebAppsListWebJobsOptions) WebJobCollectionPager {
	return &webJobCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listWebJobsCreateRequest(ctx, resourceGroupName, name, options)
		},
		responder: client.listWebJobsHandleResponse,
		errorer:   client.listWebJobsHandleError,
		advancer: func(ctx context.Context, resp WebJobCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WebJobCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listWebJobsCreateRequest creates the ListWebJobs request.
func (client *WebAppsClient) listWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListWebJobsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listWebJobsHandleResponse handles the ListWebJobs response.
func (client *WebAppsClient) listWebJobsHandleResponse(resp *azcore.Response) (WebJobCollectionResponse, error) {
	var val *WebJobCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebJobCollectionResponse{}, err
	}
	return WebJobCollectionResponse{RawResponse: resp.Response, WebJobCollection: val}, nil
}

// listWebJobsHandleError handles the ListWebJobs error response.
func (client *WebAppsClient) listWebJobsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListWebJobsSlot - Description for List webjobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListWebJobsSlot(resourceGroupName string, name string, slot string, options *WebAppsListWebJobsSlotOptions) WebJobCollectionPager {
	return &webJobCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		responder: client.listWebJobsSlotHandleResponse,
		errorer:   client.listWebJobsSlotHandleError,
		advancer: func(ctx context.Context, resp WebJobCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.WebJobCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listWebJobsSlotCreateRequest creates the ListWebJobsSlot request.
func (client *WebAppsClient) listWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListWebJobsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listWebJobsSlotHandleResponse handles the ListWebJobsSlot response.
func (client *WebAppsClient) listWebJobsSlotHandleResponse(resp *azcore.Response) (WebJobCollectionResponse, error) {
	var val *WebJobCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WebJobCollectionResponse{}, err
	}
	return WebJobCollectionResponse{RawResponse: resp.Response, WebJobCollection: val}, nil
}

// listWebJobsSlotHandleError handles the ListWebJobsSlot error response.
func (client *WebAppsClient) listWebJobsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginMigrateMySQL - Description for Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginMigrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsBeginMigrateMySQLOptions) (OperationPollerResponse, error) {
	resp, err := client.migrateMySQL(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
	if err != nil {
		return OperationPollerResponse{}, err
	}
	result := OperationPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.MigrateMySQL", "", resp, client.con.Pipeline(), client.migrateMySQLHandleError)
	if err != nil {
		return OperationPollerResponse{}, err
	}
	poller := &operationPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (OperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeMigrateMySQL creates a new OperationPoller from the specified resume token.
// token - The value must come from a previous call to OperationPoller.ResumeToken().
func (client *WebAppsClient) ResumeMigrateMySQL(ctx context.Context, token string) (OperationPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.MigrateMySQL", token, client.con.Pipeline(), client.migrateMySQLHandleError)
	if err != nil {
		return OperationPollerResponse{}, err
	}
	poller := &operationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return OperationPollerResponse{}, err
	}
	result := OperationPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (OperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// MigrateMySQL - Description for Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) migrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsBeginMigrateMySQLOptions) (*azcore.Response, error) {
	req, err := client.migrateMySQLCreateRequest(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.migrateMySQLHandleError(resp)
	}
	return resp, nil
}

// migrateMySQLCreateRequest creates the MigrateMySQL request.
func (client *WebAppsClient) migrateMySQLCreateRequest(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsBeginMigrateMySQLOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(migrationRequestEnvelope)
}

// migrateMySQLHandleError handles the MigrateMySQL error response.
func (client *WebAppsClient) migrateMySQLHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginMigrateStorage - Description for Restores a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginMigrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsBeginMigrateStorageOptions) (StorageMigrationResponsePollerResponse, error) {
	resp, err := client.migrateStorage(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
	if err != nil {
		return StorageMigrationResponsePollerResponse{}, err
	}
	result := StorageMigrationResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.MigrateStorage", "", resp, client.con.Pipeline(), client.migrateStorageHandleError)
	if err != nil {
		return StorageMigrationResponsePollerResponse{}, err
	}
	poller := &storageMigrationResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (StorageMigrationResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeMigrateStorage creates a new StorageMigrationResponsePoller from the specified resume token.
// token - The value must come from a previous call to StorageMigrationResponsePoller.ResumeToken().
func (client *WebAppsClient) ResumeMigrateStorage(ctx context.Context, token string) (StorageMigrationResponsePollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.MigrateStorage", token, client.con.Pipeline(), client.migrateStorageHandleError)
	if err != nil {
		return StorageMigrationResponsePollerResponse{}, err
	}
	poller := &storageMigrationResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return StorageMigrationResponsePollerResponse{}, err
	}
	result := StorageMigrationResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (StorageMigrationResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// MigrateStorage - Description for Restores a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) migrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsBeginMigrateStorageOptions) (*azcore.Response, error) {
	req, err := client.migrateStorageCreateRequest(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.migrateStorageHandleError(resp)
	}
	return resp, nil
}

// migrateStorageCreateRequest creates the MigrateStorage request.
func (client *WebAppsClient) migrateStorageCreateRequest(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsBeginMigrateStorageOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("subscriptionName", subscriptionName)
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(migrationOptions)
}

// migrateStorageHandleError handles the MigrateStorage error response.
func (client *WebAppsClient) migrateStorageHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutPrivateAccessVnet - Description for Sets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) PutPrivateAccessVnet(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetOptions) (PrivateAccessResponse, error) {
	req, err := client.putPrivateAccessVnetCreateRequest(ctx, resourceGroupName, name, access, options)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PrivateAccessResponse{}, client.putPrivateAccessVnetHandleError(resp)
	}
	return client.putPrivateAccessVnetHandleResponse(resp)
}

// putPrivateAccessVnetCreateRequest creates the PutPrivateAccessVnet request.
func (client *WebAppsClient) putPrivateAccessVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(access)
}

// putPrivateAccessVnetHandleResponse handles the PutPrivateAccessVnet response.
func (client *WebAppsClient) putPrivateAccessVnetHandleResponse(resp *azcore.Response) (PrivateAccessResponse, error) {
	var val *PrivateAccess
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateAccessResponse{}, err
	}
	return PrivateAccessResponse{RawResponse: resp.Response, PrivateAccess: val}, nil
}

// putPrivateAccessVnetHandleError handles the PutPrivateAccessVnet error response.
func (client *WebAppsClient) putPrivateAccessVnetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutPrivateAccessVnetSlot - Description for Sets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) PutPrivateAccessVnetSlot(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetSlotOptions) (PrivateAccessResponse, error) {
	req, err := client.putPrivateAccessVnetSlotCreateRequest(ctx, resourceGroupName, name, slot, access, options)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PrivateAccessResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PrivateAccessResponse{}, client.putPrivateAccessVnetSlotHandleError(resp)
	}
	return client.putPrivateAccessVnetSlotHandleResponse(resp)
}

// putPrivateAccessVnetSlotCreateRequest creates the PutPrivateAccessVnetSlot request.
func (client *WebAppsClient) putPrivateAccessVnetSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(access)
}

// putPrivateAccessVnetSlotHandleResponse handles the PutPrivateAccessVnetSlot response.
func (client *WebAppsClient) putPrivateAccessVnetSlotHandleResponse(resp *azcore.Response) (PrivateAccessResponse, error) {
	var val *PrivateAccess
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PrivateAccessResponse{}, err
	}
	return PrivateAccessResponse{RawResponse: resp.Response, PrivateAccess: val}, nil
}

// putPrivateAccessVnetSlotHandleError handles the PutPrivateAccessVnetSlot error response.
func (client *WebAppsClient) putPrivateAccessVnetSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RecoverSiteConfigurationSnapshot - Description for Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RecoverSiteConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsRecoverSiteConfigurationSnapshotOptions) (*http.Response, error) {
	req, err := client.recoverSiteConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.recoverSiteConfigurationSnapshotHandleError(resp)
	}
	return resp.Response, nil
}

// recoverSiteConfigurationSnapshotCreateRequest creates the RecoverSiteConfigurationSnapshot request.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsRecoverSiteConfigurationSnapshotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// recoverSiteConfigurationSnapshotHandleError handles the RecoverSiteConfigurationSnapshot error response.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RecoverSiteConfigurationSnapshotSlot - Description for Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RecoverSiteConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsRecoverSiteConfigurationSnapshotSlotOptions) (*http.Response, error) {
	req, err := client.recoverSiteConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.recoverSiteConfigurationSnapshotSlotHandleError(resp)
	}
	return resp.Response, nil
}

// recoverSiteConfigurationSnapshotSlotCreateRequest creates the RecoverSiteConfigurationSnapshotSlot request.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsRecoverSiteConfigurationSnapshotSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// recoverSiteConfigurationSnapshotSlotHandleError handles the RecoverSiteConfigurationSnapshotSlot error response.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResetProductionSlotConfig - Description for Resets the configuration settings of the current slot if they were previously modified by calling the API
// with POST.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ResetProductionSlotConfig(ctx context.Context, resourceGroupName string, name string, options *WebAppsResetProductionSlotConfigOptions) (*http.Response, error) {
	req, err := client.resetProductionSlotConfigCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.resetProductionSlotConfigHandleError(resp)
	}
	return resp.Response, nil
}

// resetProductionSlotConfigCreateRequest creates the ResetProductionSlotConfig request.
func (client *WebAppsClient) resetProductionSlotConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsResetProductionSlotConfigOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// resetProductionSlotConfigHandleError handles the ResetProductionSlotConfig error response.
func (client *WebAppsClient) resetProductionSlotConfigHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResetSlotConfigurationSlot - Description for Resets the configuration settings of the current slot if they were previously modified by calling the API
// with POST.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ResetSlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsResetSlotConfigurationSlotOptions) (*http.Response, error) {
	req, err := client.resetSlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.resetSlotConfigurationSlotHandleError(resp)
	}
	return resp.Response, nil
}

// resetSlotConfigurationSlotCreateRequest creates the ResetSlotConfigurationSlot request.
func (client *WebAppsClient) resetSlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsResetSlotConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// resetSlotConfigurationSlotHandleError handles the ResetSlotConfigurationSlot error response.
func (client *WebAppsClient) resetSlotConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Restart - Description for Restarts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Restart(ctx context.Context, resourceGroupName string, name string, options *WebAppsRestartOptions) (*http.Response, error) {
	req, err := client.restartCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.restartHandleError(resp)
	}
	return resp.Response, nil
}

// restartCreateRequest creates the Restart request.
func (client *WebAppsClient) restartCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsRestartOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// restartHandleError handles the Restart error response.
func (client *WebAppsClient) restartHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RestartSlot - Description for Restarts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RestartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsRestartSlotOptions) (*http.Response, error) {
	req, err := client.restartSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.restartSlotHandleError(resp)
	}
	return resp.Response, nil
}

// restartSlotCreateRequest creates the RestartSlot request.
func (client *WebAppsClient) restartSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsRestartSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// restartSlotHandleError handles the RestartSlot error response.
func (client *WebAppsClient) restartSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestore - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsBeginRestoreOptions) (HTTPPollerResponse, error) {
	resp, err := client.restore(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.Restore", "", resp, client.con.Pipeline(), client.restoreHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestore creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestore(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.Restore", token, client.con.Pipeline(), client.restoreHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Restore - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsBeginRestoreOptions) (*azcore.Response, error) {
	req, err := client.restoreCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreHandleError(resp)
	}
	return resp, nil
}

// restoreCreateRequest creates the Restore request.
func (client *WebAppsClient) restoreCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsBeginRestoreOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// restoreHandleError handles the Restore error response.
func (client *WebAppsClient) restoreHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestoreFromBackupBlob - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobOptions) (HTTPPollerResponse, error) {
	resp, err := client.restoreFromBackupBlob(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.RestoreFromBackupBlob", "", resp, client.con.Pipeline(), client.restoreFromBackupBlobHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestoreFromBackupBlob creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestoreFromBackupBlob(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.RestoreFromBackupBlob", token, client.con.Pipeline(), client.restoreFromBackupBlobHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// RestoreFromBackupBlob - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobOptions) (*azcore.Response, error) {
	req, err := client.restoreFromBackupBlobCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromBackupBlobHandleError(resp)
	}
	return resp, nil
}

// restoreFromBackupBlobCreateRequest creates the RestoreFromBackupBlob request.
func (client *WebAppsClient) restoreFromBackupBlobCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// restoreFromBackupBlobHandleError handles the RestoreFromBackupBlob error response.
func (client *WebAppsClient) restoreFromBackupBlobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestoreFromBackupBlobSlot - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobSlotOptions) (HTTPPollerResponse, error) {
	resp, err := client.restoreFromBackupBlobSlot(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.RestoreFromBackupBlobSlot", "", resp, client.con.Pipeline(), client.restoreFromBackupBlobSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestoreFromBackupBlobSlot creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestoreFromBackupBlobSlot(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.RestoreFromBackupBlobSlot", token, client.con.Pipeline(), client.restoreFromBackupBlobSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// RestoreFromBackupBlobSlot - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobSlotOptions) (*azcore.Response, error) {
	req, err := client.restoreFromBackupBlobSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromBackupBlobSlotHandleError(resp)
	}
	return resp, nil
}

// restoreFromBackupBlobSlotCreateRequest creates the RestoreFromBackupBlobSlot request.
func (client *WebAppsClient) restoreFromBackupBlobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// restoreFromBackupBlobSlotHandleError handles the RestoreFromBackupBlobSlot error response.
func (client *WebAppsClient) restoreFromBackupBlobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestoreFromDeletedApp - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppOptions) (HTTPPollerResponse, error) {
	resp, err := client.restoreFromDeletedApp(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.RestoreFromDeletedApp", "", resp, client.con.Pipeline(), client.restoreFromDeletedAppHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestoreFromDeletedApp creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestoreFromDeletedApp(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.RestoreFromDeletedApp", token, client.con.Pipeline(), client.restoreFromDeletedAppHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// RestoreFromDeletedApp - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppOptions) (*azcore.Response, error) {
	req, err := client.restoreFromDeletedAppCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromDeletedAppHandleError(resp)
	}
	return resp, nil
}

// restoreFromDeletedAppCreateRequest creates the RestoreFromDeletedApp request.
func (client *WebAppsClient) restoreFromDeletedAppCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(restoreRequest)
}

// restoreFromDeletedAppHandleError handles the RestoreFromDeletedApp error response.
func (client *WebAppsClient) restoreFromDeletedAppHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestoreFromDeletedAppSlot - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppSlotOptions) (HTTPPollerResponse, error) {
	resp, err := client.restoreFromDeletedAppSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.RestoreFromDeletedAppSlot", "", resp, client.con.Pipeline(), client.restoreFromDeletedAppSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestoreFromDeletedAppSlot creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestoreFromDeletedAppSlot(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.RestoreFromDeletedAppSlot", token, client.con.Pipeline(), client.restoreFromDeletedAppSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// RestoreFromDeletedAppSlot - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppSlotOptions) (*azcore.Response, error) {
	req, err := client.restoreFromDeletedAppSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromDeletedAppSlotHandleError(resp)
	}
	return resp, nil
}

// restoreFromDeletedAppSlotCreateRequest creates the RestoreFromDeletedAppSlot request.
func (client *WebAppsClient) restoreFromDeletedAppSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(restoreRequest)
}

// restoreFromDeletedAppSlotHandleError handles the RestoreFromDeletedAppSlot error response.
func (client *WebAppsClient) restoreFromDeletedAppSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestoreSlot - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsBeginRestoreSlotOptions) (HTTPPollerResponse, error) {
	resp, err := client.restoreSlot(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.RestoreSlot", "", resp, client.con.Pipeline(), client.restoreSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestoreSlot creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestoreSlot(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.RestoreSlot", token, client.con.Pipeline(), client.restoreSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// RestoreSlot - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsBeginRestoreSlotOptions) (*azcore.Response, error) {
	req, err := client.restoreSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreSlotHandleError(resp)
	}
	return resp, nil
}

// restoreSlotCreateRequest creates the RestoreSlot request.
func (client *WebAppsClient) restoreSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsBeginRestoreSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// restoreSlotHandleError handles the RestoreSlot error response.
func (client *WebAppsClient) restoreSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestoreSnapshot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotOptions) (HTTPPollerResponse, error) {
	resp, err := client.restoreSnapshot(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.RestoreSnapshot", "", resp, client.con.Pipeline(), client.restoreSnapshotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestoreSnapshot creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestoreSnapshot(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.RestoreSnapshot", token, client.con.Pipeline(), client.restoreSnapshotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// RestoreSnapshot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotOptions) (*azcore.Response, error) {
	req, err := client.restoreSnapshotCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreSnapshotHandleError(resp)
	}
	return resp, nil
}

// restoreSnapshotCreateRequest creates the RestoreSnapshot request.
func (client *WebAppsClient) restoreSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(restoreRequest)
}

// restoreSnapshotHandleError handles the RestoreSnapshot error response.
func (client *WebAppsClient) restoreSnapshotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginRestoreSnapshotSlot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotSlotOptions) (HTTPPollerResponse, error) {
	resp, err := client.restoreSnapshotSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.RestoreSnapshotSlot", "", resp, client.con.Pipeline(), client.restoreSnapshotSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeRestoreSnapshotSlot creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeRestoreSnapshotSlot(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.RestoreSnapshotSlot", token, client.con.Pipeline(), client.restoreSnapshotSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// RestoreSnapshotSlot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotSlotOptions) (*azcore.Response, error) {
	req, err := client.restoreSnapshotSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreSnapshotSlotHandleError(resp)
	}
	return resp, nil
}

// restoreSnapshotSlotCreateRequest creates the RestoreSnapshotSlot request.
func (client *WebAppsClient) restoreSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(restoreRequest)
}

// restoreSnapshotSlotHandleError handles the RestoreSnapshotSlot error response.
func (client *WebAppsClient) restoreSnapshotSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RunTriggeredWebJob - Description for Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RunTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsRunTriggeredWebJobOptions) (*http.Response, error) {
	req, err := client.runTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.runTriggeredWebJobHandleError(resp)
	}
	return resp.Response, nil
}

// runTriggeredWebJobCreateRequest creates the RunTriggeredWebJob request.
func (client *WebAppsClient) runTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsRunTriggeredWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// runTriggeredWebJobHandleError handles the RunTriggeredWebJob error response.
func (client *WebAppsClient) runTriggeredWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// RunTriggeredWebJobSlot - Description for Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RunTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsRunTriggeredWebJobSlotOptions) (*http.Response, error) {
	req, err := client.runTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.runTriggeredWebJobSlotHandleError(resp)
	}
	return resp.Response, nil
}

// runTriggeredWebJobSlotCreateRequest creates the RunTriggeredWebJobSlot request.
func (client *WebAppsClient) runTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsRunTriggeredWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// runTriggeredWebJobSlotHandleError handles the RunTriggeredWebJobSlot error response.
func (client *WebAppsClient) runTriggeredWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// Start - Description for Starts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Start(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartOptions) (*http.Response, error) {
	req, err := client.startCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.startHandleError(resp)
	}
	return resp.Response, nil
}

// startCreateRequest creates the Start request.
func (client *WebAppsClient) startCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startHandleError handles the Start error response.
func (client *WebAppsClient) startHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StartContinuousWebJob - Description for Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStartContinuousWebJobOptions) (*http.Response, error) {
	req, err := client.startContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.startContinuousWebJobHandleError(resp)
	}
	return resp.Response, nil
}

// startContinuousWebJobCreateRequest creates the StartContinuousWebJob request.
func (client *WebAppsClient) startContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStartContinuousWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startContinuousWebJobHandleError handles the StartContinuousWebJob error response.
func (client *WebAppsClient) startContinuousWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// StartContinuousWebJobSlot - Description for Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStartContinuousWebJobSlotOptions) (*http.Response, error) {
	req, err := client.startContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.startContinuousWebJobSlotHandleError(resp)
	}
	return resp.Response, nil
}

// startContinuousWebJobSlotCreateRequest creates the StartContinuousWebJobSlot request.
func (client *WebAppsClient) startContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStartContinuousWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startContinuousWebJobSlotHandleError handles the StartContinuousWebJobSlot error response.
func (client *WebAppsClient) startContinuousWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// BeginStartNetworkTrace - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartNetworkTraceOptions) (NetworkTraceArrayPollerResponse, error) {
	resp, err := client.startNetworkTrace(ctx, resourceGroupName, name, options)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.StartNetworkTrace", "", resp, client.con.Pipeline(), client.startNetworkTraceHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeStartNetworkTrace creates a new NetworkTraceArrayPoller from the specified resume token.
// token - The value must come from a previous call to NetworkTraceArrayPoller.ResumeToken().
func (client *WebAppsClient) ResumeStartNetworkTrace(ctx context.Context, token string) (NetworkTraceArrayPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.StartNetworkTrace", token, client.con.Pipeline(), client.startNetworkTraceHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// StartNetworkTrace - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartNetworkTraceOptions) (*azcore.Response, error) {
	req, err := client.startNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.startNetworkTraceHandleError(resp)
	}
	return resp, nil
}

// startNetworkTraceCreateRequest creates the StartNetworkTrace request.
func (client *WebAppsClient) startNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartNetworkTraceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startNetworkTraceHandleError handles the StartNetworkTrace error response.
func (client *WebAppsClient) startNetworkTraceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginStartNetworkTraceSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartNetworkTraceSlotOptions) (NetworkTraceArrayPollerResponse, error) {
	resp, err := client.startNetworkTraceSlot(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.StartNetworkTraceSlot", "", resp, client.con.Pipeline(), client.startNetworkTraceSlotHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeStartNetworkTraceSlot creates a new NetworkTraceArrayPoller from the specified resume token.
// token - The value must come from a previous call to NetworkTraceArrayPoller.ResumeToken().
func (client *WebAppsClient) ResumeStartNetworkTraceSlot(ctx context.Context, token string) (NetworkTraceArrayPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.StartNetworkTraceSlot", token, client.con.Pipeline(), client.startNetworkTraceSlotHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// StartNetworkTraceSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartNetworkTraceSlotOptions) (*azcore.Response, error) {
	req, err := client.startNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.startNetworkTraceSlotHandleError(resp)
	}
	return resp, nil
}

// startNetworkTraceSlotCreateRequest creates the StartNetworkTraceSlot request.
func (client *WebAppsClient) startNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartNetworkTraceSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startNetworkTraceSlotHandleError handles the StartNetworkTraceSlot error response.
func (client *WebAppsClient) startNetworkTraceSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StartSlot - Description for Starts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartSlotOptions) (*http.Response, error) {
	req, err := client.startSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.startSlotHandleError(resp)
	}
	return resp.Response, nil
}

// startSlotCreateRequest creates the StartSlot request.
func (client *WebAppsClient) startSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startSlotHandleError handles the StartSlot error response.
func (client *WebAppsClient) startSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StartWebSiteNetworkTrace - Description for Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartWebSiteNetworkTraceOptions) (StringResponse, error) {
	req, err := client.startWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return StringResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringResponse{}, client.startWebSiteNetworkTraceHandleError(resp)
	}
	return client.startWebSiteNetworkTraceHandleResponse(resp)
}

// startWebSiteNetworkTraceCreateRequest creates the StartWebSiteNetworkTrace request.
func (client *WebAppsClient) startWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartWebSiteNetworkTraceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceHandleResponse handles the StartWebSiteNetworkTrace response.
func (client *WebAppsClient) startWebSiteNetworkTraceHandleResponse(resp *azcore.Response) (StringResponse, error) {
	var val *string
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringResponse{}, err
	}
	return StringResponse{RawResponse: resp.Response, Value: val}, nil
}

// startWebSiteNetworkTraceHandleError handles the StartWebSiteNetworkTrace error response.
func (client *WebAppsClient) startWebSiteNetworkTraceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginStartWebSiteNetworkTraceOperation - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartWebSiteNetworkTraceOperationOptions) (NetworkTraceArrayPollerResponse, error) {
	resp, err := client.startWebSiteNetworkTraceOperation(ctx, resourceGroupName, name, options)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.StartWebSiteNetworkTraceOperation", "", resp, client.con.Pipeline(), client.startWebSiteNetworkTraceOperationHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeStartWebSiteNetworkTraceOperation creates a new NetworkTraceArrayPoller from the specified resume token.
// token - The value must come from a previous call to NetworkTraceArrayPoller.ResumeToken().
func (client *WebAppsClient) ResumeStartWebSiteNetworkTraceOperation(ctx context.Context, token string) (NetworkTraceArrayPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.StartWebSiteNetworkTraceOperation", token, client.con.Pipeline(), client.startWebSiteNetworkTraceOperationHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// StartWebSiteNetworkTraceOperation - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartWebSiteNetworkTraceOperationOptions) (*azcore.Response, error) {
	req, err := client.startWebSiteNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.startWebSiteNetworkTraceOperationHandleError(resp)
	}
	return resp, nil
}

// startWebSiteNetworkTraceOperationCreateRequest creates the StartWebSiteNetworkTraceOperation request.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartWebSiteNetworkTraceOperationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceOperationHandleError handles the StartWebSiteNetworkTraceOperation error response.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginStartWebSiteNetworkTraceOperationSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartWebSiteNetworkTraceOperationSlotOptions) (NetworkTraceArrayPollerResponse, error) {
	resp, err := client.startWebSiteNetworkTraceOperationSlot(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.StartWebSiteNetworkTraceOperationSlot", "", resp, client.con.Pipeline(), client.startWebSiteNetworkTraceOperationSlotHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeStartWebSiteNetworkTraceOperationSlot creates a new NetworkTraceArrayPoller from the specified resume token.
// token - The value must come from a previous call to NetworkTraceArrayPoller.ResumeToken().
func (client *WebAppsClient) ResumeStartWebSiteNetworkTraceOperationSlot(ctx context.Context, token string) (NetworkTraceArrayPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.StartWebSiteNetworkTraceOperationSlot", token, client.con.Pipeline(), client.startWebSiteNetworkTraceOperationSlotHandleError)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	poller := &networkTraceArrayPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return NetworkTraceArrayPollerResponse{}, err
	}
	result := NetworkTraceArrayPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (NetworkTraceArrayResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// StartWebSiteNetworkTraceOperationSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartWebSiteNetworkTraceOperationSlotOptions) (*azcore.Response, error) {
	req, err := client.startWebSiteNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.startWebSiteNetworkTraceOperationSlotHandleError(resp)
	}
	return resp, nil
}

// startWebSiteNetworkTraceOperationSlotCreateRequest creates the StartWebSiteNetworkTraceOperationSlot request.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartWebSiteNetworkTraceOperationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceOperationSlotHandleError handles the StartWebSiteNetworkTraceOperationSlot error response.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StartWebSiteNetworkTraceSlot - Description for Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartWebSiteNetworkTraceSlotOptions) (StringResponse, error) {
	req, err := client.startWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return StringResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringResponse{}, client.startWebSiteNetworkTraceSlotHandleError(resp)
	}
	return client.startWebSiteNetworkTraceSlotHandleResponse(resp)
}

// startWebSiteNetworkTraceSlotCreateRequest creates the StartWebSiteNetworkTraceSlot request.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartWebSiteNetworkTraceSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceSlotHandleResponse handles the StartWebSiteNetworkTraceSlot response.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotHandleResponse(resp *azcore.Response) (StringResponse, error) {
	var val *string
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringResponse{}, err
	}
	return StringResponse{RawResponse: resp.Response, Value: val}, nil
}

// startWebSiteNetworkTraceSlotHandleError handles the StartWebSiteNetworkTraceSlot error response.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Stop - Description for Stops an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Stop(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopOptions) (*http.Response, error) {
	req, err := client.stopCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.stopHandleError(resp)
	}
	return resp.Response, nil
}

// stopCreateRequest creates the Stop request.
func (client *WebAppsClient) stopCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopHandleError handles the Stop error response.
func (client *WebAppsClient) stopHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StopContinuousWebJob - Description for Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStopContinuousWebJobOptions) (*http.Response, error) {
	req, err := client.stopContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.stopContinuousWebJobHandleError(resp)
	}
	return resp.Response, nil
}

// stopContinuousWebJobCreateRequest creates the StopContinuousWebJob request.
func (client *WebAppsClient) stopContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStopContinuousWebJobOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopContinuousWebJobHandleError handles the StopContinuousWebJob error response.
func (client *WebAppsClient) stopContinuousWebJobHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// StopContinuousWebJobSlot - Description for Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStopContinuousWebJobSlotOptions) (*http.Response, error) {
	req, err := client.stopContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.stopContinuousWebJobSlotHandleError(resp)
	}
	return resp.Response, nil
}

// stopContinuousWebJobSlotCreateRequest creates the StopContinuousWebJobSlot request.
func (client *WebAppsClient) stopContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStopContinuousWebJobSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopContinuousWebJobSlotHandleError handles the StopContinuousWebJobSlot error response.
func (client *WebAppsClient) stopContinuousWebJobSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
		}
		return azcore.NewResponseError(errors.New(string(body)), resp.Response)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := resp.UnmarshalAsJSON(&errType); err != nil {
			return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
		}
		return azcore.NewResponseError(&errType, resp.Response)
	}
}

// StopNetworkTrace - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopNetworkTraceOptions) (*http.Response, error) {
	req, err := client.stopNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.stopNetworkTraceHandleError(resp)
	}
	return resp.Response, nil
}

// stopNetworkTraceCreateRequest creates the StopNetworkTrace request.
func (client *WebAppsClient) stopNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopNetworkTraceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopNetworkTraceHandleError handles the StopNetworkTrace error response.
func (client *WebAppsClient) stopNetworkTraceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StopNetworkTraceSlot - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopNetworkTraceSlotOptions) (*http.Response, error) {
	req, err := client.stopNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.stopNetworkTraceSlotHandleError(resp)
	}
	return resp.Response, nil
}

// stopNetworkTraceSlotCreateRequest creates the StopNetworkTraceSlot request.
func (client *WebAppsClient) stopNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopNetworkTraceSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopNetworkTraceSlotHandleError handles the StopNetworkTraceSlot error response.
func (client *WebAppsClient) stopNetworkTraceSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StopSlot - Description for Stops an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopSlotOptions) (*http.Response, error) {
	req, err := client.stopSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.stopSlotHandleError(resp)
	}
	return resp.Response, nil
}

// stopSlotCreateRequest creates the StopSlot request.
func (client *WebAppsClient) stopSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopSlotHandleError handles the StopSlot error response.
func (client *WebAppsClient) stopSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StopWebSiteNetworkTrace - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopWebSiteNetworkTraceOptions) (*http.Response, error) {
	req, err := client.stopWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.stopWebSiteNetworkTraceHandleError(resp)
	}
	return resp.Response, nil
}

// stopWebSiteNetworkTraceCreateRequest creates the StopWebSiteNetworkTrace request.
func (client *WebAppsClient) stopWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopWebSiteNetworkTraceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopWebSiteNetworkTraceHandleError handles the StopWebSiteNetworkTrace error response.
func (client *WebAppsClient) stopWebSiteNetworkTraceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// StopWebSiteNetworkTraceSlot - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopWebSiteNetworkTraceSlotOptions) (*http.Response, error) {
	req, err := client.stopWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.stopWebSiteNetworkTraceSlotHandleError(resp)
	}
	return resp.Response, nil
}

// stopWebSiteNetworkTraceSlotCreateRequest creates the StopWebSiteNetworkTraceSlot request.
func (client *WebAppsClient) stopWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopWebSiteNetworkTraceSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// stopWebSiteNetworkTraceSlotHandleError handles the StopWebSiteNetworkTraceSlot error response.
func (client *WebAppsClient) stopWebSiteNetworkTraceSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginSwapSlot - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginSwapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotOptions) (HTTPPollerResponse, error) {
	resp, err := client.swapSlot(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.SwapSlot", "", resp, client.con.Pipeline(), client.swapSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeSwapSlot creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeSwapSlot(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.SwapSlot", token, client.con.Pipeline(), client.swapSlotHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// SwapSlot - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) swapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotOptions) (*azcore.Response, error) {
	req, err := client.swapSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.swapSlotHandleError(resp)
	}
	return resp, nil
}

// swapSlotCreateRequest creates the SwapSlot request.
func (client *WebAppsClient) swapSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(slotSwapEntity)
}

// swapSlotHandleError handles the SwapSlot error response.
func (client *WebAppsClient) swapSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginSwapSlotWithProduction - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginSwapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotWithProductionOptions) (HTTPPollerResponse, error) {
	resp, err := client.swapSlotWithProduction(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewLROPoller("WebAppsClient.SwapSlotWithProduction", "", resp, client.con.Pipeline(), client.swapSlotWithProductionHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeSwapSlotWithProduction creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *WebAppsClient) ResumeSwapSlotWithProduction(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewLROPollerFromResumeToken("WebAppsClient.SwapSlotWithProduction", token, client.con.Pipeline(), client.swapSlotWithProductionHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// SwapSlotWithProduction - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) swapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotWithProductionOptions) (*azcore.Response, error) {
	req, err := client.swapSlotWithProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.swapSlotWithProductionHandleError(resp)
	}
	return resp, nil
}

// swapSlotWithProductionCreateRequest creates the SwapSlotWithProduction request.
func (client *WebAppsClient) swapSlotWithProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotWithProductionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(slotSwapEntity)
}

// swapSlotWithProductionHandleError handles the SwapSlotWithProduction error response.
func (client *WebAppsClient) swapSlotWithProductionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SyncFunctionTriggers - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionTriggersOptions) (*http.Response, error) {
	req, err := client.syncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.syncFunctionTriggersHandleError(resp)
	}
	return resp.Response, nil
}

// syncFunctionTriggersCreateRequest creates the SyncFunctionTriggers request.
func (client *WebAppsClient) syncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionTriggersOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionTriggersHandleError handles the SyncFunctionTriggers error response.
func (client *WebAppsClient) syncFunctionTriggersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SyncFunctionTriggersSlot - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionTriggersSlotOptions) (*http.Response, error) {
	req, err := client.syncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.syncFunctionTriggersSlotHandleError(resp)
	}
	return resp.Response, nil
}

// syncFunctionTriggersSlotCreateRequest creates the SyncFunctionTriggersSlot request.
func (client *WebAppsClient) syncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionTriggersSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionTriggersSlotHandleError handles the SyncFunctionTriggersSlot error response.
func (client *WebAppsClient) syncFunctionTriggersSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SyncFunctions - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctions(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionsOptions) (*http.Response, error) {
	req, err := client.syncFunctionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.syncFunctionsHandleError(resp)
	}
	return resp.Response, nil
}

// syncFunctionsCreateRequest creates the SyncFunctions request.
func (client *WebAppsClient) syncFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionsHandleError handles the SyncFunctions error response.
func (client *WebAppsClient) syncFunctionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SyncFunctionsSlot - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionsSlotOptions) (*http.Response, error) {
	req, err := client.syncFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.syncFunctionsSlotHandleError(resp)
	}
	return resp.Response, nil
}

// syncFunctionsSlotCreateRequest creates the SyncFunctionsSlot request.
func (client *WebAppsClient) syncFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionsSlotHandleError handles the SyncFunctionsSlot error response.
func (client *WebAppsClient) syncFunctionsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SyncRepository - Description for Sync web app repository.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncRepository(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncRepositoryOptions) (*http.Response, error) {
	req, err := client.syncRepositoryCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.syncRepositoryHandleError(resp)
	}
	return resp.Response, nil
}

// syncRepositoryCreateRequest creates the SyncRepository request.
func (client *WebAppsClient) syncRepositoryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncRepositoryOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// syncRepositoryHandleError handles the SyncRepository error response.
func (client *WebAppsClient) syncRepositoryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SyncRepositorySlot - Description for Sync web app repository.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncRepositorySlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncRepositorySlotOptions) (*http.Response, error) {
	req, err := client.syncRepositorySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.syncRepositorySlotHandleError(resp)
	}
	return resp.Response, nil
}

// syncRepositorySlotCreateRequest creates the SyncRepositorySlot request.
func (client *WebAppsClient) syncRepositorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncRepositorySlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// syncRepositorySlotHandleError handles the SyncRepositorySlot error response.
func (client *WebAppsClient) syncRepositorySlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Update - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Update(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *WebAppsUpdateOptions) (SiteResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return SiteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return SiteResponse{}, client.updateHandleError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *WebAppsClient) updateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *WebAppsUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteEnvelope)
}

// updateHandleResponse handles the Update response.
func (client *WebAppsClient) updateHandleResponse(resp *azcore.Response) (SiteResponse, error) {
	var val *Site
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteResponse{}, err
	}
	return SiteResponse{RawResponse: resp.Response, Site: val}, nil
}

// updateHandleError handles the Update error response.
func (client *WebAppsClient) updateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateApplicationSettings - Description for Replaces the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateApplicationSettings(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsOptions) (StringDictionaryResponse, error) {
	req, err := client.updateApplicationSettingsCreateRequest(ctx, resourceGroupName, name, appSettings, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.updateApplicationSettingsHandleError(resp)
	}
	return client.updateApplicationSettingsHandleResponse(resp)
}

// updateApplicationSettingsCreateRequest creates the UpdateApplicationSettings request.
func (client *WebAppsClient) updateApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(appSettings)
}

// updateApplicationSettingsHandleResponse handles the UpdateApplicationSettings response.
func (client *WebAppsClient) updateApplicationSettingsHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// updateApplicationSettingsHandleError handles the UpdateApplicationSettings error response.
func (client *WebAppsClient) updateApplicationSettingsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateApplicationSettingsSlot - Description for Replaces the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsSlotOptions) (StringDictionaryResponse, error) {
	req, err := client.updateApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, appSettings, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.updateApplicationSettingsSlotHandleError(resp)
	}
	return client.updateApplicationSettingsSlotHandleResponse(resp)
}

// updateApplicationSettingsSlotCreateRequest creates the UpdateApplicationSettingsSlot request.
func (client *WebAppsClient) updateApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(appSettings)
}

// updateApplicationSettingsSlotHandleResponse handles the UpdateApplicationSettingsSlot response.
func (client *WebAppsClient) updateApplicationSettingsSlotHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// updateApplicationSettingsSlotHandleError handles the UpdateApplicationSettingsSlot error response.
func (client *WebAppsClient) updateApplicationSettingsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateAuthSettings - Description for Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettings(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsOptions) (SiteAuthSettingsResponse, error) {
	req, err := client.updateAuthSettingsCreateRequest(ctx, resourceGroupName, name, siteAuthSettings, options)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsResponse{}, client.updateAuthSettingsHandleError(resp)
	}
	return client.updateAuthSettingsHandleResponse(resp)
}

// updateAuthSettingsCreateRequest creates the UpdateAuthSettings request.
func (client *WebAppsClient) updateAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteAuthSettings)
}

// updateAuthSettingsHandleResponse handles the UpdateAuthSettings response.
func (client *WebAppsClient) updateAuthSettingsHandleResponse(resp *azcore.Response) (SiteAuthSettingsResponse, error) {
	var val *SiteAuthSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	return SiteAuthSettingsResponse{RawResponse: resp.Response, SiteAuthSettings: val}, nil
}

// updateAuthSettingsHandleError handles the UpdateAuthSettings error response.
func (client *WebAppsClient) updateAuthSettingsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateAuthSettingsSlot - Description for Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsSlotOptions) (SiteAuthSettingsResponse, error) {
	req, err := client.updateAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, siteAuthSettings, options)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsResponse{}, client.updateAuthSettingsSlotHandleError(resp)
	}
	return client.updateAuthSettingsSlotHandleResponse(resp)
}

// updateAuthSettingsSlotCreateRequest creates the UpdateAuthSettingsSlot request.
func (client *WebAppsClient) updateAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteAuthSettings)
}

// updateAuthSettingsSlotHandleResponse handles the UpdateAuthSettingsSlot response.
func (client *WebAppsClient) updateAuthSettingsSlotHandleResponse(resp *azcore.Response) (SiteAuthSettingsResponse, error) {
	var val *SiteAuthSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsResponse{}, err
	}
	return SiteAuthSettingsResponse{RawResponse: resp.Response, SiteAuthSettings: val}, nil
}

// updateAuthSettingsSlotHandleError handles the UpdateAuthSettingsSlot error response.
func (client *WebAppsClient) updateAuthSettingsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateAuthSettingsV2 - Description for Updates site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettingsV2(ctx context.Context, resourceGroupName string, name string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2Options) (SiteAuthSettingsV2Response, error) {
	req, err := client.updateAuthSettingsV2CreateRequest(ctx, resourceGroupName, name, siteAuthSettingsV2, options)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsV2Response{}, client.updateAuthSettingsV2HandleError(resp)
	}
	return client.updateAuthSettingsV2HandleResponse(resp)
}

// updateAuthSettingsV2CreateRequest creates the UpdateAuthSettingsV2 request.
func (client *WebAppsClient) updateAuthSettingsV2CreateRequest(ctx context.Context, resourceGroupName string, name string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2Options) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteAuthSettingsV2)
}

// updateAuthSettingsV2HandleResponse handles the UpdateAuthSettingsV2 response.
func (client *WebAppsClient) updateAuthSettingsV2HandleResponse(resp *azcore.Response) (SiteAuthSettingsV2Response, error) {
	var val *SiteAuthSettingsV2
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	return SiteAuthSettingsV2Response{RawResponse: resp.Response, SiteAuthSettingsV2: val}, nil
}

// updateAuthSettingsV2HandleError handles the UpdateAuthSettingsV2 error response.
func (client *WebAppsClient) updateAuthSettingsV2HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateAuthSettingsV2Slot - Description for Updates site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettingsV2Slot(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2SlotOptions) (SiteAuthSettingsV2Response, error) {
	req, err := client.updateAuthSettingsV2SlotCreateRequest(ctx, resourceGroupName, name, slot, siteAuthSettingsV2, options)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteAuthSettingsV2Response{}, client.updateAuthSettingsV2SlotHandleError(resp)
	}
	return client.updateAuthSettingsV2SlotHandleResponse(resp)
}

// updateAuthSettingsV2SlotCreateRequest creates the UpdateAuthSettingsV2Slot request.
func (client *WebAppsClient) updateAuthSettingsV2SlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2SlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteAuthSettingsV2)
}

// updateAuthSettingsV2SlotHandleResponse handles the UpdateAuthSettingsV2Slot response.
func (client *WebAppsClient) updateAuthSettingsV2SlotHandleResponse(resp *azcore.Response) (SiteAuthSettingsV2Response, error) {
	var val *SiteAuthSettingsV2
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteAuthSettingsV2Response{}, err
	}
	return SiteAuthSettingsV2Response{RawResponse: resp.Response, SiteAuthSettingsV2: val}, nil
}

// updateAuthSettingsV2SlotHandleError handles the UpdateAuthSettingsV2Slot error response.
func (client *WebAppsClient) updateAuthSettingsV2SlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateAzureStorageAccounts - Description for Updates the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsOptions) (AzureStoragePropertyDictionaryResourceResponse, error) {
	req, err := client.updateAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, azureStorageAccounts, options)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return AzureStoragePropertyDictionaryResourceResponse{}, client.updateAzureStorageAccountsHandleError(resp)
	}
	return client.updateAzureStorageAccountsHandleResponse(resp)
}

// updateAzureStorageAccountsCreateRequest creates the UpdateAzureStorageAccounts request.
func (client *WebAppsClient) updateAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(azureStorageAccounts)
}

// updateAzureStorageAccountsHandleResponse handles the UpdateAzureStorageAccounts response.
func (client *WebAppsClient) updateAzureStorageAccountsHandleResponse(resp *azcore.Response) (AzureStoragePropertyDictionaryResourceResponse, error) {
	var val *AzureStoragePropertyDictionaryResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	return AzureStoragePropertyDictionaryResourceResponse{RawResponse: resp.Response, AzureStoragePropertyDictionaryResource: val}, nil
}

// updateAzureStorageAccountsHandleError handles the UpdateAzureStorageAccounts error response.
func (client *WebAppsClient) updateAzureStorageAccountsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateAzureStorageAccountsSlot - Description for Updates the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsSlotOptions) (AzureStoragePropertyDictionaryResourceResponse, error) {
	req, err := client.updateAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, azureStorageAccounts, options)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return AzureStoragePropertyDictionaryResourceResponse{}, client.updateAzureStorageAccountsSlotHandleError(resp)
	}
	return client.updateAzureStorageAccountsSlotHandleResponse(resp)
}

// updateAzureStorageAccountsSlotCreateRequest creates the UpdateAzureStorageAccountsSlot request.
func (client *WebAppsClient) updateAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(azureStorageAccounts)
}

// updateAzureStorageAccountsSlotHandleResponse handles the UpdateAzureStorageAccountsSlot response.
func (client *WebAppsClient) updateAzureStorageAccountsSlotHandleResponse(resp *azcore.Response) (AzureStoragePropertyDictionaryResourceResponse, error) {
	var val *AzureStoragePropertyDictionaryResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return AzureStoragePropertyDictionaryResourceResponse{}, err
	}
	return AzureStoragePropertyDictionaryResourceResponse{RawResponse: resp.Response, AzureStoragePropertyDictionaryResource: val}, nil
}

// updateAzureStorageAccountsSlotHandleError handles the UpdateAzureStorageAccountsSlot error response.
func (client *WebAppsClient) updateAzureStorageAccountsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateBackupConfiguration - Description for Updates the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateBackupConfiguration(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsUpdateBackupConfigurationOptions) (BackupRequestResponse, error) {
	req, err := client.updateBackupConfigurationCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupRequestResponse{}, client.updateBackupConfigurationHandleError(resp)
	}
	return client.updateBackupConfigurationHandleResponse(resp)
}

// updateBackupConfigurationCreateRequest creates the UpdateBackupConfiguration request.
func (client *WebAppsClient) updateBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsUpdateBackupConfigurationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// updateBackupConfigurationHandleResponse handles the UpdateBackupConfiguration response.
func (client *WebAppsClient) updateBackupConfigurationHandleResponse(resp *azcore.Response) (BackupRequestResponse, error) {
	var val *BackupRequest
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupRequestResponse{}, err
	}
	return BackupRequestResponse{RawResponse: resp.Response, BackupRequest: val}, nil
}

// updateBackupConfigurationHandleError handles the UpdateBackupConfiguration error response.
func (client *WebAppsClient) updateBackupConfigurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateBackupConfigurationSlot - Description for Updates the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsUpdateBackupConfigurationSlotOptions) (BackupRequestResponse, error) {
	req, err := client.updateBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupRequestResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupRequestResponse{}, client.updateBackupConfigurationSlotHandleError(resp)
	}
	return client.updateBackupConfigurationSlotHandleResponse(resp)
}

// updateBackupConfigurationSlotCreateRequest creates the UpdateBackupConfigurationSlot request.
func (client *WebAppsClient) updateBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsUpdateBackupConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// updateBackupConfigurationSlotHandleResponse handles the UpdateBackupConfigurationSlot response.
func (client *WebAppsClient) updateBackupConfigurationSlotHandleResponse(resp *azcore.Response) (BackupRequestResponse, error) {
	var val *BackupRequest
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupRequestResponse{}, err
	}
	return BackupRequestResponse{RawResponse: resp.Response, BackupRequest: val}, nil
}

// updateBackupConfigurationSlotHandleError handles the UpdateBackupConfigurationSlot error response.
func (client *WebAppsClient) updateBackupConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateConfiguration - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationOptions) (SiteConfigResourceResponse, error) {
	req, err := client.updateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.updateConfigurationHandleError(resp)
	}
	return client.updateConfigurationHandleResponse(resp)
}

// updateConfigurationCreateRequest creates the UpdateConfiguration request.
func (client *WebAppsClient) updateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteConfig)
}

// updateConfigurationHandleResponse handles the UpdateConfiguration response.
func (client *WebAppsClient) updateConfigurationHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// updateConfigurationHandleError handles the UpdateConfiguration error response.
func (client *WebAppsClient) updateConfigurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateConfigurationSlot - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationSlotOptions) (SiteConfigResourceResponse, error) {
	req, err := client.updateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteConfigResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteConfigResourceResponse{}, client.updateConfigurationSlotHandleError(resp)
	}
	return client.updateConfigurationSlotHandleResponse(resp)
}

// updateConfigurationSlotCreateRequest creates the UpdateConfigurationSlot request.
func (client *WebAppsClient) updateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteConfig)
}

// updateConfigurationSlotHandleResponse handles the UpdateConfigurationSlot response.
func (client *WebAppsClient) updateConfigurationSlotHandleResponse(resp *azcore.Response) (SiteConfigResourceResponse, error) {
	var val *SiteConfigResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteConfigResourceResponse{}, err
	}
	return SiteConfigResourceResponse{RawResponse: resp.Response, SiteConfigResource: val}, nil
}

// updateConfigurationSlotHandleError handles the UpdateConfigurationSlot error response.
func (client *WebAppsClient) updateConfigurationSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateConnectionStrings - Description for Replaces the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConnectionStrings(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsOptions) (ConnectionStringDictionaryResponse, error) {
	req, err := client.updateConnectionStringsCreateRequest(ctx, resourceGroupName, name, connectionStrings, options)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ConnectionStringDictionaryResponse{}, client.updateConnectionStringsHandleError(resp)
	}
	return client.updateConnectionStringsHandleResponse(resp)
}

// updateConnectionStringsCreateRequest creates the UpdateConnectionStrings request.
func (client *WebAppsClient) updateConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionStrings)
}

// updateConnectionStringsHandleResponse handles the UpdateConnectionStrings response.
func (client *WebAppsClient) updateConnectionStringsHandleResponse(resp *azcore.Response) (ConnectionStringDictionaryResponse, error) {
	var val *ConnectionStringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	return ConnectionStringDictionaryResponse{RawResponse: resp.Response, ConnectionStringDictionary: val}, nil
}

// updateConnectionStringsHandleError handles the UpdateConnectionStrings error response.
func (client *WebAppsClient) updateConnectionStringsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateConnectionStringsSlot - Description for Replaces the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsSlotOptions) (ConnectionStringDictionaryResponse, error) {
	req, err := client.updateConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionStrings, options)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ConnectionStringDictionaryResponse{}, client.updateConnectionStringsSlotHandleError(resp)
	}
	return client.updateConnectionStringsSlotHandleResponse(resp)
}

// updateConnectionStringsSlotCreateRequest creates the UpdateConnectionStringsSlot request.
func (client *WebAppsClient) updateConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionStrings)
}

// updateConnectionStringsSlotHandleResponse handles the UpdateConnectionStringsSlot response.
func (client *WebAppsClient) updateConnectionStringsSlotHandleResponse(resp *azcore.Response) (ConnectionStringDictionaryResponse, error) {
	var val *ConnectionStringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ConnectionStringDictionaryResponse{}, err
	}
	return ConnectionStringDictionaryResponse{RawResponse: resp.Response, ConnectionStringDictionary: val}, nil
}

// updateConnectionStringsSlotHandleError handles the UpdateConnectionStringsSlot error response.
func (client *WebAppsClient) updateConnectionStringsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateDiagnosticLogsConfig - Description for Updates the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDiagnosticLogsConfig(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigOptions) (SiteLogsConfigResponse, error) {
	req, err := client.updateDiagnosticLogsConfigCreateRequest(ctx, resourceGroupName, name, siteLogsConfig, options)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteLogsConfigResponse{}, client.updateDiagnosticLogsConfigHandleError(resp)
	}
	return client.updateDiagnosticLogsConfigHandleResponse(resp)
}

// updateDiagnosticLogsConfigCreateRequest creates the UpdateDiagnosticLogsConfig request.
func (client *WebAppsClient) updateDiagnosticLogsConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteLogsConfig)
}

// updateDiagnosticLogsConfigHandleResponse handles the UpdateDiagnosticLogsConfig response.
func (client *WebAppsClient) updateDiagnosticLogsConfigHandleResponse(resp *azcore.Response) (SiteLogsConfigResponse, error) {
	var val *SiteLogsConfig
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteLogsConfigResponse{}, err
	}
	return SiteLogsConfigResponse{RawResponse: resp.Response, SiteLogsConfig: val}, nil
}

// updateDiagnosticLogsConfigHandleError handles the UpdateDiagnosticLogsConfig error response.
func (client *WebAppsClient) updateDiagnosticLogsConfigHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateDiagnosticLogsConfigSlot - Description for Updates the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDiagnosticLogsConfigSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigSlotOptions) (SiteLogsConfigResponse, error) {
	req, err := client.updateDiagnosticLogsConfigSlotCreateRequest(ctx, resourceGroupName, name, slot, siteLogsConfig, options)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteLogsConfigResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SiteLogsConfigResponse{}, client.updateDiagnosticLogsConfigSlotHandleError(resp)
	}
	return client.updateDiagnosticLogsConfigSlotHandleResponse(resp)
}

// updateDiagnosticLogsConfigSlotCreateRequest creates the UpdateDiagnosticLogsConfigSlot request.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteLogsConfig)
}

// updateDiagnosticLogsConfigSlotHandleResponse handles the UpdateDiagnosticLogsConfigSlot response.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotHandleResponse(resp *azcore.Response) (SiteLogsConfigResponse, error) {
	var val *SiteLogsConfig
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteLogsConfigResponse{}, err
	}
	return SiteLogsConfigResponse{RawResponse: resp.Response, SiteLogsConfig: val}, nil
}

// updateDiagnosticLogsConfigSlotHandleError handles the UpdateDiagnosticLogsConfigSlot error response.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateDomainOwnershipIdentifier - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierOptions) (IdentifierResponse, error) {
	req, err := client.updateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return IdentifierResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IdentifierResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IdentifierResponse{}, client.updateDomainOwnershipIdentifierHandleError(resp)
	}
	return client.updateDomainOwnershipIdentifierHandleResponse(resp)
}

// updateDomainOwnershipIdentifierCreateRequest creates the UpdateDomainOwnershipIdentifier request.
func (client *WebAppsClient) updateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(domainOwnershipIdentifier)
}

// updateDomainOwnershipIdentifierHandleResponse handles the UpdateDomainOwnershipIdentifier response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierHandleResponse(resp *azcore.Response) (IdentifierResponse, error) {
	var val *Identifier
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierResponse{}, err
	}
	return IdentifierResponse{RawResponse: resp.Response, Identifier: val}, nil
}

// updateDomainOwnershipIdentifierHandleError handles the UpdateDomainOwnershipIdentifier error response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateDomainOwnershipIdentifierSlot - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierSlotOptions) (IdentifierResponse, error) {
	req, err := client.updateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return IdentifierResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IdentifierResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IdentifierResponse{}, client.updateDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return client.updateDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// updateDomainOwnershipIdentifierSlotCreateRequest creates the UpdateDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(domainOwnershipIdentifier)
}

// updateDomainOwnershipIdentifierSlotHandleResponse handles the UpdateDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotHandleResponse(resp *azcore.Response) (IdentifierResponse, error) {
	var val *Identifier
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierResponse{}, err
	}
	return IdentifierResponse{RawResponse: resp.Response, Identifier: val}, nil
}

// updateDomainOwnershipIdentifierSlotHandleError handles the UpdateDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateFtpAllowed - Description for Updates whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateFtpAllowed(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.updateFtpAllowedCreateRequest(ctx, resourceGroupName, name, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.updateFtpAllowedHandleError(resp)
	}
	return client.updateFtpAllowedHandleResponse(resp)
}

// updateFtpAllowedCreateRequest creates the UpdateFtpAllowed request.
func (client *WebAppsClient) updateFtpAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(csmPublishingAccessPoliciesEntity)
}

// updateFtpAllowedHandleResponse handles the UpdateFtpAllowed response.
func (client *WebAppsClient) updateFtpAllowedHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// updateFtpAllowedHandleError handles the UpdateFtpAllowed error response.
func (client *WebAppsClient) updateFtpAllowedHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateFtpAllowedSlot - Description for Updates whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateFtpAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedSlotOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.updateFtpAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.updateFtpAllowedSlotHandleError(resp)
	}
	return client.updateFtpAllowedSlotHandleResponse(resp)
}

// updateFtpAllowedSlotCreateRequest creates the UpdateFtpAllowedSlot request.
func (client *WebAppsClient) updateFtpAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(csmPublishingAccessPoliciesEntity)
}

// updateFtpAllowedSlotHandleResponse handles the UpdateFtpAllowedSlot response.
func (client *WebAppsClient) updateFtpAllowedSlotHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// updateFtpAllowedSlotHandleError handles the UpdateFtpAllowedSlot error response.
func (client *WebAppsClient) updateFtpAllowedSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateHybridConnection - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionOptions) (HybridConnectionResponse, error) {
	req, err := client.updateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.updateHybridConnectionHandleError(resp)
	}
	return client.updateHybridConnectionHandleResponse(resp)
}

// updateHybridConnectionCreateRequest creates the UpdateHybridConnection request.
func (client *WebAppsClient) updateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateHybridConnectionHandleResponse handles the UpdateHybridConnection response.
func (client *WebAppsClient) updateHybridConnectionHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// updateHybridConnectionHandleError handles the UpdateHybridConnection error response.
func (client *WebAppsClient) updateHybridConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateHybridConnectionSlot - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionSlotOptions) (HybridConnectionResponse, error) {
	req, err := client.updateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HybridConnectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HybridConnectionResponse{}, client.updateHybridConnectionSlotHandleError(resp)
	}
	return client.updateHybridConnectionSlotHandleResponse(resp)
}

// updateHybridConnectionSlotCreateRequest creates the UpdateHybridConnectionSlot request.
func (client *WebAppsClient) updateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateHybridConnectionSlotHandleResponse handles the UpdateHybridConnectionSlot response.
func (client *WebAppsClient) updateHybridConnectionSlotHandleResponse(resp *azcore.Response) (HybridConnectionResponse, error) {
	var val *HybridConnection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HybridConnectionResponse{}, err
	}
	return HybridConnectionResponse{RawResponse: resp.Response, HybridConnection: val}, nil
}

// updateHybridConnectionSlotHandleError handles the UpdateHybridConnectionSlot error response.
func (client *WebAppsClient) updateHybridConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateMetadata - Description for Replaces the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateMetadata(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *WebAppsUpdateMetadataOptions) (StringDictionaryResponse, error) {
	req, err := client.updateMetadataCreateRequest(ctx, resourceGroupName, name, metadata, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.updateMetadataHandleError(resp)
	}
	return client.updateMetadataHandleResponse(resp)
}

// updateMetadataCreateRequest creates the UpdateMetadata request.
func (client *WebAppsClient) updateMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *WebAppsUpdateMetadataOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(metadata)
}

// updateMetadataHandleResponse handles the UpdateMetadata response.
func (client *WebAppsClient) updateMetadataHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// updateMetadataHandleError handles the UpdateMetadata error response.
func (client *WebAppsClient) updateMetadataHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateMetadataSlot - Description for Replaces the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *WebAppsUpdateMetadataSlotOptions) (StringDictionaryResponse, error) {
	req, err := client.updateMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, metadata, options)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StringDictionaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StringDictionaryResponse{}, client.updateMetadataSlotHandleError(resp)
	}
	return client.updateMetadataSlotHandleResponse(resp)
}

// updateMetadataSlotCreateRequest creates the UpdateMetadataSlot request.
func (client *WebAppsClient) updateMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *WebAppsUpdateMetadataSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(metadata)
}

// updateMetadataSlotHandleResponse handles the UpdateMetadataSlot response.
func (client *WebAppsClient) updateMetadataSlotHandleResponse(resp *azcore.Response) (StringDictionaryResponse, error) {
	var val *StringDictionary
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StringDictionaryResponse{}, err
	}
	return StringDictionaryResponse{RawResponse: resp.Response, StringDictionary: val}, nil
}

// updateMetadataSlotHandleError handles the UpdateMetadataSlot error response.
func (client *WebAppsClient) updateMetadataSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdatePremierAddOn - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdatePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnOptions) (PremierAddOnResponse, error) {
	req, err := client.updatePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.updatePremierAddOnHandleError(resp)
	}
	return client.updatePremierAddOnHandleResponse(resp)
}

// updatePremierAddOnCreateRequest creates the UpdatePremierAddOn request.
func (client *WebAppsClient) updatePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(premierAddOn)
}

// updatePremierAddOnHandleResponse handles the UpdatePremierAddOn response.
func (client *WebAppsClient) updatePremierAddOnHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// updatePremierAddOnHandleError handles the UpdatePremierAddOn error response.
func (client *WebAppsClient) updatePremierAddOnHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdatePremierAddOnSlot - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdatePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnSlotOptions) (PremierAddOnResponse, error) {
	req, err := client.updatePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PremierAddOnResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PremierAddOnResponse{}, client.updatePremierAddOnSlotHandleError(resp)
	}
	return client.updatePremierAddOnSlotHandleResponse(resp)
}

// updatePremierAddOnSlotCreateRequest creates the UpdatePremierAddOnSlot request.
func (client *WebAppsClient) updatePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(premierAddOn)
}

// updatePremierAddOnSlotHandleResponse handles the UpdatePremierAddOnSlot response.
func (client *WebAppsClient) updatePremierAddOnSlotHandleResponse(resp *azcore.Response) (PremierAddOnResponse, error) {
	var val *PremierAddOn
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnResponse{}, err
	}
	return PremierAddOnResponse{RawResponse: resp.Response, PremierAddOn: val}, nil
}

// updatePremierAddOnSlotHandleError handles the UpdatePremierAddOnSlot error response.
func (client *WebAppsClient) updatePremierAddOnSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateRelayServiceConnection - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.updateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.updateRelayServiceConnectionHandleError(resp)
	}
	return client.updateRelayServiceConnectionHandleResponse(resp)
}

// updateRelayServiceConnectionCreateRequest creates the UpdateRelayServiceConnection request.
func (client *WebAppsClient) updateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateRelayServiceConnectionHandleResponse handles the UpdateRelayServiceConnection response.
func (client *WebAppsClient) updateRelayServiceConnectionHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// updateRelayServiceConnectionHandleError handles the UpdateRelayServiceConnection error response.
func (client *WebAppsClient) updateRelayServiceConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateRelayServiceConnectionSlot - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionSlotOptions) (RelayServiceConnectionEntityResponse, error) {
	req, err := client.updateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RelayServiceConnectionEntityResponse{}, client.updateRelayServiceConnectionSlotHandleError(resp)
	}
	return client.updateRelayServiceConnectionSlotHandleResponse(resp)
}

// updateRelayServiceConnectionSlotCreateRequest creates the UpdateRelayServiceConnectionSlot request.
func (client *WebAppsClient) updateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateRelayServiceConnectionSlotHandleResponse handles the UpdateRelayServiceConnectionSlot response.
func (client *WebAppsClient) updateRelayServiceConnectionSlotHandleResponse(resp *azcore.Response) (RelayServiceConnectionEntityResponse, error) {
	var val *RelayServiceConnectionEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RelayServiceConnectionEntityResponse{}, err
	}
	return RelayServiceConnectionEntityResponse{RawResponse: resp.Response, RelayServiceConnectionEntity: val}, nil
}

// updateRelayServiceConnectionSlotHandleError handles the UpdateRelayServiceConnectionSlot error response.
func (client *WebAppsClient) updateRelayServiceConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateScmAllowed - Description for Updates whether user publishing credentials are allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateScmAllowed(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.updateScmAllowedCreateRequest(ctx, resourceGroupName, name, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.updateScmAllowedHandleError(resp)
	}
	return client.updateScmAllowedHandleResponse(resp)
}

// updateScmAllowedCreateRequest creates the UpdateScmAllowed request.
func (client *WebAppsClient) updateScmAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(csmPublishingAccessPoliciesEntity)
}

// updateScmAllowedHandleResponse handles the UpdateScmAllowed response.
func (client *WebAppsClient) updateScmAllowedHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// updateScmAllowedHandleError handles the UpdateScmAllowed error response.
func (client *WebAppsClient) updateScmAllowedHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateScmAllowedSlot - Description for Updates whether user publishing credentials are allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateScmAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedSlotOptions) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	req, err := client.updateScmAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, client.updateScmAllowedSlotHandleError(resp)
	}
	return client.updateScmAllowedSlotHandleResponse(resp)
}

// updateScmAllowedSlotCreateRequest creates the UpdateScmAllowedSlot request.
func (client *WebAppsClient) updateScmAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(csmPublishingAccessPoliciesEntity)
}

// updateScmAllowedSlotHandleResponse handles the UpdateScmAllowedSlot response.
func (client *WebAppsClient) updateScmAllowedSlotHandleResponse(resp *azcore.Response) (CsmPublishingCredentialsPoliciesEntityResponse, error) {
	var val *CsmPublishingCredentialsPoliciesEntity
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CsmPublishingCredentialsPoliciesEntityResponse{}, err
	}
	return CsmPublishingCredentialsPoliciesEntityResponse{RawResponse: resp.Response, CsmPublishingCredentialsPoliciesEntity: val}, nil
}

// updateScmAllowedSlotHandleError handles the UpdateScmAllowedSlot error response.
func (client *WebAppsClient) updateScmAllowedSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSitePushSettings - Description for Updates the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSitePushSettings(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsOptions) (PushSettingsResponse, error) {
	req, err := client.updateSitePushSettingsCreateRequest(ctx, resourceGroupName, name, pushSettings, options)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PushSettingsResponse{}, client.updateSitePushSettingsHandleError(resp)
	}
	return client.updateSitePushSettingsHandleResponse(resp)
}

// updateSitePushSettingsCreateRequest creates the UpdateSitePushSettings request.
func (client *WebAppsClient) updateSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(pushSettings)
}

// updateSitePushSettingsHandleResponse handles the UpdateSitePushSettings response.
func (client *WebAppsClient) updateSitePushSettingsHandleResponse(resp *azcore.Response) (PushSettingsResponse, error) {
	var val *PushSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PushSettingsResponse{}, err
	}
	return PushSettingsResponse{RawResponse: resp.Response, PushSettings: val}, nil
}

// updateSitePushSettingsHandleError handles the UpdateSitePushSettings error response.
func (client *WebAppsClient) updateSitePushSettingsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSitePushSettingsSlot - Description for Updates the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsSlotOptions) (PushSettingsResponse, error) {
	req, err := client.updateSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, pushSettings, options)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PushSettingsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PushSettingsResponse{}, client.updateSitePushSettingsSlotHandleError(resp)
	}
	return client.updateSitePushSettingsSlotHandleResponse(resp)
}

// updateSitePushSettingsSlotCreateRequest creates the UpdateSitePushSettingsSlot request.
func (client *WebAppsClient) updateSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(pushSettings)
}

// updateSitePushSettingsSlotHandleResponse handles the UpdateSitePushSettingsSlot response.
func (client *WebAppsClient) updateSitePushSettingsSlotHandleResponse(resp *azcore.Response) (PushSettingsResponse, error) {
	var val *PushSettings
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PushSettingsResponse{}, err
	}
	return PushSettingsResponse{RawResponse: resp.Response, PushSettings: val}, nil
}

// updateSitePushSettingsSlotHandleError handles the UpdateSitePushSettingsSlot error response.
func (client *WebAppsClient) updateSitePushSettingsSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *WebAppsUpdateSlotOptions) (SiteResponse, error) {
	req, err := client.updateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return SiteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return SiteResponse{}, client.updateSlotHandleError(resp)
	}
	return client.updateSlotHandleResponse(resp)
}

// updateSlotCreateRequest creates the UpdateSlot request.
func (client *WebAppsClient) updateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *WebAppsUpdateSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteEnvelope)
}

// updateSlotHandleResponse handles the UpdateSlot response.
func (client *WebAppsClient) updateSlotHandleResponse(resp *azcore.Response) (SiteResponse, error) {
	var val *Site
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteResponse{}, err
	}
	return SiteResponse{RawResponse: resp.Response, Site: val}, nil
}

// updateSlotHandleError handles the UpdateSlot error response.
func (client *WebAppsClient) updateSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSlotConfigurationNames - Description for Updates the names of application settings and connection string that remain with the slot during swap
// operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *WebAppsUpdateSlotConfigurationNamesOptions) (SlotConfigNamesResourceResponse, error) {
	req, err := client.updateSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, slotConfigNames, options)
	if err != nil {
		return SlotConfigNamesResourceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SlotConfigNamesResourceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SlotConfigNamesResourceResponse{}, client.updateSlotConfigurationNamesHandleError(resp)
	}
	return client.updateSlotConfigurationNamesHandleResponse(resp)
}

// updateSlotConfigurationNamesCreateRequest creates the UpdateSlotConfigurationNames request.
func (client *WebAppsClient) updateSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *WebAppsUpdateSlotConfigurationNamesOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(slotConfigNames)
}

// updateSlotConfigurationNamesHandleResponse handles the UpdateSlotConfigurationNames response.
func (client *WebAppsClient) updateSlotConfigurationNamesHandleResponse(resp *azcore.Response) (SlotConfigNamesResourceResponse, error) {
	var val *SlotConfigNamesResource
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SlotConfigNamesResourceResponse{}, err
	}
	return SlotConfigNamesResourceResponse{RawResponse: resp.Response, SlotConfigNamesResource: val}, nil
}

// updateSlotConfigurationNamesHandleError handles the UpdateSlotConfigurationNames error response.
func (client *WebAppsClient) updateSlotConfigurationNamesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlOptions) (SiteSourceControlResponse, error) {
	req, err := client.updateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return SiteSourceControlResponse{}, client.updateSourceControlHandleError(resp)
	}
	return client.updateSourceControlHandleResponse(resp)
}

// updateSourceControlCreateRequest creates the UpdateSourceControl request.
func (client *WebAppsClient) updateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteSourceControl)
}

// updateSourceControlHandleResponse handles the UpdateSourceControl response.
func (client *WebAppsClient) updateSourceControlHandleResponse(resp *azcore.Response) (SiteSourceControlResponse, error) {
	var val *SiteSourceControl
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteSourceControlResponse{}, err
	}
	return SiteSourceControlResponse{RawResponse: resp.Response, SiteSourceControl: val}, nil
}

// updateSourceControlHandleError handles the UpdateSourceControl error response.
func (client *WebAppsClient) updateSourceControlHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlSlotOptions) (SiteSourceControlResponse, error) {
	req, err := client.updateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SiteSourceControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return SiteSourceControlResponse{}, client.updateSourceControlSlotHandleError(resp)
	}
	return client.updateSourceControlSlotHandleResponse(resp)
}

// updateSourceControlSlotCreateRequest creates the UpdateSourceControlSlot request.
func (client *WebAppsClient) updateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(siteSourceControl)
}

// updateSourceControlSlotHandleResponse handles the UpdateSourceControlSlot response.
func (client *WebAppsClient) updateSourceControlSlotHandleResponse(resp *azcore.Response) (SiteSourceControlResponse, error) {
	var val *SiteSourceControl
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SiteSourceControlResponse{}, err
	}
	return SiteSourceControlResponse{RawResponse: resp.Response, SiteSourceControl: val}, nil
}

// updateSourceControlSlotHandleError handles the UpdateSourceControlSlot error response.
func (client *WebAppsClient) updateSourceControlSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSwiftVirtualNetworkConnectionWithCheck - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSwiftVirtualNetworkConnectionWithCheck(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (SwiftVirtualNetworkResponse, error) {
	req, err := client.updateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SwiftVirtualNetworkResponse{}, client.updateSwiftVirtualNetworkConnectionWithCheckHandleError(resp)
	}
	return client.updateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp)
}

// updateSwiftVirtualNetworkConnectionWithCheckCreateRequest creates the UpdateSwiftVirtualNetworkConnectionWithCheck request.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateSwiftVirtualNetworkConnectionWithCheckHandleResponse handles the UpdateSwiftVirtualNetworkConnectionWithCheck response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp *azcore.Response) (SwiftVirtualNetworkResponse, error) {
	var val *SwiftVirtualNetwork
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	return SwiftVirtualNetworkResponse{RawResponse: resp.Response, SwiftVirtualNetwork: val}, nil
}

// updateSwiftVirtualNetworkConnectionWithCheckHandleError handles the UpdateSwiftVirtualNetworkConnectionWithCheck error response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSwiftVirtualNetworkConnectionWithCheckSlot - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSwiftVirtualNetworkConnectionWithCheckSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (SwiftVirtualNetworkResponse, error) {
	req, err := client.updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SwiftVirtualNetworkResponse{}, client.updateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp)
	}
	return client.updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp)
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest creates the UpdateSwiftVirtualNetworkConnectionWithCheckSlot request.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse handles the UpdateSwiftVirtualNetworkConnectionWithCheckSlot response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp *azcore.Response) (SwiftVirtualNetworkResponse, error) {
	var val *SwiftVirtualNetwork
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SwiftVirtualNetworkResponse{}, err
	}
	return SwiftVirtualNetworkResponse{RawResponse: resp.Response, SwiftVirtualNetwork: val}, nil
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotHandleError handles the UpdateSwiftVirtualNetworkConnectionWithCheckSlot error response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateVnetConnection - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *WebAppsUpdateVnetConnectionOptions) (VnetInfoResponse, error) {
	req, err := client.updateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoResponse{}, client.updateVnetConnectionHandleError(resp)
	}
	return client.updateVnetConnectionHandleResponse(resp)
}

// updateVnetConnectionCreateRequest creates the UpdateVnetConnection request.
func (client *WebAppsClient) updateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, options *WebAppsUpdateVnetConnectionOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateVnetConnectionHandleResponse handles the UpdateVnetConnection response.
func (client *WebAppsClient) updateVnetConnectionHandleResponse(resp *azcore.Response) (VnetInfoResponse, error) {
	var val *VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoResponse{}, err
	}
	return VnetInfoResponse{RawResponse: resp.Response, VnetInfo: val}, nil
}

// updateVnetConnectionHandleError handles the UpdateVnetConnection error response.
func (client *WebAppsClient) updateVnetConnectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateVnetConnectionGateway - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewayOptions) (VnetGatewayResponse, error) {
	req, err := client.updateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetGatewayResponse{}, client.updateVnetConnectionGatewayHandleError(resp)
	}
	return client.updateVnetConnectionGatewayHandleResponse(resp)
}

// updateVnetConnectionGatewayCreateRequest creates the UpdateVnetConnectionGateway request.
func (client *WebAppsClient) updateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewayOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateVnetConnectionGatewayHandleResponse handles the UpdateVnetConnectionGateway response.
func (client *WebAppsClient) updateVnetConnectionGatewayHandleResponse(resp *azcore.Response) (VnetGatewayResponse, error) {
	var val *VnetGateway
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetGatewayResponse{}, err
	}
	return VnetGatewayResponse{RawResponse: resp.Response, VnetGateway: val}, nil
}

// updateVnetConnectionGatewayHandleError handles the UpdateVnetConnectionGateway error response.
func (client *WebAppsClient) updateVnetConnectionGatewayHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateVnetConnectionGatewaySlot - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewaySlotOptions) (VnetGatewayResponse, error) {
	req, err := client.updateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetGatewayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetGatewayResponse{}, client.updateVnetConnectionGatewaySlotHandleError(resp)
	}
	return client.updateVnetConnectionGatewaySlotHandleResponse(resp)
}

// updateVnetConnectionGatewaySlotCreateRequest creates the UpdateVnetConnectionGatewaySlot request.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewaySlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateVnetConnectionGatewaySlotHandleResponse handles the UpdateVnetConnectionGatewaySlot response.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotHandleResponse(resp *azcore.Response) (VnetGatewayResponse, error) {
	var val *VnetGateway
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetGatewayResponse{}, err
	}
	return VnetGatewayResponse{RawResponse: resp.Response, VnetGateway: val}, nil
}

// updateVnetConnectionGatewaySlotHandleError handles the UpdateVnetConnectionGatewaySlot error response.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateVnetConnectionSlot - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *WebAppsUpdateVnetConnectionSlotOptions) (VnetInfoResponse, error) {
	req, err := client.updateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetInfoResponse{}, client.updateVnetConnectionSlotHandleError(resp)
	}
	return client.updateVnetConnectionSlotHandleResponse(resp)
}

// updateVnetConnectionSlotCreateRequest creates the UpdateVnetConnectionSlot request.
func (client *WebAppsClient) updateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfo, options *WebAppsUpdateVnetConnectionSlotOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(connectionEnvelope)
}

// updateVnetConnectionSlotHandleResponse handles the UpdateVnetConnectionSlot response.
func (client *WebAppsClient) updateVnetConnectionSlotHandleResponse(resp *azcore.Response) (VnetInfoResponse, error) {
	var val *VnetInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetInfoResponse{}, err
	}
	return VnetInfoResponse{RawResponse: resp.Response, VnetInfo: val}, nil
}

// updateVnetConnectionSlotHandleError handles the UpdateVnetConnectionSlot error response.
func (client *WebAppsClient) updateVnetConnectionSlotHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
