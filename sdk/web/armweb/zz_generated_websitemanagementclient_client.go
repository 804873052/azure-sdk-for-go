// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// WebSiteManagementClient contains the methods for the WebSiteManagementClient group.
// Don't use this type directly, use NewWebSiteManagementClient() instead.
type WebSiteManagementClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewWebSiteManagementClient creates a new instance of WebSiteManagementClient with the specified values.
func NewWebSiteManagementClient(con *armcore.Connection, subscriptionID string) *WebSiteManagementClient {
	return &WebSiteManagementClient{con: con, subscriptionID: subscriptionID}
}

// CheckNameAvailability - Description for Check if a resource name is available.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) CheckNameAvailability(ctx context.Context, request ResourceNameAvailabilityRequest, options *WebSiteManagementClientCheckNameAvailabilityOptions) (ResourceNameAvailabilityResponse, error) {
	req, err := client.checkNameAvailabilityCreateRequest(ctx, request, options)
	if err != nil {
		return ResourceNameAvailabilityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ResourceNameAvailabilityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ResourceNameAvailabilityResponse{}, client.checkNameAvailabilityHandleError(resp)
	}
	return client.checkNameAvailabilityHandleResponse(resp)
}

// checkNameAvailabilityCreateRequest creates the CheckNameAvailability request.
func (client *WebSiteManagementClient) checkNameAvailabilityCreateRequest(ctx context.Context, request ResourceNameAvailabilityRequest, options *WebSiteManagementClientCheckNameAvailabilityOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// checkNameAvailabilityHandleResponse handles the CheckNameAvailability response.
func (client *WebSiteManagementClient) checkNameAvailabilityHandleResponse(resp *azcore.Response) (ResourceNameAvailabilityResponse, error) {
	var val *ResourceNameAvailability
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ResourceNameAvailabilityResponse{}, err
	}
	return ResourceNameAvailabilityResponse{RawResponse: resp.Response, ResourceNameAvailability: val}, nil
}

// checkNameAvailabilityHandleError handles the CheckNameAvailability error response.
func (client *WebSiteManagementClient) checkNameAvailabilityHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GenerateGithubAccessTokenForAppserviceCLIAsync - Description for Exchange code for GitHub access token for AppService CLI
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) GenerateGithubAccessTokenForAppserviceCLIAsync(ctx context.Context, request AppserviceGithubTokenRequest, options *WebSiteManagementClientGenerateGithubAccessTokenForAppserviceCLIAsyncOptions) (AppserviceGithubTokenResponse, error) {
	req, err := client.generateGithubAccessTokenForAppserviceCLIAsyncCreateRequest(ctx, request, options)
	if err != nil {
		return AppserviceGithubTokenResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return AppserviceGithubTokenResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return AppserviceGithubTokenResponse{}, client.generateGithubAccessTokenForAppserviceCLIAsyncHandleError(resp)
	}
	return client.generateGithubAccessTokenForAppserviceCLIAsyncHandleResponse(resp)
}

// generateGithubAccessTokenForAppserviceCLIAsyncCreateRequest creates the GenerateGithubAccessTokenForAppserviceCLIAsync request.
func (client *WebSiteManagementClient) generateGithubAccessTokenForAppserviceCLIAsyncCreateRequest(ctx context.Context, request AppserviceGithubTokenRequest, options *WebSiteManagementClientGenerateGithubAccessTokenForAppserviceCLIAsyncOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Web/generateGithubAccessTokenForAppserviceCLI"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(request)
}

// generateGithubAccessTokenForAppserviceCLIAsyncHandleResponse handles the GenerateGithubAccessTokenForAppserviceCLIAsync response.
func (client *WebSiteManagementClient) generateGithubAccessTokenForAppserviceCLIAsyncHandleResponse(resp *azcore.Response) (AppserviceGithubTokenResponse, error) {
	var val *AppserviceGithubToken
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return AppserviceGithubTokenResponse{}, err
	}
	return AppserviceGithubTokenResponse{RawResponse: resp.Response, AppserviceGithubToken: val}, nil
}

// generateGithubAccessTokenForAppserviceCLIAsyncHandleError handles the GenerateGithubAccessTokenForAppserviceCLIAsync error response.
func (client *WebSiteManagementClient) generateGithubAccessTokenForAppserviceCLIAsyncHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPublishingUser - Description for Gets publishing user
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) GetPublishingUser(ctx context.Context, options *WebSiteManagementClientGetPublishingUserOptions) (UserResponse, error) {
	req, err := client.getPublishingUserCreateRequest(ctx, options)
	if err != nil {
		return UserResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return UserResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return UserResponse{}, client.getPublishingUserHandleError(resp)
	}
	return client.getPublishingUserHandleResponse(resp)
}

// getPublishingUserCreateRequest creates the GetPublishingUser request.
func (client *WebSiteManagementClient) getPublishingUserCreateRequest(ctx context.Context, options *WebSiteManagementClientGetPublishingUserOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Web/publishingUsers/web"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPublishingUserHandleResponse handles the GetPublishingUser response.
func (client *WebSiteManagementClient) getPublishingUserHandleResponse(resp *azcore.Response) (UserResponse, error) {
	var val *User
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return UserResponse{}, err
	}
	return UserResponse{RawResponse: resp.Response, User: val}, nil
}

// getPublishingUserHandleError handles the GetPublishingUser error response.
func (client *WebSiteManagementClient) getPublishingUserHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSourceControl - Description for Gets source control token
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) GetSourceControl(ctx context.Context, sourceControlType string, options *WebSiteManagementClientGetSourceControlOptions) (SourceControlResponse, error) {
	req, err := client.getSourceControlCreateRequest(ctx, sourceControlType, options)
	if err != nil {
		return SourceControlResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SourceControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SourceControlResponse{}, client.getSourceControlHandleError(resp)
	}
	return client.getSourceControlHandleResponse(resp)
}

// getSourceControlCreateRequest creates the GetSourceControl request.
func (client *WebSiteManagementClient) getSourceControlCreateRequest(ctx context.Context, sourceControlType string, options *WebSiteManagementClientGetSourceControlOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}"
	if sourceControlType == "" {
		return nil, errors.New("parameter sourceControlType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceControlType}", url.PathEscape(sourceControlType))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSourceControlHandleResponse handles the GetSourceControl response.
func (client *WebSiteManagementClient) getSourceControlHandleResponse(resp *azcore.Response) (SourceControlResponse, error) {
	var val *SourceControl
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SourceControlResponse{}, err
	}
	return SourceControlResponse{RawResponse: resp.Response, SourceControl: val}, nil
}

// getSourceControlHandleError handles the GetSourceControl error response.
func (client *WebSiteManagementClient) getSourceControlHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSubscriptionDeploymentLocations - Description for Gets list of available geo regions plus ministamps
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) GetSubscriptionDeploymentLocations(ctx context.Context, options *WebSiteManagementClientGetSubscriptionDeploymentLocationsOptions) (DeploymentLocationsResponse, error) {
	req, err := client.getSubscriptionDeploymentLocationsCreateRequest(ctx, options)
	if err != nil {
		return DeploymentLocationsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentLocationsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentLocationsResponse{}, client.getSubscriptionDeploymentLocationsHandleError(resp)
	}
	return client.getSubscriptionDeploymentLocationsHandleResponse(resp)
}

// getSubscriptionDeploymentLocationsCreateRequest creates the GetSubscriptionDeploymentLocations request.
func (client *WebSiteManagementClient) getSubscriptionDeploymentLocationsCreateRequest(ctx context.Context, options *WebSiteManagementClientGetSubscriptionDeploymentLocationsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSubscriptionDeploymentLocationsHandleResponse handles the GetSubscriptionDeploymentLocations response.
func (client *WebSiteManagementClient) getSubscriptionDeploymentLocationsHandleResponse(resp *azcore.Response) (DeploymentLocationsResponse, error) {
	var val *DeploymentLocations
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentLocationsResponse{}, err
	}
	return DeploymentLocationsResponse{RawResponse: resp.Response, DeploymentLocations: val}, nil
}

// getSubscriptionDeploymentLocationsHandleError handles the GetSubscriptionDeploymentLocations error response.
func (client *WebSiteManagementClient) getSubscriptionDeploymentLocationsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListBillingMeters - Description for Gets a list of meters for a given location.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) ListBillingMeters(options *WebSiteManagementClientListBillingMetersOptions) BillingMeterCollectionPager {
	return &billingMeterCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listBillingMetersCreateRequest(ctx, options)
		},
		responder: client.listBillingMetersHandleResponse,
		errorer:   client.listBillingMetersHandleError,
		advancer: func(ctx context.Context, resp BillingMeterCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.BillingMeterCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listBillingMetersCreateRequest creates the ListBillingMeters request.
func (client *WebSiteManagementClient) listBillingMetersCreateRequest(ctx context.Context, options *WebSiteManagementClientListBillingMetersOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.BillingLocation != nil {
		reqQP.Set("billingLocation", *options.BillingLocation)
	}
	if options != nil && options.OSType != nil {
		reqQP.Set("osType", *options.OSType)
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listBillingMetersHandleResponse handles the ListBillingMeters response.
func (client *WebSiteManagementClient) listBillingMetersHandleResponse(resp *azcore.Response) (BillingMeterCollectionResponse, error) {
	var val *BillingMeterCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BillingMeterCollectionResponse{}, err
	}
	return BillingMeterCollectionResponse{RawResponse: resp.Response, BillingMeterCollection: val}, nil
}

// listBillingMetersHandleError handles the ListBillingMeters error response.
func (client *WebSiteManagementClient) listBillingMetersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListGeoRegions - Description for Get a list of available geographical regions.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) ListGeoRegions(options *WebSiteManagementClientListGeoRegionsOptions) GeoRegionCollectionPager {
	return &geoRegionCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listGeoRegionsCreateRequest(ctx, options)
		},
		responder: client.listGeoRegionsHandleResponse,
		errorer:   client.listGeoRegionsHandleError,
		advancer: func(ctx context.Context, resp GeoRegionCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.GeoRegionCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listGeoRegionsCreateRequest creates the ListGeoRegions request.
func (client *WebSiteManagementClient) listGeoRegionsCreateRequest(ctx context.Context, options *WebSiteManagementClientListGeoRegionsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.SKU != nil {
		reqQP.Set("sku", string(*options.SKU))
	}
	if options != nil && options.LinuxWorkersEnabled != nil {
		reqQP.Set("linuxWorkersEnabled", strconv.FormatBool(*options.LinuxWorkersEnabled))
	}
	if options != nil && options.XenonWorkersEnabled != nil {
		reqQP.Set("xenonWorkersEnabled", strconv.FormatBool(*options.XenonWorkersEnabled))
	}
	if options != nil && options.LinuxDynamicWorkersEnabled != nil {
		reqQP.Set("linuxDynamicWorkersEnabled", strconv.FormatBool(*options.LinuxDynamicWorkersEnabled))
	}
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listGeoRegionsHandleResponse handles the ListGeoRegions response.
func (client *WebSiteManagementClient) listGeoRegionsHandleResponse(resp *azcore.Response) (GeoRegionCollectionResponse, error) {
	var val *GeoRegionCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GeoRegionCollectionResponse{}, err
	}
	return GeoRegionCollectionResponse{RawResponse: resp.Response, GeoRegionCollection: val}, nil
}

// listGeoRegionsHandleError handles the ListGeoRegions error response.
func (client *WebSiteManagementClient) listGeoRegionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPremierAddOnOffers - Description for List all premier add-on offers.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) ListPremierAddOnOffers(options *WebSiteManagementClientListPremierAddOnOffersOptions) PremierAddOnOfferCollectionPager {
	return &premierAddOnOfferCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listPremierAddOnOffersCreateRequest(ctx, options)
		},
		responder: client.listPremierAddOnOffersHandleResponse,
		errorer:   client.listPremierAddOnOffersHandleError,
		advancer: func(ctx context.Context, resp PremierAddOnOfferCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.PremierAddOnOfferCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listPremierAddOnOffersCreateRequest creates the ListPremierAddOnOffers request.
func (client *WebSiteManagementClient) listPremierAddOnOffersCreateRequest(ctx context.Context, options *WebSiteManagementClientListPremierAddOnOffersOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPremierAddOnOffersHandleResponse handles the ListPremierAddOnOffers response.
func (client *WebSiteManagementClient) listPremierAddOnOffersHandleResponse(resp *azcore.Response) (PremierAddOnOfferCollectionResponse, error) {
	var val *PremierAddOnOfferCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PremierAddOnOfferCollectionResponse{}, err
	}
	return PremierAddOnOfferCollectionResponse{RawResponse: resp.Response, PremierAddOnOfferCollection: val}, nil
}

// listPremierAddOnOffersHandleError handles the ListPremierAddOnOffers error response.
func (client *WebSiteManagementClient) listPremierAddOnOffersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSKUs - Description for List all SKUs.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) ListSKUs(ctx context.Context, options *WebSiteManagementClientListSKUsOptions) (SKUInfosResponse, error) {
	req, err := client.listSKUsCreateRequest(ctx, options)
	if err != nil {
		return SKUInfosResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SKUInfosResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SKUInfosResponse{}, client.listSKUsHandleError(resp)
	}
	return client.listSKUsHandleResponse(resp)
}

// listSKUsCreateRequest creates the ListSKUs request.
func (client *WebSiteManagementClient) listSKUsCreateRequest(ctx context.Context, options *WebSiteManagementClientListSKUsOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSKUsHandleResponse handles the ListSKUs response.
func (client *WebSiteManagementClient) listSKUsHandleResponse(resp *azcore.Response) (SKUInfosResponse, error) {
	var val *SKUInfos
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SKUInfosResponse{}, err
	}
	return SKUInfosResponse{RawResponse: resp.Response, SKUInfos: val}, nil
}

// listSKUsHandleError handles the ListSKUs error response.
func (client *WebSiteManagementClient) listSKUsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSiteIdentifiersAssignedToHostName - Description for List all apps that are assigned to a hostname.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) ListSiteIdentifiersAssignedToHostName(nameIdentifier NameIdentifier, options *WebSiteManagementClientListSiteIdentifiersAssignedToHostNameOptions) IdentifierCollectionPager {
	return &identifierCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSiteIdentifiersAssignedToHostNameCreateRequest(ctx, nameIdentifier, options)
		},
		responder: client.listSiteIdentifiersAssignedToHostNameHandleResponse,
		errorer:   client.listSiteIdentifiersAssignedToHostNameHandleError,
		advancer: func(ctx context.Context, resp IdentifierCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.IdentifierCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSiteIdentifiersAssignedToHostNameCreateRequest creates the ListSiteIdentifiersAssignedToHostName request.
func (client *WebSiteManagementClient) listSiteIdentifiersAssignedToHostNameCreateRequest(ctx context.Context, nameIdentifier NameIdentifier, options *WebSiteManagementClientListSiteIdentifiersAssignedToHostNameOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(nameIdentifier)
}

// listSiteIdentifiersAssignedToHostNameHandleResponse handles the ListSiteIdentifiersAssignedToHostName response.
func (client *WebSiteManagementClient) listSiteIdentifiersAssignedToHostNameHandleResponse(resp *azcore.Response) (IdentifierCollectionResponse, error) {
	var val *IdentifierCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IdentifierCollectionResponse{}, err
	}
	return IdentifierCollectionResponse{RawResponse: resp.Response, IdentifierCollection: val}, nil
}

// listSiteIdentifiersAssignedToHostNameHandleError handles the ListSiteIdentifiersAssignedToHostName error response.
func (client *WebSiteManagementClient) listSiteIdentifiersAssignedToHostNameHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListSourceControls - Description for Gets the source controls available for Azure websites.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) ListSourceControls(options *WebSiteManagementClientListSourceControlsOptions) SourceControlCollectionPager {
	return &sourceControlCollectionPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSourceControlsCreateRequest(ctx, options)
		},
		responder: client.listSourceControlsHandleResponse,
		errorer:   client.listSourceControlsHandleError,
		advancer: func(ctx context.Context, resp SourceControlCollectionResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SourceControlCollection.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listSourceControlsCreateRequest creates the ListSourceControls request.
func (client *WebSiteManagementClient) listSourceControlsCreateRequest(ctx context.Context, options *WebSiteManagementClientListSourceControlsOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSourceControlsHandleResponse handles the ListSourceControls response.
func (client *WebSiteManagementClient) listSourceControlsHandleResponse(resp *azcore.Response) (SourceControlCollectionResponse, error) {
	var val *SourceControlCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SourceControlCollectionResponse{}, err
	}
	return SourceControlCollectionResponse{RawResponse: resp.Response, SourceControlCollection: val}, nil
}

// listSourceControlsHandleError handles the ListSourceControls error response.
func (client *WebSiteManagementClient) listSourceControlsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Move - Description for Move resources between resource groups.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) Move(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *WebSiteManagementClientMoveOptions) (*http.Response, error) {
	req, err := client.moveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.moveHandleError(resp)
	}
	return resp.Response, nil
}

// moveCreateRequest creates the Move request.
func (client *WebSiteManagementClient) moveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *WebSiteManagementClientMoveOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(moveResourceEnvelope)
}

// moveHandleError handles the Move error response.
func (client *WebSiteManagementClient) moveHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdatePublishingUser - Description for Updates publishing user
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) UpdatePublishingUser(ctx context.Context, userDetails User, options *WebSiteManagementClientUpdatePublishingUserOptions) (UserResponse, error) {
	req, err := client.updatePublishingUserCreateRequest(ctx, userDetails, options)
	if err != nil {
		return UserResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return UserResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return UserResponse{}, client.updatePublishingUserHandleError(resp)
	}
	return client.updatePublishingUserHandleResponse(resp)
}

// updatePublishingUserCreateRequest creates the UpdatePublishingUser request.
func (client *WebSiteManagementClient) updatePublishingUserCreateRequest(ctx context.Context, userDetails User, options *WebSiteManagementClientUpdatePublishingUserOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Web/publishingUsers/web"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(userDetails)
}

// updatePublishingUserHandleResponse handles the UpdatePublishingUser response.
func (client *WebSiteManagementClient) updatePublishingUserHandleResponse(resp *azcore.Response) (UserResponse, error) {
	var val *User
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return UserResponse{}, err
	}
	return UserResponse{RawResponse: resp.Response, User: val}, nil
}

// updatePublishingUserHandleError handles the UpdatePublishingUser error response.
func (client *WebSiteManagementClient) updatePublishingUserHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSourceControl - Description for Updates source control token
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) UpdateSourceControl(ctx context.Context, sourceControlType string, requestMessage SourceControl, options *WebSiteManagementClientUpdateSourceControlOptions) (SourceControlResponse, error) {
	req, err := client.updateSourceControlCreateRequest(ctx, sourceControlType, requestMessage, options)
	if err != nil {
		return SourceControlResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SourceControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SourceControlResponse{}, client.updateSourceControlHandleError(resp)
	}
	return client.updateSourceControlHandleResponse(resp)
}

// updateSourceControlCreateRequest creates the UpdateSourceControl request.
func (client *WebSiteManagementClient) updateSourceControlCreateRequest(ctx context.Context, sourceControlType string, requestMessage SourceControl, options *WebSiteManagementClientUpdateSourceControlOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}"
	if sourceControlType == "" {
		return nil, errors.New("parameter sourceControlType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceControlType}", url.PathEscape(sourceControlType))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(requestMessage)
}

// updateSourceControlHandleResponse handles the UpdateSourceControl response.
func (client *WebSiteManagementClient) updateSourceControlHandleResponse(resp *azcore.Response) (SourceControlResponse, error) {
	var val *SourceControl
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SourceControlResponse{}, err
	}
	return SourceControlResponse{RawResponse: resp.Response, SourceControl: val}, nil
}

// updateSourceControlHandleError handles the UpdateSourceControl error response.
func (client *WebSiteManagementClient) updateSourceControlHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Validate - Description for Validate if a resource can be created.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) Validate(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, options *WebSiteManagementClientValidateOptions) (ValidateResponseResponse, error) {
	req, err := client.validateCreateRequest(ctx, resourceGroupName, validateRequest, options)
	if err != nil {
		return ValidateResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ValidateResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ValidateResponseResponse{}, client.validateHandleError(resp)
	}
	return client.validateHandleResponse(resp)
}

// validateCreateRequest creates the Validate request.
func (client *WebSiteManagementClient) validateCreateRequest(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, options *WebSiteManagementClientValidateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(validateRequest)
}

// validateHandleResponse handles the Validate response.
func (client *WebSiteManagementClient) validateHandleResponse(resp *azcore.Response) (ValidateResponseResponse, error) {
	var val *ValidateResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ValidateResponseResponse{}, err
	}
	return ValidateResponseResponse{RawResponse: resp.Response, ValidateResponse: val}, nil
}

// validateHandleError handles the Validate error response.
func (client *WebSiteManagementClient) validateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ValidateMove - Description for Validate whether a resource can be moved.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) ValidateMove(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *WebSiteManagementClientValidateMoveOptions) (*http.Response, error) {
	req, err := client.validateMoveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.validateMoveHandleError(resp)
	}
	return resp.Response, nil
}

// validateMoveCreateRequest creates the ValidateMove request.
func (client *WebSiteManagementClient) validateMoveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *WebSiteManagementClientValidateMoveOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(moveResourceEnvelope)
}

// validateMoveHandleError handles the ValidateMove error response.
func (client *WebSiteManagementClient) validateMoveHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// VerifyHostingEnvironmentVnet - Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network Security
// Group rules.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebSiteManagementClient) VerifyHostingEnvironmentVnet(ctx context.Context, parameters VnetParameters, options *WebSiteManagementClientVerifyHostingEnvironmentVnetOptions) (VnetValidationFailureDetailsResponse, error) {
	req, err := client.verifyHostingEnvironmentVnetCreateRequest(ctx, parameters, options)
	if err != nil {
		return VnetValidationFailureDetailsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return VnetValidationFailureDetailsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return VnetValidationFailureDetailsResponse{}, client.verifyHostingEnvironmentVnetHandleError(resp)
	}
	return client.verifyHostingEnvironmentVnetHandleResponse(resp)
}

// verifyHostingEnvironmentVnetCreateRequest creates the VerifyHostingEnvironmentVnet request.
func (client *WebSiteManagementClient) verifyHostingEnvironmentVnetCreateRequest(ctx context.Context, parameters VnetParameters, options *WebSiteManagementClientVerifyHostingEnvironmentVnetOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-01-15")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// verifyHostingEnvironmentVnetHandleResponse handles the VerifyHostingEnvironmentVnet response.
func (client *WebSiteManagementClient) verifyHostingEnvironmentVnetHandleResponse(resp *azcore.Response) (VnetValidationFailureDetailsResponse, error) {
	var val *VnetValidationFailureDetails
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return VnetValidationFailureDetailsResponse{}, err
	}
	return VnetValidationFailureDetailsResponse{RawResponse: resp.Response, VnetValidationFailureDetails: val}, nil
}

// verifyHostingEnvironmentVnetHandleError handles the VerifyHostingEnvironmentVnet error response.
func (client *WebSiteManagementClient) verifyHostingEnvironmentVnetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
