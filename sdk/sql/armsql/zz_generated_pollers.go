// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsql

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// BackupShortTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupShortTermRetentionPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BackupShortTermRetentionPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesCreateOrUpdateResponse, error)
}

type backupShortTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *backupShortTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *backupShortTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *backupShortTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *backupShortTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *backupShortTermRetentionPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (BackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BackupShortTermRetentionPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupShortTermRetentionPoliciesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BackupShortTermRetentionPoliciesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesUpdateResponse, error)
}

type backupShortTermRetentionPoliciesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *backupShortTermRetentionPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *backupShortTermRetentionPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *backupShortTermRetentionPoliciesUpdatePoller) FinalResponse(ctx context.Context) (BackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *backupShortTermRetentionPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *backupShortTermRetentionPoliciesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (BackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := BackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.BackupShortTermRetentionPolicy)
	if err != nil {
		return BackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseExtensionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabaseExtensionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseExtensionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseExtensionsCreateOrUpdateResponse, error)
}

type databaseExtensionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *databaseExtensionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseExtensionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseExtensionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabaseExtensionsCreateOrUpdateResponse, error) {
	respType := DatabaseExtensionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportExtensionsOperationResult)
	if err != nil {
		return DatabaseExtensionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseExtensionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseExtensionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseExtensionsCreateOrUpdateResponse, error) {
	respType := DatabaseExtensionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ImportExportExtensionsOperationResult)
	if err != nil {
		return DatabaseExtensionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabaseVulnerabilityAssessmentScansInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type DatabaseVulnerabilityAssessmentScansInitiateScanPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabaseVulnerabilityAssessmentScansInitiateScanResponse will be returned.
	FinalResponse(ctx context.Context) (DatabaseVulnerabilityAssessmentScansInitiateScanResponse, error)
}

type databaseVulnerabilityAssessmentScansInitiateScanPoller struct {
	pt *armcore.LROPoller
}

func (p *databaseVulnerabilityAssessmentScansInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

func (p *databaseVulnerabilityAssessmentScansInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databaseVulnerabilityAssessmentScansInitiateScanPoller) FinalResponse(ctx context.Context) (DatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := DatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabaseVulnerabilityAssessmentScansInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databaseVulnerabilityAssessmentScansInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databaseVulnerabilityAssessmentScansInitiateScanPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := DatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabaseVulnerabilityAssessmentScansInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesCreateOrUpdateResponse, error)
}

type databasesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *databasesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DatabasesCreateOrUpdateResponse, error) {
	respType := DatabasesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesCreateOrUpdateResponse, error) {
	respType := DatabasesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return DatabasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesDeletePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesDeleteResponse, error)
}

type databasesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *databasesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesDeletePoller) FinalResponse(ctx context.Context) (DatabasesDeleteResponse, error) {
	respType := DatabasesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesDeleteResponse, error) {
	respType := DatabasesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesExportPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesExportPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesExportResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesExportResponse, error)
}

type databasesExportPoller struct {
	pt *armcore.LROPoller
}

func (p *databasesExportPoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesExportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesExportPoller) FinalResponse(ctx context.Context) (DatabasesExportResponse, error) {
	respType := DatabasesExportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesExportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesExportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesExportPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesExportResponse, error) {
	respType := DatabasesExportResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesExportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesFailoverPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesFailoverPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesFailoverResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesFailoverResponse, error)
}

type databasesFailoverPoller struct {
	pt *armcore.LROPoller
}

func (p *databasesFailoverPoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesFailoverPoller) FinalResponse(ctx context.Context) (DatabasesFailoverResponse, error) {
	respType := DatabasesFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesFailoverPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesFailoverResponse, error) {
	respType := DatabasesFailoverResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabasesFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesImportPoller provides polling facilities until the operation reaches a terminal state.
type DatabasesImportPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesImportResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesImportResponse, error)
}

type databasesImportPoller struct {
	pt *armcore.LROPoller
}

func (p *databasesImportPoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesImportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesImportPoller) FinalResponse(ctx context.Context) (DatabasesImportResponse, error) {
	respType := DatabasesImportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesImportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesImportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesImportPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesImportResponse, error) {
	respType := DatabasesImportResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ImportExportOperationResult)
	if err != nil {
		return DatabasesImportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesPausePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesPausePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesPauseResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesPauseResponse, error)
}

type databasesPausePoller struct {
	pt *armcore.LROPoller
}

func (p *databasesPausePoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesPausePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesPausePoller) FinalResponse(ctx context.Context) (DatabasesPauseResponse, error) {
	respType := DatabasesPauseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesPauseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesPausePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesPausePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesPauseResponse, error) {
	respType := DatabasesPauseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return DatabasesPauseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesResumePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesResumePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesResumeResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesResumeResponse, error)
}

type databasesResumePoller struct {
	pt *armcore.LROPoller
}

func (p *databasesResumePoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesResumePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesResumePoller) FinalResponse(ctx context.Context) (DatabasesResumeResponse, error) {
	respType := DatabasesResumeResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesResumeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesResumePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesResumePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesResumeResponse, error) {
	respType := DatabasesResumeResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return DatabasesResumeResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesUpdateResponse, error)
}

type databasesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *databasesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesUpdatePoller) FinalResponse(ctx context.Context) (DatabasesUpdateResponse, error) {
	respType := DatabasesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Database)
	if err != nil {
		return DatabasesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesUpdateResponse, error) {
	respType := DatabasesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Database)
	if err != nil {
		return DatabasesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DatabasesUpgradeDataWarehousePoller provides polling facilities until the operation reaches a terminal state.
type DatabasesUpgradeDataWarehousePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DatabasesUpgradeDataWarehouseResponse will be returned.
	FinalResponse(ctx context.Context) (DatabasesUpgradeDataWarehouseResponse, error)
}

type databasesUpgradeDataWarehousePoller struct {
	pt *armcore.LROPoller
}

func (p *databasesUpgradeDataWarehousePoller) Done() bool {
	return p.pt.Done()
}

func (p *databasesUpgradeDataWarehousePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *databasesUpgradeDataWarehousePoller) FinalResponse(ctx context.Context) (DatabasesUpgradeDataWarehouseResponse, error) {
	respType := DatabasesUpgradeDataWarehouseResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatabasesUpgradeDataWarehouseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *databasesUpgradeDataWarehousePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *databasesUpgradeDataWarehousePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DatabasesUpgradeDataWarehouseResponse, error) {
	respType := DatabasesUpgradeDataWarehouseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DatabasesUpgradeDataWarehouseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DeletedServersRecoverPoller provides polling facilities until the operation reaches a terminal state.
type DeletedServersRecoverPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DeletedServersRecoverResponse will be returned.
	FinalResponse(ctx context.Context) (DeletedServersRecoverResponse, error)
}

type deletedServersRecoverPoller struct {
	pt *armcore.LROPoller
}

func (p *deletedServersRecoverPoller) Done() bool {
	return p.pt.Done()
}

func (p *deletedServersRecoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *deletedServersRecoverPoller) FinalResponse(ctx context.Context) (DeletedServersRecoverResponse, error) {
	respType := DeletedServersRecoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeletedServer)
	if err != nil {
		return DeletedServersRecoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *deletedServersRecoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *deletedServersRecoverPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DeletedServersRecoverResponse, error) {
	respType := DeletedServersRecoverResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DeletedServer)
	if err != nil {
		return DeletedServersRecoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ElasticPoolsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ElasticPoolsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ElasticPoolsCreateOrUpdateResponse, error)
}

type elasticPoolsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *elasticPoolsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *elasticPoolsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *elasticPoolsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ElasticPoolsCreateOrUpdateResponse, error) {
	respType := ElasticPoolsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *elasticPoolsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *elasticPoolsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsCreateOrUpdateResponse, error) {
	respType := ElasticPoolsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ElasticPoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ElasticPoolsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ElasticPoolsDeleteResponse, error)
}

type elasticPoolsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *elasticPoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *elasticPoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *elasticPoolsDeletePoller) FinalResponse(ctx context.Context) (ElasticPoolsDeleteResponse, error) {
	respType := ElasticPoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ElasticPoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *elasticPoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *elasticPoolsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsDeleteResponse, error) {
	respType := ElasticPoolsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ElasticPoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ElasticPoolsFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsFailoverPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ElasticPoolsFailoverResponse will be returned.
	FinalResponse(ctx context.Context) (ElasticPoolsFailoverResponse, error)
}

type elasticPoolsFailoverPoller struct {
	pt *armcore.LROPoller
}

func (p *elasticPoolsFailoverPoller) Done() bool {
	return p.pt.Done()
}

func (p *elasticPoolsFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *elasticPoolsFailoverPoller) FinalResponse(ctx context.Context) (ElasticPoolsFailoverResponse, error) {
	respType := ElasticPoolsFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ElasticPoolsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *elasticPoolsFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *elasticPoolsFailoverPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsFailoverResponse, error) {
	respType := ElasticPoolsFailoverResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ElasticPoolsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ElasticPoolsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ElasticPoolsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ElasticPoolsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ElasticPoolsUpdateResponse, error)
}

type elasticPoolsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *elasticPoolsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *elasticPoolsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *elasticPoolsUpdatePoller) FinalResponse(ctx context.Context) (ElasticPoolsUpdateResponse, error) {
	respType := ElasticPoolsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *elasticPoolsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *elasticPoolsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ElasticPoolsUpdateResponse, error) {
	respType := ElasticPoolsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ElasticPool)
	if err != nil {
		return ElasticPoolsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EncryptionProtectorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type EncryptionProtectorsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EncryptionProtectorsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (EncryptionProtectorsCreateOrUpdateResponse, error)
}

type encryptionProtectorsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *encryptionProtectorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *encryptionProtectorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *encryptionProtectorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (EncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := EncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EncryptionProtector)
	if err != nil {
		return EncryptionProtectorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *encryptionProtectorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *encryptionProtectorsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := EncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EncryptionProtector)
	if err != nil {
		return EncryptionProtectorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// EncryptionProtectorsRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type EncryptionProtectorsRevalidatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final EncryptionProtectorsRevalidateResponse will be returned.
	FinalResponse(ctx context.Context) (EncryptionProtectorsRevalidateResponse, error)
}

type encryptionProtectorsRevalidatePoller struct {
	pt *armcore.LROPoller
}

func (p *encryptionProtectorsRevalidatePoller) Done() bool {
	return p.pt.Done()
}

func (p *encryptionProtectorsRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *encryptionProtectorsRevalidatePoller) FinalResponse(ctx context.Context) (EncryptionProtectorsRevalidateResponse, error) {
	respType := EncryptionProtectorsRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return EncryptionProtectorsRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *encryptionProtectorsRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *encryptionProtectorsRevalidatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (EncryptionProtectorsRevalidateResponse, error) {
	respType := EncryptionProtectorsRevalidateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return EncryptionProtectorsRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExtendedServerBlobAuditingPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse, error)
}

type extendedServerBlobAuditingPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *extendedServerBlobAuditingPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *extendedServerBlobAuditingPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *extendedServerBlobAuditingPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExtendedServerBlobAuditingPolicy)
	if err != nil {
		return ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *extendedServerBlobAuditingPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *extendedServerBlobAuditingPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExtendedServerBlobAuditingPolicy)
	if err != nil {
		return ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FailoverGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FailoverGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (FailoverGroupsCreateOrUpdateResponse, error)
}

type failoverGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *failoverGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *failoverGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *failoverGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FailoverGroupsCreateOrUpdateResponse, error) {
	respType := FailoverGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *failoverGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *failoverGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsCreateOrUpdateResponse, error) {
	respType := FailoverGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FailoverGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FailoverGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (FailoverGroupsDeleteResponse, error)
}

type failoverGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *failoverGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *failoverGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *failoverGroupsDeletePoller) FinalResponse(ctx context.Context) (FailoverGroupsDeleteResponse, error) {
	respType := FailoverGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FailoverGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *failoverGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *failoverGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsDeleteResponse, error) {
	respType := FailoverGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return FailoverGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FailoverGroupsFailoverPoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsFailoverPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FailoverGroupsFailoverResponse will be returned.
	FinalResponse(ctx context.Context) (FailoverGroupsFailoverResponse, error)
}

type failoverGroupsFailoverPoller struct {
	pt *armcore.LROPoller
}

func (p *failoverGroupsFailoverPoller) Done() bool {
	return p.pt.Done()
}

func (p *failoverGroupsFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *failoverGroupsFailoverPoller) FinalResponse(ctx context.Context) (FailoverGroupsFailoverResponse, error) {
	respType := FailoverGroupsFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *failoverGroupsFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *failoverGroupsFailoverPoller) pollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsFailoverResponse, error) {
	respType := FailoverGroupsFailoverResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FailoverGroupsForceFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsForceFailoverAllowDataLossPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FailoverGroupsForceFailoverAllowDataLossResponse will be returned.
	FinalResponse(ctx context.Context) (FailoverGroupsForceFailoverAllowDataLossResponse, error)
}

type failoverGroupsForceFailoverAllowDataLossPoller struct {
	pt *armcore.LROPoller
}

func (p *failoverGroupsForceFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

func (p *failoverGroupsForceFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *failoverGroupsForceFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (FailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := FailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *failoverGroupsForceFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *failoverGroupsForceFailoverAllowDataLossPoller) pollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := FailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FailoverGroupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FailoverGroupsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FailoverGroupsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (FailoverGroupsUpdateResponse, error)
}

type failoverGroupsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *failoverGroupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *failoverGroupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *failoverGroupsUpdatePoller) FinalResponse(ctx context.Context) (FailoverGroupsUpdateResponse, error) {
	respType := FailoverGroupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *failoverGroupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *failoverGroupsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FailoverGroupsUpdateResponse, error) {
	respType := FailoverGroupsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FailoverGroup)
	if err != nil {
		return FailoverGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InstanceFailoverGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InstanceFailoverGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (InstanceFailoverGroupsCreateOrUpdateResponse, error)
}

type instanceFailoverGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *instanceFailoverGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *instanceFailoverGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *instanceFailoverGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsCreateOrUpdateResponse, error) {
	respType := InstanceFailoverGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *instanceFailoverGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *instanceFailoverGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsCreateOrUpdateResponse, error) {
	respType := InstanceFailoverGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InstanceFailoverGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InstanceFailoverGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (InstanceFailoverGroupsDeleteResponse, error)
}

type instanceFailoverGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *instanceFailoverGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *instanceFailoverGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *instanceFailoverGroupsDeletePoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsDeleteResponse, error) {
	respType := InstanceFailoverGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InstanceFailoverGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *instanceFailoverGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *instanceFailoverGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsDeleteResponse, error) {
	respType := InstanceFailoverGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return InstanceFailoverGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InstanceFailoverGroupsFailoverPoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsFailoverPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InstanceFailoverGroupsFailoverResponse will be returned.
	FinalResponse(ctx context.Context) (InstanceFailoverGroupsFailoverResponse, error)
}

type instanceFailoverGroupsFailoverPoller struct {
	pt *armcore.LROPoller
}

func (p *instanceFailoverGroupsFailoverPoller) Done() bool {
	return p.pt.Done()
}

func (p *instanceFailoverGroupsFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *instanceFailoverGroupsFailoverPoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsFailoverResponse, error) {
	respType := InstanceFailoverGroupsFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *instanceFailoverGroupsFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *instanceFailoverGroupsFailoverPoller) pollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsFailoverResponse, error) {
	respType := InstanceFailoverGroupsFailoverResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InstanceFailoverGroupsForceFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type InstanceFailoverGroupsForceFailoverAllowDataLossPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InstanceFailoverGroupsForceFailoverAllowDataLossResponse will be returned.
	FinalResponse(ctx context.Context) (InstanceFailoverGroupsForceFailoverAllowDataLossResponse, error)
}

type instanceFailoverGroupsForceFailoverAllowDataLossPoller struct {
	pt *armcore.LROPoller
}

func (p *instanceFailoverGroupsForceFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

func (p *instanceFailoverGroupsForceFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *instanceFailoverGroupsForceFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (InstanceFailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := InstanceFailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *instanceFailoverGroupsForceFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *instanceFailoverGroupsForceFailoverAllowDataLossPoller) pollUntilDone(ctx context.Context, freq time.Duration) (InstanceFailoverGroupsForceFailoverAllowDataLossResponse, error) {
	respType := InstanceFailoverGroupsForceFailoverAllowDataLossResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.InstanceFailoverGroup)
	if err != nil {
		return InstanceFailoverGroupsForceFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InstancePoolsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InstancePoolsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (InstancePoolsCreateOrUpdateResponse, error)
}

type instancePoolsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *instancePoolsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *instancePoolsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *instancePoolsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InstancePoolsCreateOrUpdateResponse, error) {
	respType := InstancePoolsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstancePool)
	if err != nil {
		return InstancePoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *instancePoolsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *instancePoolsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (InstancePoolsCreateOrUpdateResponse, error) {
	respType := InstancePoolsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.InstancePool)
	if err != nil {
		return InstancePoolsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InstancePoolsDeletePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InstancePoolsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (InstancePoolsDeleteResponse, error)
}

type instancePoolsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *instancePoolsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *instancePoolsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *instancePoolsDeletePoller) FinalResponse(ctx context.Context) (InstancePoolsDeleteResponse, error) {
	respType := InstancePoolsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InstancePoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *instancePoolsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *instancePoolsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (InstancePoolsDeleteResponse, error) {
	respType := InstancePoolsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return InstancePoolsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InstancePoolsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InstancePoolsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InstancePoolsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (InstancePoolsUpdateResponse, error)
}

type instancePoolsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *instancePoolsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *instancePoolsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *instancePoolsUpdatePoller) FinalResponse(ctx context.Context) (InstancePoolsUpdateResponse, error) {
	respType := InstancePoolsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InstancePool)
	if err != nil {
		return InstancePoolsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *instancePoolsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *instancePoolsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (InstancePoolsUpdateResponse, error) {
	respType := InstancePoolsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.InstancePool)
	if err != nil {
		return InstancePoolsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// JobAgentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final JobAgentsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (JobAgentsCreateOrUpdateResponse, error)
}

type jobAgentsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *jobAgentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *jobAgentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *jobAgentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (JobAgentsCreateOrUpdateResponse, error) {
	respType := JobAgentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobAgent)
	if err != nil {
		return JobAgentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *jobAgentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *jobAgentsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (JobAgentsCreateOrUpdateResponse, error) {
	respType := JobAgentsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.JobAgent)
	if err != nil {
		return JobAgentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// JobAgentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final JobAgentsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (JobAgentsDeleteResponse, error)
}

type jobAgentsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *jobAgentsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *jobAgentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *jobAgentsDeletePoller) FinalResponse(ctx context.Context) (JobAgentsDeleteResponse, error) {
	respType := JobAgentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return JobAgentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *jobAgentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *jobAgentsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (JobAgentsDeleteResponse, error) {
	respType := JobAgentsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return JobAgentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// JobAgentsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobAgentsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final JobAgentsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (JobAgentsUpdateResponse, error)
}

type jobAgentsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *jobAgentsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *jobAgentsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *jobAgentsUpdatePoller) FinalResponse(ctx context.Context) (JobAgentsUpdateResponse, error) {
	respType := JobAgentsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobAgent)
	if err != nil {
		return JobAgentsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *jobAgentsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *jobAgentsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (JobAgentsUpdateResponse, error) {
	respType := JobAgentsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.JobAgent)
	if err != nil {
		return JobAgentsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// JobExecutionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type JobExecutionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final JobExecutionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (JobExecutionsCreateOrUpdateResponse, error)
}

type jobExecutionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *jobExecutionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *jobExecutionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *jobExecutionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (JobExecutionsCreateOrUpdateResponse, error) {
	respType := JobExecutionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobExecution)
	if err != nil {
		return JobExecutionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *jobExecutionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *jobExecutionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (JobExecutionsCreateOrUpdateResponse, error) {
	respType := JobExecutionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.JobExecution)
	if err != nil {
		return JobExecutionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// JobExecutionsCreatePoller provides polling facilities until the operation reaches a terminal state.
type JobExecutionsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final JobExecutionsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (JobExecutionsCreateResponse, error)
}

type jobExecutionsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *jobExecutionsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *jobExecutionsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *jobExecutionsCreatePoller) FinalResponse(ctx context.Context) (JobExecutionsCreateResponse, error) {
	respType := JobExecutionsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.JobExecution)
	if err != nil {
		return JobExecutionsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *jobExecutionsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *jobExecutionsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (JobExecutionsCreateResponse, error) {
	respType := JobExecutionsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.JobExecution)
	if err != nil {
		return JobExecutionsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LedgerDigestUploadsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LedgerDigestUploadsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LedgerDigestUploadsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (LedgerDigestUploadsCreateOrUpdateResponse, error)
}

type ledgerDigestUploadsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *ledgerDigestUploadsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *ledgerDigestUploadsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ledgerDigestUploadsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LedgerDigestUploadsCreateOrUpdateResponse, error) {
	respType := LedgerDigestUploadsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ledgerDigestUploadsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ledgerDigestUploadsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LedgerDigestUploadsCreateOrUpdateResponse, error) {
	respType := LedgerDigestUploadsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LedgerDigestUploadsDisablePoller provides polling facilities until the operation reaches a terminal state.
type LedgerDigestUploadsDisablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LedgerDigestUploadsDisableResponse will be returned.
	FinalResponse(ctx context.Context) (LedgerDigestUploadsDisableResponse, error)
}

type ledgerDigestUploadsDisablePoller struct {
	pt *armcore.LROPoller
}

func (p *ledgerDigestUploadsDisablePoller) Done() bool {
	return p.pt.Done()
}

func (p *ledgerDigestUploadsDisablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ledgerDigestUploadsDisablePoller) FinalResponse(ctx context.Context) (LedgerDigestUploadsDisableResponse, error) {
	respType := LedgerDigestUploadsDisableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsDisableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ledgerDigestUploadsDisablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ledgerDigestUploadsDisablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LedgerDigestUploadsDisableResponse, error) {
	respType := LedgerDigestUploadsDisableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LedgerDigestUploads)
	if err != nil {
		return LedgerDigestUploadsDisableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionBackupsCopyByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsCopyByResourceGroupPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionBackupsCopyByResourceGroupResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionBackupsCopyByResourceGroupResponse, error)
}

type longTermRetentionBackupsCopyByResourceGroupPoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionBackupsCopyByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionBackupsCopyByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionBackupsCopyByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsCopyByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsCopyByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsCopyByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionBackupsCopyByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionBackupsCopyByResourceGroupPoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsCopyByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsCopyByResourceGroupResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsCopyByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionBackupsCopyPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsCopyPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionBackupsCopyResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionBackupsCopyResponse, error)
}

type longTermRetentionBackupsCopyPoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionBackupsCopyPoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionBackupsCopyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionBackupsCopyPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsCopyResponse, error) {
	respType := LongTermRetentionBackupsCopyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsCopyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionBackupsCopyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionBackupsCopyPoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsCopyResponse, error) {
	respType := LongTermRetentionBackupsCopyResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsCopyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionBackupsDeleteByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsDeleteByResourceGroupPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionBackupsDeleteByResourceGroupResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionBackupsDeleteByResourceGroupResponse, error)
}

type longTermRetentionBackupsDeleteByResourceGroupPoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionBackupsDeleteByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionBackupsDeleteByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionBackupsDeleteByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsDeleteByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionBackupsDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionBackupsDeleteByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionBackupsDeleteByResourceGroupPoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsDeleteByResourceGroupResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return LongTermRetentionBackupsDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionBackupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionBackupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionBackupsDeleteResponse, error)
}

type longTermRetentionBackupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionBackupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionBackupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionBackupsDeletePoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsDeleteResponse, error) {
	respType := LongTermRetentionBackupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionBackupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionBackupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionBackupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsDeleteResponse, error) {
	respType := LongTermRetentionBackupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return LongTermRetentionBackupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionBackupsUpdateByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsUpdateByResourceGroupPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionBackupsUpdateByResourceGroupResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionBackupsUpdateByResourceGroupResponse, error)
}

type longTermRetentionBackupsUpdateByResourceGroupPoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionBackupsUpdateByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionBackupsUpdateByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionBackupsUpdateByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsUpdateByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsUpdateByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsUpdateByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionBackupsUpdateByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionBackupsUpdateByResourceGroupPoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsUpdateByResourceGroupResponse, error) {
	respType := LongTermRetentionBackupsUpdateByResourceGroupResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsUpdateByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionBackupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionBackupsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionBackupsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionBackupsUpdateResponse, error)
}

type longTermRetentionBackupsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionBackupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionBackupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionBackupsUpdatePoller) FinalResponse(ctx context.Context) (LongTermRetentionBackupsUpdateResponse, error) {
	respType := LongTermRetentionBackupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionBackupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionBackupsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionBackupsUpdateResponse, error) {
	respType := LongTermRetentionBackupsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionBackupOperationResult)
	if err != nil {
		return LongTermRetentionBackupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse, error)
}

type longTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionManagedInstanceBackupsDeleteByResourceGroupPoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsDeleteByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionManagedInstanceBackupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionManagedInstanceBackupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionManagedInstanceBackupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsDeleteResponse, error)
}

type longTermRetentionManagedInstanceBackupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionManagedInstanceBackupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionManagedInstanceBackupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionManagedInstanceBackupsDeletePoller) FinalResponse(ctx context.Context) (LongTermRetentionManagedInstanceBackupsDeleteResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionManagedInstanceBackupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionManagedInstanceBackupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionManagedInstanceBackupsDeleteResponse, error) {
	respType := LongTermRetentionManagedInstanceBackupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return LongTermRetentionManagedInstanceBackupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LongTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LongTermRetentionPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LongTermRetentionPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (LongTermRetentionPoliciesCreateOrUpdateResponse, error)
}

type longTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *longTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *longTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *longTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := LongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LongTermRetentionPolicy)
	if err != nil {
		return LongTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *longTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *longTermRetentionPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := LongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LongTermRetentionPolicy)
	if err != nil {
		return LongTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedBackupShortTermRetentionPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error)
}

type managedBackupShortTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedBackupShortTermRetentionPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedBackupShortTermRetentionPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedBackupShortTermRetentionPoliciesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedBackupShortTermRetentionPoliciesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesUpdateResponse, error)
}

type managedBackupShortTermRetentionPoliciesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedBackupShortTermRetentionPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedBackupShortTermRetentionPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedBackupShortTermRetentionPoliciesUpdatePoller) FinalResponse(ctx context.Context) (ManagedBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedBackupShortTermRetentionPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedBackupShortTermRetentionPoliciesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedBackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabaseVulnerabilityAssessmentScansInitiateScanPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse, error)
}

type managedDatabaseVulnerabilityAssessmentScansInitiateScanPoller struct {
	pt *armcore.LROPoller
}

func (p *managedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) Done() bool {
	return p.pt.Done()
}

func (p *managedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) FinalResponse(ctx context.Context) (ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedDatabaseVulnerabilityAssessmentScansInitiateScanPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse, error) {
	respType := ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedDatabaseVulnerabilityAssessmentScansInitiateScanResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedDatabasesCompleteRestorePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesCompleteRestorePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedDatabasesCompleteRestoreResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedDatabasesCompleteRestoreResponse, error)
}

type managedDatabasesCompleteRestorePoller struct {
	pt *armcore.LROPoller
}

func (p *managedDatabasesCompleteRestorePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedDatabasesCompleteRestorePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedDatabasesCompleteRestorePoller) FinalResponse(ctx context.Context) (ManagedDatabasesCompleteRestoreResponse, error) {
	respType := ManagedDatabasesCompleteRestoreResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabasesCompleteRestoreResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedDatabasesCompleteRestorePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedDatabasesCompleteRestorePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesCompleteRestoreResponse, error) {
	respType := ManagedDatabasesCompleteRestoreResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedDatabasesCompleteRestoreResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedDatabasesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedDatabasesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedDatabasesCreateOrUpdateResponse, error)
}

type managedDatabasesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedDatabasesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedDatabasesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedDatabasesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedDatabasesCreateOrUpdateResponse, error) {
	respType := ManagedDatabasesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedDatabasesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedDatabasesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesCreateOrUpdateResponse, error) {
	respType := ManagedDatabasesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedDatabasesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedDatabasesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedDatabasesDeleteResponse, error)
}

type managedDatabasesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *managedDatabasesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedDatabasesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedDatabasesDeletePoller) FinalResponse(ctx context.Context) (ManagedDatabasesDeleteResponse, error) {
	respType := ManagedDatabasesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedDatabasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedDatabasesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedDatabasesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesDeleteResponse, error) {
	respType := ManagedDatabasesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedDatabasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedDatabasesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedDatabasesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedDatabasesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedDatabasesUpdateResponse, error)
}

type managedDatabasesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedDatabasesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedDatabasesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedDatabasesUpdatePoller) FinalResponse(ctx context.Context) (ManagedDatabasesUpdateResponse, error) {
	respType := ManagedDatabasesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedDatabasesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedDatabasesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedDatabasesUpdateResponse, error) {
	respType := ManagedDatabasesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedDatabase)
	if err != nil {
		return ManagedDatabasesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceAdministratorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAdministratorsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceAdministratorsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsCreateOrUpdateResponse, error)
}

type managedInstanceAdministratorsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceAdministratorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceAdministratorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceAdministratorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAdministratorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceAdministrator)
	if err != nil {
		return ManagedInstanceAdministratorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceAdministratorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceAdministratorsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAdministratorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAdministratorsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceAdministrator)
	if err != nil {
		return ManagedInstanceAdministratorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceAdministratorsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAdministratorsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceAdministratorsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsDeleteResponse, error)
}

type managedInstanceAdministratorsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceAdministratorsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceAdministratorsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceAdministratorsDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceAdministratorsDeleteResponse, error) {
	respType := ManagedInstanceAdministratorsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceAdministratorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceAdministratorsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceAdministratorsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAdministratorsDeleteResponse, error) {
	respType := ManagedInstanceAdministratorsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstanceAdministratorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse, error)
}

type managedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceAzureADOnlyAuthentication)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceAzureADOnlyAuthenticationsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceAzureADOnlyAuthentication)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceAzureADOnlyAuthenticationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceAzureADOnlyAuthenticationsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse, error)
}

type managedInstanceAzureADOnlyAuthenticationsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceAzureADOnlyAuthenticationsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceAzureADOnlyAuthenticationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceAzureADOnlyAuthenticationsDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceAzureADOnlyAuthenticationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceAzureADOnlyAuthenticationsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstanceAzureADOnlyAuthenticationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceEncryptionProtectorsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse, error)
}

type managedInstanceEncryptionProtectorsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceEncryptionProtectorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceEncryptionProtectorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceEncryptionProtectorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceEncryptionProtector)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceEncryptionProtectorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceEncryptionProtectorsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceEncryptionProtector)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceEncryptionProtectorsRevalidatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceEncryptionProtectorsRevalidatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceEncryptionProtectorsRevalidateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsRevalidateResponse, error)
}

type managedInstanceEncryptionProtectorsRevalidatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceEncryptionProtectorsRevalidatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceEncryptionProtectorsRevalidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceEncryptionProtectorsRevalidatePoller) FinalResponse(ctx context.Context) (ManagedInstanceEncryptionProtectorsRevalidateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsRevalidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceEncryptionProtectorsRevalidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceEncryptionProtectorsRevalidatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceEncryptionProtectorsRevalidateResponse, error) {
	respType := ManagedInstanceEncryptionProtectorsRevalidateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstanceEncryptionProtectorsRevalidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceKeysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceKeysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceKeysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceKeysCreateOrUpdateResponse, error)
}

type managedInstanceKeysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceKeysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceKeysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceKeysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceKeysCreateOrUpdateResponse, error) {
	respType := ManagedInstanceKeysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceKey)
	if err != nil {
		return ManagedInstanceKeysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceKeysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceKeysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceKeysCreateOrUpdateResponse, error) {
	respType := ManagedInstanceKeysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceKey)
	if err != nil {
		return ManagedInstanceKeysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceKeysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceKeysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceKeysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceKeysDeleteResponse, error)
}

type managedInstanceKeysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceKeysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceKeysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceKeysDeletePoller) FinalResponse(ctx context.Context) (ManagedInstanceKeysDeleteResponse, error) {
	respType := ManagedInstanceKeysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceKeysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceKeysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceKeysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceKeysDeleteResponse, error) {
	respType := ManagedInstanceKeysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstanceKeysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse, error)
}

type managedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstanceLongTermRetentionPolicy)
	if err != nil {
		return ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceLongTermRetentionPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstanceLongTermRetentionPolicy)
	if err != nil {
		return ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancePrivateEndpointConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse, error)
}

type managedInstancePrivateEndpointConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstancePrivateEndpointConnection)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstancePrivateEndpointConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstancePrivateEndpointConnection)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstancePrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancePrivateEndpointConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstancePrivateEndpointConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsDeleteResponse, error)
}

type managedInstancePrivateEndpointConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstancePrivateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstancePrivateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstancePrivateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (ManagedInstancePrivateEndpointConnectionsDeleteResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstancePrivateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstancePrivateEndpointConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancePrivateEndpointConnectionsDeleteResponse, error) {
	respType := ManagedInstancePrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstancePrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstanceTdeCertificatesCreatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstanceTdeCertificatesCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstanceTdeCertificatesCreateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstanceTdeCertificatesCreateResponse, error)
}

type managedInstanceTdeCertificatesCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstanceTdeCertificatesCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstanceTdeCertificatesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstanceTdeCertificatesCreatePoller) FinalResponse(ctx context.Context) (ManagedInstanceTdeCertificatesCreateResponse, error) {
	respType := ManagedInstanceTdeCertificatesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstanceTdeCertificatesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstanceTdeCertificatesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstanceTdeCertificatesCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstanceTdeCertificatesCreateResponse, error) {
	respType := ManagedInstanceTdeCertificatesCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstanceTdeCertificatesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstancesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstancesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstancesCreateOrUpdateResponse, error)
}

type managedInstancesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstancesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstancesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstancesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancesCreateOrUpdateResponse, error) {
	respType := ManagedInstancesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstancesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstancesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesCreateOrUpdateResponse, error) {
	respType := ManagedInstancesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstancesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstancesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstancesDeleteResponse, error)
}

type managedInstancesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstancesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstancesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstancesDeletePoller) FinalResponse(ctx context.Context) (ManagedInstancesDeleteResponse, error) {
	respType := ManagedInstancesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstancesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstancesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesDeleteResponse, error) {
	respType := ManagedInstancesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstancesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstancesFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesFailoverPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstancesFailoverResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstancesFailoverResponse, error)
}

type managedInstancesFailoverPoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstancesFailoverPoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstancesFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstancesFailoverPoller) FinalResponse(ctx context.Context) (ManagedInstancesFailoverResponse, error) {
	respType := ManagedInstancesFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ManagedInstancesFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstancesFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstancesFailoverPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesFailoverResponse, error) {
	respType := ManagedInstancesFailoverResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ManagedInstancesFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedInstancesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedInstancesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedInstancesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedInstancesUpdateResponse, error)
}

type managedInstancesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedInstancesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedInstancesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedInstancesUpdatePoller) FinalResponse(ctx context.Context) (ManagedInstancesUpdateResponse, error) {
	respType := ManagedInstancesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedInstancesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedInstancesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedInstancesUpdateResponse, error) {
	respType := ManagedInstancesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedInstance)
	if err != nil {
		return ManagedInstancesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error)
}

type managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse, error)
}

type managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) FinalResponse(ctx context.Context) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse, error) {
	respType := ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedBackupShortTermRetentionPolicy)
	if err != nil {
		return ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ManagedServerSecurityAlertPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse, error)
}

type managedServerSecurityAlertPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *managedServerSecurityAlertPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *managedServerSecurityAlertPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *managedServerSecurityAlertPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ManagedServerSecurityAlertPolicy)
	if err != nil {
		return ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *managedServerSecurityAlertPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *managedServerSecurityAlertPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ManagedServerSecurityAlertPolicy)
	if err != nil {
		return ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OutboundFirewallRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OutboundFirewallRulesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OutboundFirewallRulesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (OutboundFirewallRulesCreateOrUpdateResponse, error)
}

type outboundFirewallRulesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *outboundFirewallRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *outboundFirewallRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *outboundFirewallRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (OutboundFirewallRulesCreateOrUpdateResponse, error) {
	respType := OutboundFirewallRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.OutboundFirewallRule)
	if err != nil {
		return OutboundFirewallRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *outboundFirewallRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *outboundFirewallRulesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OutboundFirewallRulesCreateOrUpdateResponse, error) {
	respType := OutboundFirewallRulesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.OutboundFirewallRule)
	if err != nil {
		return OutboundFirewallRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// OutboundFirewallRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type OutboundFirewallRulesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final OutboundFirewallRulesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (OutboundFirewallRulesDeleteResponse, error)
}

type outboundFirewallRulesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *outboundFirewallRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *outboundFirewallRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *outboundFirewallRulesDeletePoller) FinalResponse(ctx context.Context) (OutboundFirewallRulesDeleteResponse, error) {
	respType := OutboundFirewallRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return OutboundFirewallRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *outboundFirewallRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *outboundFirewallRulesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (OutboundFirewallRulesDeleteResponse, error) {
	respType := OutboundFirewallRulesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return OutboundFirewallRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointConnectionsCreateOrUpdateResponse, error)
}

type privateEndpointConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error)
}

type privateEndpointConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointConnectionsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointConnectionsDeleteResponse, error) {
	respType := PrivateEndpointConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PrivateEndpointConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ReplicationLinksFailoverAllowDataLossPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksFailoverAllowDataLossPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ReplicationLinksFailoverAllowDataLossResponse will be returned.
	FinalResponse(ctx context.Context) (ReplicationLinksFailoverAllowDataLossResponse, error)
}

type replicationLinksFailoverAllowDataLossPoller struct {
	pt *armcore.LROPoller
}

func (p *replicationLinksFailoverAllowDataLossPoller) Done() bool {
	return p.pt.Done()
}

func (p *replicationLinksFailoverAllowDataLossPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *replicationLinksFailoverAllowDataLossPoller) FinalResponse(ctx context.Context) (ReplicationLinksFailoverAllowDataLossResponse, error) {
	respType := ReplicationLinksFailoverAllowDataLossResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *replicationLinksFailoverAllowDataLossPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *replicationLinksFailoverAllowDataLossPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ReplicationLinksFailoverAllowDataLossResponse, error) {
	respType := ReplicationLinksFailoverAllowDataLossResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ReplicationLinksFailoverAllowDataLossResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ReplicationLinksFailoverPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksFailoverPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ReplicationLinksFailoverResponse will be returned.
	FinalResponse(ctx context.Context) (ReplicationLinksFailoverResponse, error)
}

type replicationLinksFailoverPoller struct {
	pt *armcore.LROPoller
}

func (p *replicationLinksFailoverPoller) Done() bool {
	return p.pt.Done()
}

func (p *replicationLinksFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *replicationLinksFailoverPoller) FinalResponse(ctx context.Context) (ReplicationLinksFailoverResponse, error) {
	respType := ReplicationLinksFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *replicationLinksFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *replicationLinksFailoverPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ReplicationLinksFailoverResponse, error) {
	respType := ReplicationLinksFailoverResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ReplicationLinksFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ReplicationLinksUnlinkPoller provides polling facilities until the operation reaches a terminal state.
type ReplicationLinksUnlinkPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ReplicationLinksUnlinkResponse will be returned.
	FinalResponse(ctx context.Context) (ReplicationLinksUnlinkResponse, error)
}

type replicationLinksUnlinkPoller struct {
	pt *armcore.LROPoller
}

func (p *replicationLinksUnlinkPoller) Done() bool {
	return p.pt.Done()
}

func (p *replicationLinksUnlinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *replicationLinksUnlinkPoller) FinalResponse(ctx context.Context) (ReplicationLinksUnlinkResponse, error) {
	respType := ReplicationLinksUnlinkResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationLinksUnlinkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *replicationLinksUnlinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *replicationLinksUnlinkPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ReplicationLinksUnlinkResponse, error) {
	respType := ReplicationLinksUnlinkResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ReplicationLinksUnlinkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RestorePointsCreatePoller provides polling facilities until the operation reaches a terminal state.
type RestorePointsCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RestorePointsCreateResponse will be returned.
	FinalResponse(ctx context.Context) (RestorePointsCreateResponse, error)
}

type restorePointsCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *restorePointsCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *restorePointsCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *restorePointsCreatePoller) FinalResponse(ctx context.Context) (RestorePointsCreateResponse, error) {
	respType := RestorePointsCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RestorePoint)
	if err != nil {
		return RestorePointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *restorePointsCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *restorePointsCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RestorePointsCreateResponse, error) {
	respType := RestorePointsCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.RestorePoint)
	if err != nil {
		return RestorePointsCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerAzureADAdministratorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADAdministratorsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerAzureADAdministratorsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerAzureADAdministratorsCreateOrUpdateResponse, error)
}

type serverAzureADAdministratorsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverAzureADAdministratorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverAzureADAdministratorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverAzureADAdministratorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerAzureADAdministratorsCreateOrUpdateResponse, error) {
	respType := ServerAzureADAdministratorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerAzureADAdministrator)
	if err != nil {
		return ServerAzureADAdministratorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverAzureADAdministratorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverAzureADAdministratorsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADAdministratorsCreateOrUpdateResponse, error) {
	respType := ServerAzureADAdministratorsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerAzureADAdministrator)
	if err != nil {
		return ServerAzureADAdministratorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerAzureADAdministratorsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADAdministratorsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerAzureADAdministratorsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServerAzureADAdministratorsDeleteResponse, error)
}

type serverAzureADAdministratorsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serverAzureADAdministratorsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverAzureADAdministratorsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverAzureADAdministratorsDeletePoller) FinalResponse(ctx context.Context) (ServerAzureADAdministratorsDeleteResponse, error) {
	respType := ServerAzureADAdministratorsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerAzureADAdministratorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverAzureADAdministratorsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverAzureADAdministratorsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADAdministratorsDeleteResponse, error) {
	respType := ServerAzureADAdministratorsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServerAzureADAdministratorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADOnlyAuthenticationsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse, error)
}

type serverAzureADOnlyAuthenticationsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverAzureADOnlyAuthenticationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverAzureADOnlyAuthenticationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverAzureADOnlyAuthenticationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerAzureADOnlyAuthentication)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverAzureADOnlyAuthenticationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverAzureADOnlyAuthenticationsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerAzureADOnlyAuthentication)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerAzureADOnlyAuthenticationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerAzureADOnlyAuthenticationsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerAzureADOnlyAuthenticationsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsDeleteResponse, error)
}

type serverAzureADOnlyAuthenticationsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serverAzureADOnlyAuthenticationsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverAzureADOnlyAuthenticationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverAzureADOnlyAuthenticationsDeletePoller) FinalResponse(ctx context.Context) (ServerAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverAzureADOnlyAuthenticationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverAzureADOnlyAuthenticationsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerAzureADOnlyAuthenticationsDeleteResponse, error) {
	respType := ServerAzureADOnlyAuthenticationsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServerAzureADOnlyAuthenticationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerBlobAuditingPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerBlobAuditingPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerBlobAuditingPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerBlobAuditingPoliciesCreateOrUpdateResponse, error)
}

type serverBlobAuditingPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverBlobAuditingPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverBlobAuditingPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverBlobAuditingPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerBlobAuditingPolicy)
	if err != nil {
		return ServerBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverBlobAuditingPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverBlobAuditingPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerBlobAuditingPoliciesCreateOrUpdateResponse, error) {
	respType := ServerBlobAuditingPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerBlobAuditingPolicy)
	if err != nil {
		return ServerBlobAuditingPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerCommunicationLinksCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerCommunicationLinksCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerCommunicationLinksCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerCommunicationLinksCreateOrUpdateResponse, error)
}

type serverCommunicationLinksCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverCommunicationLinksCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverCommunicationLinksCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverCommunicationLinksCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerCommunicationLinksCreateOrUpdateResponse, error) {
	respType := ServerCommunicationLinksCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerCommunicationLink)
	if err != nil {
		return ServerCommunicationLinksCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverCommunicationLinksCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverCommunicationLinksCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerCommunicationLinksCreateOrUpdateResponse, error) {
	respType := ServerCommunicationLinksCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerCommunicationLink)
	if err != nil {
		return ServerCommunicationLinksCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerDNSAliasesAcquirePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesAcquirePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerDNSAliasesAcquireResponse will be returned.
	FinalResponse(ctx context.Context) (ServerDNSAliasesAcquireResponse, error)
}

type serverDNSAliasesAcquirePoller struct {
	pt *armcore.LROPoller
}

func (p *serverDNSAliasesAcquirePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverDNSAliasesAcquirePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverDNSAliasesAcquirePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesAcquireResponse, error) {
	respType := ServerDNSAliasesAcquireResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesAcquireResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverDNSAliasesAcquirePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverDNSAliasesAcquirePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerDNSAliasesAcquireResponse, error) {
	respType := ServerDNSAliasesAcquireResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesAcquireResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerDNSAliasesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerDNSAliasesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerDNSAliasesCreateOrUpdateResponse, error)
}

type serverDNSAliasesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverDNSAliasesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverDNSAliasesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverDNSAliasesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesCreateOrUpdateResponse, error) {
	respType := ServerDNSAliasesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverDNSAliasesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverDNSAliasesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerDNSAliasesCreateOrUpdateResponse, error) {
	respType := ServerDNSAliasesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerDNSAlias)
	if err != nil {
		return ServerDNSAliasesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerDNSAliasesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerDNSAliasesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerDNSAliasesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServerDNSAliasesDeleteResponse, error)
}

type serverDNSAliasesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serverDNSAliasesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverDNSAliasesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverDNSAliasesDeletePoller) FinalResponse(ctx context.Context) (ServerDNSAliasesDeleteResponse, error) {
	respType := ServerDNSAliasesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerDNSAliasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverDNSAliasesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverDNSAliasesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerDNSAliasesDeleteResponse, error) {
	respType := ServerDNSAliasesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServerDNSAliasesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerDevOpsAuditSettingsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerDevOpsAuditSettingsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerDevOpsAuditSettingsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerDevOpsAuditSettingsCreateOrUpdateResponse, error)
}

type serverDevOpsAuditSettingsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverDevOpsAuditSettingsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverDevOpsAuditSettingsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverDevOpsAuditSettingsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerDevOpsAuditSettingsCreateOrUpdateResponse, error) {
	respType := ServerDevOpsAuditSettingsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerDevOpsAuditingSettings)
	if err != nil {
		return ServerDevOpsAuditSettingsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverDevOpsAuditSettingsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverDevOpsAuditSettingsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerDevOpsAuditSettingsCreateOrUpdateResponse, error) {
	respType := ServerDevOpsAuditSettingsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerDevOpsAuditingSettings)
	if err != nil {
		return ServerDevOpsAuditSettingsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerKeysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerKeysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerKeysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerKeysCreateOrUpdateResponse, error)
}

type serverKeysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverKeysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverKeysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverKeysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerKeysCreateOrUpdateResponse, error) {
	respType := ServerKeysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerKey)
	if err != nil {
		return ServerKeysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverKeysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverKeysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerKeysCreateOrUpdateResponse, error) {
	respType := ServerKeysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerKey)
	if err != nil {
		return ServerKeysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerKeysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerKeysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerKeysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServerKeysDeleteResponse, error)
}

type serverKeysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serverKeysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverKeysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverKeysDeletePoller) FinalResponse(ctx context.Context) (ServerKeysDeleteResponse, error) {
	respType := ServerKeysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerKeysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverKeysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverKeysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerKeysDeleteResponse, error) {
	respType := ServerKeysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServerKeysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerSecurityAlertPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerSecurityAlertPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerSecurityAlertPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerSecurityAlertPoliciesCreateOrUpdateResponse, error)
}

type serverSecurityAlertPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverSecurityAlertPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverSecurityAlertPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverSecurityAlertPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return ServerSecurityAlertPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverSecurityAlertPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverSecurityAlertPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerSecurityAlertPoliciesCreateOrUpdateResponse, error) {
	respType := ServerSecurityAlertPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerSecurityAlertPolicy)
	if err != nil {
		return ServerSecurityAlertPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerTrustGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServerTrustGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerTrustGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServerTrustGroupsCreateOrUpdateResponse, error)
}

type serverTrustGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serverTrustGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverTrustGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverTrustGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServerTrustGroupsCreateOrUpdateResponse, error) {
	respType := ServerTrustGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServerTrustGroup)
	if err != nil {
		return ServerTrustGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverTrustGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverTrustGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerTrustGroupsCreateOrUpdateResponse, error) {
	respType := ServerTrustGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServerTrustGroup)
	if err != nil {
		return ServerTrustGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServerTrustGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServerTrustGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServerTrustGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServerTrustGroupsDeleteResponse, error)
}

type serverTrustGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serverTrustGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serverTrustGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serverTrustGroupsDeletePoller) FinalResponse(ctx context.Context) (ServerTrustGroupsDeleteResponse, error) {
	respType := ServerTrustGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServerTrustGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serverTrustGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serverTrustGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServerTrustGroupsDeleteResponse, error) {
	respType := ServerTrustGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServerTrustGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServersCreateOrUpdateResponse, error)
}

type serversCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serversCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serversCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serversCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServersCreateOrUpdateResponse, error) {
	respType := ServersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Server)
	if err != nil {
		return ServersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serversCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serversCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServersCreateOrUpdateResponse, error) {
	respType := ServersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Server)
	if err != nil {
		return ServersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServersDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServersDeleteResponse, error)
}

type serversDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serversDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serversDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serversDeletePoller) FinalResponse(ctx context.Context) (ServersDeleteResponse, error) {
	respType := ServersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serversDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serversDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServersDeleteResponse, error) {
	respType := ServersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServersImportDatabasePoller provides polling facilities until the operation reaches a terminal state.
type ServersImportDatabasePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServersImportDatabaseResponse will be returned.
	FinalResponse(ctx context.Context) (ServersImportDatabaseResponse, error)
}

type serversImportDatabasePoller struct {
	pt *armcore.LROPoller
}

func (p *serversImportDatabasePoller) Done() bool {
	return p.pt.Done()
}

func (p *serversImportDatabasePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serversImportDatabasePoller) FinalResponse(ctx context.Context) (ServersImportDatabaseResponse, error) {
	respType := ServersImportDatabaseResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ImportExportOperationResult)
	if err != nil {
		return ServersImportDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serversImportDatabasePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serversImportDatabasePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServersImportDatabaseResponse, error) {
	respType := ServersImportDatabaseResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ImportExportOperationResult)
	if err != nil {
		return ServersImportDatabaseResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServersUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServersUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServersUpdateResponse, error)
}

type serversUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serversUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serversUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serversUpdatePoller) FinalResponse(ctx context.Context) (ServersUpdateResponse, error) {
	respType := ServersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Server)
	if err != nil {
		return ServersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serversUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serversUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServersUpdateResponse, error) {
	respType := ServersUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Server)
	if err != nil {
		return ServersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncAgentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncAgentsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncAgentsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SyncAgentsCreateOrUpdateResponse, error)
}

type syncAgentsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *syncAgentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncAgentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncAgentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncAgentsCreateOrUpdateResponse, error) {
	respType := SyncAgentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncAgent)
	if err != nil {
		return SyncAgentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncAgentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncAgentsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncAgentsCreateOrUpdateResponse, error) {
	respType := SyncAgentsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SyncAgent)
	if err != nil {
		return SyncAgentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncAgentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncAgentsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncAgentsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SyncAgentsDeleteResponse, error)
}

type syncAgentsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *syncAgentsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncAgentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncAgentsDeletePoller) FinalResponse(ctx context.Context) (SyncAgentsDeleteResponse, error) {
	respType := SyncAgentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncAgentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncAgentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncAgentsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncAgentsDeleteResponse, error) {
	respType := SyncAgentsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SyncAgentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SyncGroupsCreateOrUpdateResponse, error)
}

type syncGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *syncGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncGroupsCreateOrUpdateResponse, error) {
	respType := SyncGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsCreateOrUpdateResponse, error) {
	respType := SyncGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SyncGroupsDeleteResponse, error)
}

type syncGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *syncGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncGroupsDeletePoller) FinalResponse(ctx context.Context) (SyncGroupsDeleteResponse, error) {
	respType := SyncGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsDeleteResponse, error) {
	respType := SyncGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SyncGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncGroupsRefreshHubSchemaPoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsRefreshHubSchemaPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncGroupsRefreshHubSchemaResponse will be returned.
	FinalResponse(ctx context.Context) (SyncGroupsRefreshHubSchemaResponse, error)
}

type syncGroupsRefreshHubSchemaPoller struct {
	pt *armcore.LROPoller
}

func (p *syncGroupsRefreshHubSchemaPoller) Done() bool {
	return p.pt.Done()
}

func (p *syncGroupsRefreshHubSchemaPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncGroupsRefreshHubSchemaPoller) FinalResponse(ctx context.Context) (SyncGroupsRefreshHubSchemaResponse, error) {
	respType := SyncGroupsRefreshHubSchemaResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncGroupsRefreshHubSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncGroupsRefreshHubSchemaPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncGroupsRefreshHubSchemaPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsRefreshHubSchemaResponse, error) {
	respType := SyncGroupsRefreshHubSchemaResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SyncGroupsRefreshHubSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncGroupsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncGroupsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncGroupsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SyncGroupsUpdateResponse, error)
}

type syncGroupsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *syncGroupsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncGroupsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncGroupsUpdatePoller) FinalResponse(ctx context.Context) (SyncGroupsUpdateResponse, error) {
	respType := SyncGroupsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncGroupsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncGroupsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncGroupsUpdateResponse, error) {
	respType := SyncGroupsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SyncGroup)
	if err != nil {
		return SyncGroupsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncMembersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncMembersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SyncMembersCreateOrUpdateResponse, error)
}

type syncMembersCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *syncMembersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncMembersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncMembersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SyncMembersCreateOrUpdateResponse, error) {
	respType := SyncMembersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncMember)
	if err != nil {
		return SyncMembersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncMembersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncMembersCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersCreateOrUpdateResponse, error) {
	respType := SyncMembersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SyncMember)
	if err != nil {
		return SyncMembersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncMembersDeletePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncMembersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SyncMembersDeleteResponse, error)
}

type syncMembersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *syncMembersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncMembersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncMembersDeletePoller) FinalResponse(ctx context.Context) (SyncMembersDeleteResponse, error) {
	respType := SyncMembersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncMembersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncMembersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncMembersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersDeleteResponse, error) {
	respType := SyncMembersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SyncMembersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncMembersRefreshMemberSchemaPoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersRefreshMemberSchemaPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncMembersRefreshMemberSchemaResponse will be returned.
	FinalResponse(ctx context.Context) (SyncMembersRefreshMemberSchemaResponse, error)
}

type syncMembersRefreshMemberSchemaPoller struct {
	pt *armcore.LROPoller
}

func (p *syncMembersRefreshMemberSchemaPoller) Done() bool {
	return p.pt.Done()
}

func (p *syncMembersRefreshMemberSchemaPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncMembersRefreshMemberSchemaPoller) FinalResponse(ctx context.Context) (SyncMembersRefreshMemberSchemaResponse, error) {
	respType := SyncMembersRefreshMemberSchemaResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SyncMembersRefreshMemberSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncMembersRefreshMemberSchemaPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncMembersRefreshMemberSchemaPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersRefreshMemberSchemaResponse, error) {
	respType := SyncMembersRefreshMemberSchemaResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SyncMembersRefreshMemberSchemaResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SyncMembersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SyncMembersUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SyncMembersUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SyncMembersUpdateResponse, error)
}

type syncMembersUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *syncMembersUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *syncMembersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *syncMembersUpdatePoller) FinalResponse(ctx context.Context) (SyncMembersUpdateResponse, error) {
	respType := SyncMembersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SyncMember)
	if err != nil {
		return SyncMembersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *syncMembersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *syncMembersUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SyncMembersUpdateResponse, error) {
	respType := SyncMembersUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SyncMember)
	if err != nil {
		return SyncMembersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// TdeCertificatesCreatePoller provides polling facilities until the operation reaches a terminal state.
type TdeCertificatesCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final TdeCertificatesCreateResponse will be returned.
	FinalResponse(ctx context.Context) (TdeCertificatesCreateResponse, error)
}

type tdeCertificatesCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *tdeCertificatesCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *tdeCertificatesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *tdeCertificatesCreatePoller) FinalResponse(ctx context.Context) (TdeCertificatesCreateResponse, error) {
	respType := TdeCertificatesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TdeCertificatesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *tdeCertificatesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *tdeCertificatesCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (TdeCertificatesCreateResponse, error) {
	respType := TdeCertificatesCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return TdeCertificatesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualClustersDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualClustersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualClustersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualClustersDeleteResponse, error)
}

type virtualClustersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualClustersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualClustersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualClustersDeletePoller) FinalResponse(ctx context.Context) (VirtualClustersDeleteResponse, error) {
	respType := VirtualClustersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualClustersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualClustersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualClustersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualClustersDeleteResponse, error) {
	respType := VirtualClustersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualClustersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualClustersUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualClustersUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualClustersUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualClustersUpdateResponse, error)
}

type virtualClustersUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualClustersUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualClustersUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualClustersUpdatePoller) FinalResponse(ctx context.Context) (VirtualClustersUpdateResponse, error) {
	respType := VirtualClustersUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualCluster)
	if err != nil {
		return VirtualClustersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualClustersUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualClustersUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualClustersUpdateResponse, error) {
	respType := VirtualClustersUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualCluster)
	if err != nil {
		return VirtualClustersUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkRulesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkRulesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkRulesCreateOrUpdateResponse, error)
}

type virtualNetworkRulesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkRulesCreateOrUpdateResponse, error) {
	respType := VirtualNetworkRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkRule)
	if err != nil {
		return VirtualNetworkRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkRulesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkRulesCreateOrUpdateResponse, error) {
	respType := VirtualNetworkRulesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkRule)
	if err != nil {
		return VirtualNetworkRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkRulesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkRulesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkRulesDeleteResponse, error)
}

type virtualNetworkRulesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkRulesDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkRulesDeleteResponse, error) {
	respType := VirtualNetworkRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkRulesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkRulesDeleteResponse, error) {
	respType := VirtualNetworkRulesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworkRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// WorkloadClassifiersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadClassifiersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final WorkloadClassifiersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (WorkloadClassifiersCreateOrUpdateResponse, error)
}

type workloadClassifiersCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *workloadClassifiersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *workloadClassifiersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *workloadClassifiersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkloadClassifiersCreateOrUpdateResponse, error) {
	respType := WorkloadClassifiersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadClassifier)
	if err != nil {
		return WorkloadClassifiersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *workloadClassifiersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *workloadClassifiersCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (WorkloadClassifiersCreateOrUpdateResponse, error) {
	respType := WorkloadClassifiersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.WorkloadClassifier)
	if err != nil {
		return WorkloadClassifiersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// WorkloadClassifiersDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadClassifiersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final WorkloadClassifiersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (WorkloadClassifiersDeleteResponse, error)
}

type workloadClassifiersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *workloadClassifiersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *workloadClassifiersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *workloadClassifiersDeletePoller) FinalResponse(ctx context.Context) (WorkloadClassifiersDeleteResponse, error) {
	respType := WorkloadClassifiersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadClassifiersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *workloadClassifiersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *workloadClassifiersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (WorkloadClassifiersDeleteResponse, error) {
	respType := WorkloadClassifiersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return WorkloadClassifiersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// WorkloadGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final WorkloadGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (WorkloadGroupsCreateOrUpdateResponse, error)
}

type workloadGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *workloadGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *workloadGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *workloadGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (WorkloadGroupsCreateOrUpdateResponse, error) {
	respType := WorkloadGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.WorkloadGroup)
	if err != nil {
		return WorkloadGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *workloadGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *workloadGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (WorkloadGroupsCreateOrUpdateResponse, error) {
	respType := WorkloadGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.WorkloadGroup)
	if err != nil {
		return WorkloadGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// WorkloadGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type WorkloadGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final WorkloadGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (WorkloadGroupsDeleteResponse, error)
}

type workloadGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *workloadGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *workloadGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *workloadGroupsDeletePoller) FinalResponse(ctx context.Context) (WorkloadGroupsDeleteResponse, error) {
	respType := WorkloadGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WorkloadGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *workloadGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *workloadGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (WorkloadGroupsDeleteResponse, error) {
	respType := WorkloadGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return WorkloadGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
