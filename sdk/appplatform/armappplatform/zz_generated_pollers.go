//go:build go1.13
// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armappplatform

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// AppsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AppsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AppsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (AppsCreateOrUpdateResponse, error)
}

type appsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *appsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *appsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *appsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (AppsCreateOrUpdateResponse, error) {
	respType := AppsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AppResource)
	if err != nil {
		return AppsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *appsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *appsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AppsCreateOrUpdateResponse, error) {
	respType := AppsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AppResource)
	if err != nil {
		return AppsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AppsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AppsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AppsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (AppsDeleteResponse, error)
}

type appsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *appsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *appsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *appsDeletePoller) FinalResponse(ctx context.Context) (AppsDeleteResponse, error) {
	respType := AppsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AppsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *appsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *appsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AppsDeleteResponse, error) {
	respType := AppsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return AppsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AppsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AppsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AppsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (AppsUpdateResponse, error)
}

type appsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *appsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *appsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *appsUpdatePoller) FinalResponse(ctx context.Context) (AppsUpdateResponse, error) {
	respType := AppsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AppResource)
	if err != nil {
		return AppsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *appsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *appsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AppsUpdateResponse, error) {
	respType := AppsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AppResource)
	if err != nil {
		return AppsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BindingsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BindingsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BindingsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (BindingsCreateOrUpdateResponse, error)
}

type bindingsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *bindingsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *bindingsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *bindingsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BindingsCreateOrUpdateResponse, error) {
	respType := BindingsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BindingResource)
	if err != nil {
		return BindingsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *bindingsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bindingsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (BindingsCreateOrUpdateResponse, error) {
	respType := BindingsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.BindingResource)
	if err != nil {
		return BindingsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BindingsDeletePoller provides polling facilities until the operation reaches a terminal state.
type BindingsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BindingsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (BindingsDeleteResponse, error)
}

type bindingsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *bindingsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *bindingsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *bindingsDeletePoller) FinalResponse(ctx context.Context) (BindingsDeleteResponse, error) {
	respType := BindingsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BindingsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *bindingsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bindingsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (BindingsDeleteResponse, error) {
	respType := BindingsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return BindingsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BindingsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BindingsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BindingsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (BindingsUpdateResponse, error)
}

type bindingsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *bindingsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *bindingsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *bindingsUpdatePoller) FinalResponse(ctx context.Context) (BindingsUpdateResponse, error) {
	respType := BindingsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BindingResource)
	if err != nil {
		return BindingsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *bindingsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bindingsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (BindingsUpdateResponse, error) {
	respType := BindingsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.BindingResource)
	if err != nil {
		return BindingsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CertificatesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CertificatesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CertificatesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (CertificatesCreateOrUpdateResponse, error)
}

type certificatesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *certificatesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *certificatesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *certificatesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (CertificatesCreateOrUpdateResponse, error) {
	respType := CertificatesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CertificateResource)
	if err != nil {
		return CertificatesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *certificatesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *certificatesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CertificatesCreateOrUpdateResponse, error) {
	respType := CertificatesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CertificateResource)
	if err != nil {
		return CertificatesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CertificatesDeletePoller provides polling facilities until the operation reaches a terminal state.
type CertificatesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CertificatesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (CertificatesDeleteResponse, error)
}

type certificatesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *certificatesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *certificatesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *certificatesDeletePoller) FinalResponse(ctx context.Context) (CertificatesDeleteResponse, error) {
	respType := CertificatesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CertificatesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *certificatesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *certificatesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CertificatesDeleteResponse, error) {
	respType := CertificatesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return CertificatesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConfigServersUpdatePatchPoller provides polling facilities until the operation reaches a terminal state.
type ConfigServersUpdatePatchPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConfigServersUpdatePatchResponse will be returned.
	FinalResponse(ctx context.Context) (ConfigServersUpdatePatchResponse, error)
}

type configServersUpdatePatchPoller struct {
	pt *armcore.LROPoller
}

func (p *configServersUpdatePatchPoller) Done() bool {
	return p.pt.Done()
}

func (p *configServersUpdatePatchPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *configServersUpdatePatchPoller) FinalResponse(ctx context.Context) (ConfigServersUpdatePatchResponse, error) {
	respType := ConfigServersUpdatePatchResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConfigServerResource)
	if err != nil {
		return ConfigServersUpdatePatchResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *configServersUpdatePatchPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *configServersUpdatePatchPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersUpdatePatchResponse, error) {
	respType := ConfigServersUpdatePatchResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConfigServerResource)
	if err != nil {
		return ConfigServersUpdatePatchResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConfigServersUpdatePutPoller provides polling facilities until the operation reaches a terminal state.
type ConfigServersUpdatePutPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConfigServersUpdatePutResponse will be returned.
	FinalResponse(ctx context.Context) (ConfigServersUpdatePutResponse, error)
}

type configServersUpdatePutPoller struct {
	pt *armcore.LROPoller
}

func (p *configServersUpdatePutPoller) Done() bool {
	return p.pt.Done()
}

func (p *configServersUpdatePutPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *configServersUpdatePutPoller) FinalResponse(ctx context.Context) (ConfigServersUpdatePutResponse, error) {
	respType := ConfigServersUpdatePutResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConfigServerResource)
	if err != nil {
		return ConfigServersUpdatePutResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *configServersUpdatePutPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *configServersUpdatePutPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersUpdatePutResponse, error) {
	respType := ConfigServersUpdatePutResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConfigServerResource)
	if err != nil {
		return ConfigServersUpdatePutResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConfigServersValidatePoller provides polling facilities until the operation reaches a terminal state.
type ConfigServersValidatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConfigServersValidateResponse will be returned.
	FinalResponse(ctx context.Context) (ConfigServersValidateResponse, error)
}

type configServersValidatePoller struct {
	pt *armcore.LROPoller
}

func (p *configServersValidatePoller) Done() bool {
	return p.pt.Done()
}

func (p *configServersValidatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *configServersValidatePoller) FinalResponse(ctx context.Context) (ConfigServersValidateResponse, error) {
	respType := ConfigServersValidateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConfigServerSettingsValidateResult)
	if err != nil {
		return ConfigServersValidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *configServersValidatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *configServersValidatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConfigServersValidateResponse, error) {
	respType := ConfigServersValidateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConfigServerSettingsValidateResult)
	if err != nil {
		return ConfigServersValidateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomDomainsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomDomainsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (CustomDomainsCreateOrUpdateResponse, error)
}

type customDomainsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *customDomainsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *customDomainsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *customDomainsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (CustomDomainsCreateOrUpdateResponse, error) {
	respType := CustomDomainsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomainResource)
	if err != nil {
		return CustomDomainsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *customDomainsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customDomainsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsCreateOrUpdateResponse, error) {
	respType := CustomDomainsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CustomDomainResource)
	if err != nil {
		return CustomDomainsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomDomainsDeletePoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomDomainsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (CustomDomainsDeleteResponse, error)
}

type customDomainsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *customDomainsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *customDomainsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *customDomainsDeletePoller) FinalResponse(ctx context.Context) (CustomDomainsDeleteResponse, error) {
	respType := CustomDomainsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CustomDomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *customDomainsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customDomainsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsDeleteResponse, error) {
	respType := CustomDomainsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return CustomDomainsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// CustomDomainsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type CustomDomainsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final CustomDomainsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (CustomDomainsUpdateResponse, error)
}

type customDomainsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *customDomainsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *customDomainsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *customDomainsUpdatePoller) FinalResponse(ctx context.Context) (CustomDomainsUpdateResponse, error) {
	respType := CustomDomainsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CustomDomainResource)
	if err != nil {
		return CustomDomainsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *customDomainsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *customDomainsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (CustomDomainsUpdateResponse, error) {
	respType := CustomDomainsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.CustomDomainResource)
	if err != nil {
		return CustomDomainsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DeploymentsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DeploymentsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DeploymentsCreateOrUpdateResponse, error)
}

type deploymentsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *deploymentsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *deploymentsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *deploymentsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DeploymentsCreateOrUpdateResponse, error) {
	respType := DeploymentsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentResource)
	if err != nil {
		return DeploymentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *deploymentsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *deploymentsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsCreateOrUpdateResponse, error) {
	respType := DeploymentsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DeploymentResource)
	if err != nil {
		return DeploymentsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DeploymentsDeletePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DeploymentsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (DeploymentsDeleteResponse, error)
}

type deploymentsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *deploymentsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *deploymentsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *deploymentsDeletePoller) FinalResponse(ctx context.Context) (DeploymentsDeleteResponse, error) {
	respType := DeploymentsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *deploymentsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *deploymentsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsDeleteResponse, error) {
	respType := DeploymentsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DeploymentsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DeploymentsRestartPoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsRestartPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DeploymentsRestartResponse will be returned.
	FinalResponse(ctx context.Context) (DeploymentsRestartResponse, error)
}

type deploymentsRestartPoller struct {
	pt *armcore.LROPoller
}

func (p *deploymentsRestartPoller) Done() bool {
	return p.pt.Done()
}

func (p *deploymentsRestartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *deploymentsRestartPoller) FinalResponse(ctx context.Context) (DeploymentsRestartResponse, error) {
	respType := DeploymentsRestartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsRestartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *deploymentsRestartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *deploymentsRestartPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsRestartResponse, error) {
	respType := DeploymentsRestartResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DeploymentsRestartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DeploymentsStartPoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsStartPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DeploymentsStartResponse will be returned.
	FinalResponse(ctx context.Context) (DeploymentsStartResponse, error)
}

type deploymentsStartPoller struct {
	pt *armcore.LROPoller
}

func (p *deploymentsStartPoller) Done() bool {
	return p.pt.Done()
}

func (p *deploymentsStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *deploymentsStartPoller) FinalResponse(ctx context.Context) (DeploymentsStartResponse, error) {
	respType := DeploymentsStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *deploymentsStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *deploymentsStartPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsStartResponse, error) {
	respType := DeploymentsStartResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DeploymentsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DeploymentsStopPoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsStopPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DeploymentsStopResponse will be returned.
	FinalResponse(ctx context.Context) (DeploymentsStopResponse, error)
}

type deploymentsStopPoller struct {
	pt *armcore.LROPoller
}

func (p *deploymentsStopPoller) Done() bool {
	return p.pt.Done()
}

func (p *deploymentsStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *deploymentsStopPoller) FinalResponse(ctx context.Context) (DeploymentsStopResponse, error) {
	respType := DeploymentsStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeploymentsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *deploymentsStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *deploymentsStopPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsStopResponse, error) {
	respType := DeploymentsStopResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DeploymentsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DeploymentsUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DeploymentsUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DeploymentsUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DeploymentsUpdateResponse, error)
}

type deploymentsUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *deploymentsUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *deploymentsUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *deploymentsUpdatePoller) FinalResponse(ctx context.Context) (DeploymentsUpdateResponse, error) {
	respType := DeploymentsUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DeploymentResource)
	if err != nil {
		return DeploymentsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *deploymentsUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *deploymentsUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DeploymentsUpdateResponse, error) {
	respType := DeploymentsUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DeploymentResource)
	if err != nil {
		return DeploymentsUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MonitoringSettingsUpdatePatchPoller provides polling facilities until the operation reaches a terminal state.
type MonitoringSettingsUpdatePatchPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MonitoringSettingsUpdatePatchResponse will be returned.
	FinalResponse(ctx context.Context) (MonitoringSettingsUpdatePatchResponse, error)
}

type monitoringSettingsUpdatePatchPoller struct {
	pt *armcore.LROPoller
}

func (p *monitoringSettingsUpdatePatchPoller) Done() bool {
	return p.pt.Done()
}

func (p *monitoringSettingsUpdatePatchPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *monitoringSettingsUpdatePatchPoller) FinalResponse(ctx context.Context) (MonitoringSettingsUpdatePatchResponse, error) {
	respType := MonitoringSettingsUpdatePatchResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MonitoringSettingResource)
	if err != nil {
		return MonitoringSettingsUpdatePatchResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *monitoringSettingsUpdatePatchPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *monitoringSettingsUpdatePatchPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MonitoringSettingsUpdatePatchResponse, error) {
	respType := MonitoringSettingsUpdatePatchResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.MonitoringSettingResource)
	if err != nil {
		return MonitoringSettingsUpdatePatchResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// MonitoringSettingsUpdatePutPoller provides polling facilities until the operation reaches a terminal state.
type MonitoringSettingsUpdatePutPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final MonitoringSettingsUpdatePutResponse will be returned.
	FinalResponse(ctx context.Context) (MonitoringSettingsUpdatePutResponse, error)
}

type monitoringSettingsUpdatePutPoller struct {
	pt *armcore.LROPoller
}

func (p *monitoringSettingsUpdatePutPoller) Done() bool {
	return p.pt.Done()
}

func (p *monitoringSettingsUpdatePutPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *monitoringSettingsUpdatePutPoller) FinalResponse(ctx context.Context) (MonitoringSettingsUpdatePutResponse, error) {
	respType := MonitoringSettingsUpdatePutResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.MonitoringSettingResource)
	if err != nil {
		return MonitoringSettingsUpdatePutResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *monitoringSettingsUpdatePutPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *monitoringSettingsUpdatePutPoller) pollUntilDone(ctx context.Context, freq time.Duration) (MonitoringSettingsUpdatePutResponse, error) {
	respType := MonitoringSettingsUpdatePutResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.MonitoringSettingResource)
	if err != nil {
		return MonitoringSettingsUpdatePutResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServicesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServicesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServicesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServicesCreateOrUpdateResponse, error)
}

type servicesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *servicesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *servicesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *servicesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServicesCreateOrUpdateResponse, error) {
	respType := ServicesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServiceResource)
	if err != nil {
		return ServicesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *servicesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *servicesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServicesCreateOrUpdateResponse, error) {
	respType := ServicesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServiceResource)
	if err != nil {
		return ServicesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServicesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServicesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServicesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServicesDeleteResponse, error)
}

type servicesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *servicesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *servicesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *servicesDeletePoller) FinalResponse(ctx context.Context) (ServicesDeleteResponse, error) {
	respType := ServicesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *servicesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *servicesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServicesDeleteResponse, error) {
	respType := ServicesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServicesUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServicesUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServicesUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServicesUpdateResponse, error)
}

type servicesUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *servicesUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *servicesUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *servicesUpdatePoller) FinalResponse(ctx context.Context) (ServicesUpdateResponse, error) {
	respType := ServicesUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServiceResource)
	if err != nil {
		return ServicesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *servicesUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *servicesUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServicesUpdateResponse, error) {
	respType := ServicesUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServiceResource)
	if err != nil {
		return ServicesUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
